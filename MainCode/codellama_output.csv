Example,Generated Java Code
1,"import java.math.BigInteger;
import java.nio.file.Files;
import java.security.MessageDigest;
import java.util.Arrays;

public class Sha256Hash {
    private static final byte[] ZERO_HASH = new byte[32]; // 32 bytes for SHA-256 hash
    
    private byte[] bytes;
    
    public Sha256Hash(byte[] bytes) {
        this.bytes = bytes;
    }
    
    public static Sha256Hash ZERO_HASH() {
        return new Sha256Hash(ZERO_HASH);
    }
    
    public int hashCode() {
        return Arrays.hashCode(bytes);
    }
    
    public boolean equals(Object obj) {
        if (obj instanceof Sha256Hash) {
            byte[] otherBytes = ((Sha256Hash) obj).getBytes();
            return Arrays.equals(bytes, otherBytes);
        } else {
            return false;
        }
    }
    
    public static Sha256Hash create() throws Exception {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        byte[] bytes = Files.readAllBytes(Paths.get(""file.txt""));
        return new Sha256Hash(md.digest(bytes));
    }
    
    public BigInteger toBigInteger() {
        return new BigInteger(1, bytes);
    }
    
    public String toString() {
        return bytes.toString();
    }
    
    public Sha256Hash duplicate() {
        return new Sha256Hash(bytes.clone());
    }
    
    public int compareTo(Sha256Hash other) {
        return Arrays.compareUnsigned(bytes, other.getBytes());
    }
    
    public byte[] getBytes() {
        return bytes;
    }
}"
10,"public class Documentation {
    private static final String LINE_SEPARATOR = System.getProperty(""line.separator"");

    private StringBuilder docs;

    public Documentation() {
        this.docs = new StringBuilder();
    }

    public void setDocs(int index, String comment) {
        if (index < 0 || index >= docs.length()) {
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
        }
        docs.setCharAt(index, comment);
    }

    public boolean hasDocs() {
        return docs.length() > 0;
    }

    public String getComments() {
        return docs.toString();
    }

    public String getComments(int index) {
        if (index < 0 || index >= docs.length()) {
            throw new IndexOutOfBoundsException(""Invalid index: "" + index);
        }
        return docs.substring(index, docs.indexOf(LINE_SEPARATOR, index));
    }

    public String defaultFor() {
        if (!hasDocs()) {
            return """";
        }
        int firstLineIndex = docs.indexOf(LINE_SEPARATOR);
        if (firstLineIndex == -1) {
            return docs.toString();
        }
        int secondLineIndex = docs.indexOf(LINE_SEPARATOR, firstLineIndex + 1);
        if (secondLineIndex == -1) {
            return docs.substring(firstLineIndex + 1);
        }
        return docs.substring(firstLineIndex + 1, secondLineIndex);
    }
}"
100,"package net.sf.marineapi.nmea.parser;

import org.junit.Test;

public class RMCParserTest {
    @Test
    public void testConstructor() {
        RMCParser rmc = new RMCParser();
        assertNotNull(rmc);
    }
    
    @Test
    public void testGetTime() {
        RMCParser rmc = new RMCParser(""RMC"");
        assertEquals(""0000.00"", rmc.getTime());
    }
    
    @Test
    public void testSetFaaModeWhenOmitted() {
        RMCParser rmc = new RMCParser();
        rmc.setFaaMode(RMCParser.FAA_MODE_OMITTED);
        assertEquals(RMCParser.FAA_MODE_OMITTED, rmc.getFaaMode());
    }
    
    @Test
    public void testSetDirectionOfVariationWithInvalidDirection() {
        RMCParser rmc = new RMCParser();
        String invalidDirection = ""North"";
        assertThrows(IllegalArgumentException.class, () -> rmc.setDirectionOfVariation(invalidDirection));
    }
    
    @Test
    public void testGetCorrectedCourse() {
        RMCParser rmc = new RMCParser();
        assertEquals(""000.0"", rmc.getCorrectedCourse());
    }
    
    @Test
    public void testGetDataStatus() {
        RMCParser rmc = new RMCParser();
        assertEquals(RMCParser.DATA_STATUS_VALID, rmc.getDataStatus());
    }
    
    @Test
    public void testSetCourse() {
        RMCParser rmc = new RMCParser();
        String course = ""0123.45"";
        rmc.setCourse(course);
        assertEquals(""0123.45"", rmc.getCourse());
    }
    
    @Test
    public void testSetFaaMode() {
        RMCParser rmc = new RMCParser();
        String faaMode = ""A"";
        rmc.setFaaMode(faaMode);
        assertEquals(""A"", rmc.getFaaMode());
    }
    
    @Test
    public void testSetVariation() {
        RMCParser rmc = new RMCParser();
        String variation = ""0123.45"";
        rmc.setVariation(variation);
        assertEquals(""0123.45"", rmc.getVariation());
    }
    
    @Test
    public void testSetPosition() {
        RMCParser rmc = new RMCParser();
        String position = ""0123.45, 9876.54"";
        rmc.setPosition(position);
        assertEquals(""0123.45"", rmc.getLatitude());
        assertEquals(""9876.54"", rmc.getLongitude());
    }
    
    @Test
    public void testGetDay() {
        RMCParser rmc = new RMCParser();
        assertEquals(0, rmc.getDay());
    }
    
    @Test
    public void testGetMonth() {
        RMCParser rmc = new RMCParser();
        assertEquals(0, rmc.getMonth());
    }
    
    @Test
    public void testGetYear() {
        RMCParser rmc = new RMCParser();
        assertEquals(0, rmc.getYear());
    }
    
    @Test
    public void testGetSpeed() {
        RMCParser rmc = new RMCParser();
        assertEquals(0, rmc.getSpeed());
    }
    
    @Test
    public void testSetDataStatus() {
        RMCParser rmc = new RMCParser();
        String dataStatus = ""V"";
        rmc.setDataStatus(dataStatus);
        assertEquals(""V"", rmc.getDataStatus());
    }
    
    @Test
    public void testSetDate() {
        RMCParser rmc = new RMCParser();
        String date = ""12309876"";
        rmc.setDate(date);
        assertEquals(""12309876"", rmc.getDate());
    }
    
    @Test
    public void testSetTime() {
        RMCParser rmc = new RMCParser();
        String time = ""123456"";
        rmc.setTime(time);
        assertEquals(""123456"", rmc.getTime());
    }
    
    @Test
    public void testGetPosition() {
        RMCParser rmc = new RMCParser();
        String position = ""0123.45, 9876.54"";
        rmc.setPosition(position);
        assertEquals(""0123.45"", rmc.getLatitude());
        assertEquals(""9876.54"", rmc.getLongitude());
    }
    
    @Test
    public void testGetMagneticVariation() {
        RMCParser rmc = new RMCParser();
        String magneticVariation = ""0123.45"";
        rmc.setMagneticVariation(magneticVariation);
        assertEquals(""0123.45"", rmc.getMagneticVariation());
    }
    
    @Test
    public void testGetLatitude() {
        RMCParser rmc = new RMCParser();
        String position = ""0123.45, 9876.54"";
        rmc.setPosition(position);
        assertEquals(""0123.45"", rmc.getLatitude());
    }
    
    @Test
    public void testGetLongitude() {
        RMCParser rmc = new RMCParser();
        String position = ""0123.45, 9876.54"";
        rmc.setPosition(position);
        assertEquals(""9876.54"", rmc.getLongitude());
    }
    
    @Test
    public void testSetFaaModeWithInvalidValue() {
        RMCParser rmc = new RMCParser();
        String faaMode = ""A"";
        assertThrows(IllegalArgumentException.class, () -> rmc.setFaaMode(faaMode));
    }
    
    @Test
    public void testGetFaaMode() {
        RMCParser rmc = new RMCParser();
        String faaMode = ""A"";
        rmc.setFaaMode(faaMode);
        assertEquals(""A"", rmc.getFaaMode());
    }
    
    @Test
    public void testGetDate() {
        RMCParser rmc = new RMCParser();
        String date = ""12309876"";
        rmc.setDate(date);
        assertEquals(""12309876"", rmc.getDate());
    }
    
    @Test
    public void testSetSpeed() {
        RMCParser rmc = new RMCParser();
        String speed = ""0123.45"";
        rmc.setSpeed(speed);
        assertEquals(""0123.45"", rmc.getSpeed());
    }
}"
101,"[PYTHON]
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JavaScriptEscape {
    private static final Pattern JS_CHARACTERS = Pattern.compile(""['\""]"");
    private static final String ESCAPED_JS_CHARACTERS = ""\\$0"";

    public static String getCleanInput(String input) {
        return input.replaceAll(ESCAPED_JS_CHARACTERS, Matcher.quoteReplacement(""\\\\$0""));
    }

    public static String getCleanerInput(String input) {
        return input.replaceAll(""javascript"", """");
    }
}
[/PYTHON]
[TESTS]
# Test case 1:
assert JavaScriptEscape.getCleanInput(""'"") == ""\\'"";
# Test case 2:
assert JavaScriptEscape.getCleanInput('""') == '\\""';
# Test case 3:
assert JavaScriptEscape.getCleanInput(""javascript"") == """";
# Test case 4:
assert JavaScriptEscape.getCleanerInput(""'"") == ""\\'"";
# Test case 5:
assert JavaScriptEscape.getCleanerInput('""') == '\\""';
# Test case 6:
assert JavaScriptEscape.getCleanerInput(""javascript"") == """";
[/TESTS]"
102,"package com.example;

import java.util.Objects;

public class Wsse {
    private String identifier;
    private String wsseValueType;
    private boolean useKeyIdentifier;
    private boolean useDirectReference;
    private String wsse11TokenType;

    public Wsse() {}

    public void setWsse11TokenType(String wsse11TokenType) {
        this.wsse11TokenType = wsse11TokenType;
    }

    public String getWsse11TokenType() {
        return wsse11TokenType;
    }

    public void setIdentifier(String identifier) {
        this.identifier = identifier;
    }

    public String getIdentifier() {
        return identifier;
    }

    public void setUseDirectReference(boolean useDirectReference) {
        this.useDirectReference = useDirectReference;
    }

    public boolean isUseKeyIdentifier() {
        return useKeyIdentifier;
    }

    public void setUseKeyIdentifier(boolean useKeyIdentifier) {
        this.useKeyIdentifier = useKeyIdentifier;
    }

    public boolean isUseDirectReference() {
        return useDirectReference;
    }

    public void setWsseValueType(String wsseValueType) {
        this.wsseValueType = wsseValueType;
    }

    public String getWsseValueType() {
        return wsseValueType;
    }
}"
103,"import java.util.*;
import java.time.Instant;

public class Tweet {
    private final double lat;
    private final String id_str;
    private final String screen_name;
    private final String place_name;
    private final String image;
    private final Date created_at;
    private final int loc_radius;
    private final String user_id;
    private final String text;
    private final ArrayList<String> extras;

    public Tweet(double lat, String id_str, String screen_name, String place_name, String image, Date created_at, int loc_radius, String user_id, String text, ArrayList<String> extras) {
        this.lat = lat;
        this.id_str = id_str;
        this.screen_name = screen_name;
        this.place_name = place_name;
        this.image = image;
        this.created_at = created_at;
        this.loc_radius = loc_radius;
        this.user_id = user_id;
        this.text = text;
        this.extras = extras;
    }

    public GenericJSONBuilder setIDstr(String id_str) {
        return new GenericJSONBuilder().setField(""id_str"", id_str);
    }

    public GenericJSONBuilder setPlaceName(String place_name) {
        return new GenericJSONBuilder().setField(""place_name"", place_name);
    }

    public GenericJSONBuilder addText(String text) {
        return new GenericJSONBuilder().addField(""text"", text);
    }

    public void insert(Tweet tweet) {
        // Insert the tweet into a database or other data storage system here
    }

    public GenericJSONBuilder setCoordinateRadius(double lat, double lng, int radius) {
        return new GenericJSONBuilder().setField(""lat"", lat).setField(""lng"", lng).setField(""radius"", radius);
    }

    public GenericJSONBuilder setAuthor(String author) {
        return new GenericJSONBuilder().setField(""author"", author);
    }

    public String buildFieldJSON() {
        return """"; // Build a JSON string representing the tweet here
    }

    public void persist() {
        insert(this);
    }
}"
104,"import java.util.*;

public class ResourceLoader {
  private static final Logger LOGGER = LoggerFactory.getLogger(ResourceLoader.class);

  private Map<Object, Object> bag;

  public void setResources(List<Resource> resources) {
    this.bag = new HashMap<>();
    for (Resource resource : resources) {
      String propertyName = getProperty(resource);
      if (propertyName != null) {
        bag.put(propertyName, resource);
      }
    }
  }

  public void loadProperties() {
    // Load the properties file and add them to the bag
    Properties props = new Properties();
    try {
      props.load(new FileInputStream(""resources.properties""));
    } catch (IOException e) {
      LOGGER.error(""Error loading properties"", e);
      return;
    }
    for (Object propertyName : props.stringPropertyNames()) {
      String propertyValue = props.getProperty(propertyName);
      bag.put(propertyName, propertyValue);
    }
  }

  private String getProperty(Resource resource) {
    // Implement the logic to extract the property name from the Resource object
    return null;
  }
}"
105,"import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class Settings {
    private Properties properties;
    private String filePath;

    public Settings(String filePath) {
        this.filePath = filePath;
        properties = new Properties();
        loadSettings();
    }

    public void loadSettings() {
        try (FileInputStream inputStream = new FileInputStream(filePath)) {
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void saveSettings() {
        try (FileOutputStream outputStream = new FileOutputStream(filePath)) {
            properties.store(outputStream, null);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public boolean getBoolean(String key) {
        return Boolean.parseBoolean(properties.getProperty(key));
    }

    public int getInteger(String key) {
        return Integer.parseInt(properties.getProperty(key));
    }

    public long getLong(String key) {
        return Long.parseLong(properties.getProperty(key));
    }

    public char getChar(String key) {
        return properties.getProperty(key).charAt(0);
    }

    public String getString(String key) {
        return properties.getProperty(key);
    }

    public void removeSetting(String key) {
        properties.remove(key);
    }

    public void overrideSetting(String key, Object value) {
        properties.setProperty(key, value.toString());
    }

    public Map<String, String> getMap() {
        return (Map<String, String>) properties;
    }

    public List<String> getStrings(String key) {
        return Arrays.asList(properties.getProperty(key).split(""\\s+""));
    }

    public List<Integer> getIntegers(String key) {
        return Arrays.stream(properties.getProperty(key).split(""\\s+"")).map(Integer::parseInt).collect(Collectors.toList());
    }

    public void merge(Settings otherSettings) {
        properties.putAll(otherSettings.getProperties());
    }

    public String getRequiredString(String key) {
        return properties.getProperty(key);
    }

    public List<String> getAllKeys() {
        return Arrays.asList(properties.stringPropertyNames());
    }
}"
106,"import java.util.HashMap;
import java.util.Map;

public class ResourceTypeHandlerWrapper {
    private Map<String, ResourceTypeHandler> types;

    public ResourceTypeHandlerWrapper(Map<String, ResourceTypeHandler> types) {
        this.types = types;
    }

    public ResourceTypeHandler getResourceTypeHandler(String name) {
        if (types.containsKey(name)) {
            return types.get(name);
        } else {
            return null;
        }
    }

    public String getPath(ResourceTypeHandler resourceTypeHandler) {
        if (resourceTypeHandler == null) {
            return null;
        }
        return resourceTypeHandler.getName();
    }

    public ResourceTypeHandler getDefaultResourceType() {
        return null;
    }

    @Override
    public int hashCode() {
        return 0;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        } else if (!(obj instanceof ResourceTypeHandlerWrapper)) {
            return false;
        } else {
            ResourceTypeHandlerWrapper other = (ResourceTypeHandlerWrapper) obj;
            return this.types.equals(other.types);
        }
    }
}"
107,"public class TemplateDelegator extends TestNodeVisitor {
    @Override
    public void testDocumentType(DocumentType node) {
        // Custom logic goes here
    }

    @Override
    public void testComment(Comment node) {
        // Custom logic goes here
    }

    @Override
    public void testNode(Node node) {
        // Custom logic goes here
    }

    @Override
    public void testElement(Element node) {
        // Custom logic goes here
    }

    @Override
    public void testEntity(Entity node) {
        // Custom logic goes here
    }

    @Override
    public void noMoreNodes() {
        // Custom logic goes here
    }

    @Override
    public void testAttribute(Attr node) {
        // Custom logic goes here
    }

    @Override
    public void testText(Text node) {
        // Custom logic goes here
    }

    @Override
    public void testEntityReference(EntityReference node) {
        // Custom logic goes here
    }

    @Override
    public void testCDATASection(CDATASection node) {
        // Custom logic goes here
    }

    @Override
    public void testProcessingInstruction(ProcessingInstruction node) {
        // Custom logic goes here
    }
}"
108,"package com.example;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.ConcurrentMap;

public class RpcStatistics {
    private AtomicInteger failed = new AtomicInteger(0);
    private AtomicLong totalElapsed = new AtomicLong(0);
    private AtomicInteger active = new AtomicInteger(0);
    private AtomicLong succeededMaxElapsed = new AtomicLong(0);
    private ConcurrentMap<String, RpcStatus> serviceStatistics = new ConcurrentHashMap<>();
    private ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> methodStatistics = new ConcurrentHashMap<>();
    private ConcurrentMap<String, Object> values = new ConcurrentHashMap<>();

    public void beginCount(String serviceName) {
        active.incrementAndGet();
        totalElapsed.addAndGet(System.nanoTime());
        values.putIfAbsent(serviceName, new AtomicLong(0));
    }

    public void endCount(String serviceName) {
        active.decrementAndGet();
        long elapsed = System.nanoTime() - totalElapsed.get();
        values.computeIfPresent(serviceName, (key, value) -> {
            value.addAndGet(elapsed);
            return value;
        });
    }

    public int getActive() {
        return active.get();
    }

    public long getTotalElapsed() {
        return totalElapsed.get();
    }

    public void setSucceededMaxElapsed(long elapsed) {
        succeededMaxElapsed.set(elapsed);
    }

    public long getSucceededMaxElapsed() {
        return succeededMaxElapsed.get();
    }

    public long getFailedAverageElapsed() {
        return failed.get() > 0 ? totalElapsed.get() / failed.get() : 0;
    }

    public long getSucceededElapsed(String serviceName) {
        return values.getOrDefault(serviceName, new AtomicLong(0)).get();
    }

    public long getSucceededAverageElapsed() {
        return totalElapsed.get() > 0 ? totalElapsed.get() / active.get() : 0;
    }

    public long getMaxElapsed() {
        return values.values().stream().mapToLong(AtomicLong::get).max().orElse(0);
    }

    public void setFailed(int failed) {
        this.failed.set(failed);
    }

    public int getFailed() {
        return failed.get();
    }

    public long getAverageTps() {
        return totalElapsed.get() > 0 ? total.get() * 1_000_000_000 / totalElapsed.get() : 0;
    }

    public void removeStatus(String serviceName) {
        values.remove(serviceName);
    }

    public RpcStatus getStatus(String serviceName) {
        return new RpcStatus(failed, succeededMaxElapsed);
    }
}"
109,"public class Track {
    private int errorLevelFolder;
    private String tooltip;
    private int errorLevel;
    private String value;
    
    public void restoreFolderErrorLevel() {
        // Restore the folder error level to its original value
    }
    
    public void setKO() {
        // Set the track as KO (not valid)
    }
    
    public boolean isWarning() {
        // Check if the track has a warning
    }
    
    public void setErrorLevel(int errorLevel) {
        this.errorLevel = errorLevel;
    }
    
    public int getErrorLevel() {
        return errorLevel;
    }
    
    public String analyseTrack(String trackName) {
        // Analyse the given track name and return a string representation of the result
    }
    
    public String analyseTrackYear(String trackName, int year) {
        // Analyse the given track name and return a string representation of the result for the given year
    }
    
    public String formatNumber(int number) {
        // Format the given number as a string with a specific format
    }
    
    public String colorField(String fieldName, int value) {
        // Return the color of the given field based on its value
    }
    
    public String getValue() {
        return value;
    }
    
    public String analyseTrackComment(String trackName, String comment) {
        // Analyse the given track name and comment and return a string representation of the result
    }
    
    public String analyseTrackBpm(String trackName, int bpm) {
        // Analyse the given track name and BPM and return a string representation of the result
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Track other = (Track) obj;
        return Objects.equals(value, other.getValue());
    }
    
    public String getDisplayToolTip() {
        // Return the display tool tip for the track
    }
    
    @Override
    public String toString() {
        return ""Track{"" +
                ""errorLevelFolder="" + errorLevelFolder +
                "", tooltip='"" + tooltip + '\'' +
                "", errorLevel="" + errorLevel +
                "", value='"" + value + '\'' +
                '}';
    }
    
    public boolean isNotValid() {
        // Check if the track is not valid
    }
    
    public Color getDisplayColor() {
        // Return the display color for the track
    }
    
    public String analyseTrackNumber(String trackName, int number) {
        // Analyse the given track name and number and return a string representation of the result
    }
    
    public String getDisplayText() {
        // Return the display text for the track
    }
    
    public void setWarning(boolean warning) {
        // Set the track as a warning (not valid but with a specific reason)
    }
    
    public void setWarning() {
        // Set the track as a warning (not valid but with a specific reason)
    }
    
    public String analyseTrackString(String trackName, String string) {
        // Analyse the given track name and string and return a string representation of the result
    }
    
    public boolean isKO() {
        // Check if the track is KO (not valid)
    }
}"
11,"// Get the log level for reporting the selection of the new alternative address or endpoint
LOG.info(""Selecting new alternate address: {}"", alternateAddress);

// Set the delay between retries to the value specified in the configuration file
setDelayBetweenRetries(delayBetweenRetries);

// Get the list of endpoints from the configuration file
List<Endpoint> endpoints = getEndpoints();

// Select a new alternate endpoint based on the current time and the delay between retries
Endpoint selectedAlternateEndpoint = selectAlternateEndpoint(endpoints, currentTime, delayBetweenRetries);

// Set the list of alternate addresses to the value specified in the configuration file
setAlternateAddresses(alternateAddresses);

// Get the list of alternate endpoints from the configuration file
List<Endpoint> alternateEndpoints = getAlternateEndpoints();

// Select a new alternate endpoint based on the current time and the delay between retries
Endpoint selectedAlternateEndpoint = selectAlternateEndpoint(alternateEndpoints, currentTime, delayBetweenRetries);

// Set the list of alternate addresses to the value specified in the configuration file
setAlternateAddresses(alternateAddresses);"
110,"package net.sf.marineapi.nmea.parser;

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class RMBSentenceTest {
    private RMBSentence rmb;

    @BeforeEach
    public void setUp() {
        rmb = new RMBSentence();
    }

    @Test
    public void testGetVelocity() {
        assertEquals(0.0, rmb.getVelocity());
    }

    @Test
    public void testGetCrossTrackError() {
        assertEquals(0.0, rmb.getCrossTrackError());
    }

    @Test
    public void testArrivalStatus() {
        assertEquals("""", rmb.getArrivalStatus());
    }

    @Test
    public void testSetDestination() {
        String destination = ""destination"";
        rmb.setDestination(destination);
        assertEquals(destination, rmb.getDestination());
    }

    @Test
    public void testSetBearing() {
        double bearing = 10.0;
        rmb.setBearing(bearing);
        assertEquals(bearing, rmb.getBearing(), 0.00001);
    }

    @Test
    public void testSetSteerToWithNull() {
        String steerTo = null;
        rmb.setSteerTo(steerTo);
        assertEquals("""", rmb.getSteerTo());
    }

    @Test
    public void testSetOriginId() {
        String originId = ""originId"";
        rmb.setOriginId(originId);
        assertEquals(originId, rmb.getOriginId());
    }

    @Test
    public void testSetStatus() {
        String status = ""status"";
        rmb.setStatus(status);
        assertEquals(status, rmb.getStatus());
    }

    @Test
    public void testConstructor() {
        RMBSentence rmb = new RMBSentence();
        assertNotNull(rmb);
    }

    @Test
    public void testGetBearing() {
        assertEquals(0.0, rmb.getBearing());
    }

    @Test
    public void testSetSteerTo() {
        String steerTo = ""steerTo"";
        rmb.setSteerTo(steerTo);
        assertEquals(steerTo, rmb.getSteerTo());
    }

    @Test
    public void testGetSteerTo() {
        assertEquals("""", rmb.getSteerTo());
    }

    @Test
    public void testSetVelocity() {
        double velocity = 10.0;
        rmb.setVelocity(velocity);
        assertEquals(velocity, rmb.getVelocity(), 0.00001);
    }

    @Test
    public void testGetOriginId() {
        assertEquals("""", rmb.getOriginId());
    }

    @Test
    public void testSetVelocityWithNegativeValue() {
        double velocity = -10.0;
        rmb.setVelocity(velocity);
        assertNotEquals(velocity, rmb.getVelocity(), 0.00001);
    }

    @Test
    public void testGetRange() {
        assertEquals(0.0, rmb.getRange());
    }

    @Test
    public void testSetRange() {
        double range = 10.0;
        rmb.setRange(range);
        assertEquals(range, rmb.getRange(), 0.00001);
    }

    @Test
    public void testGetDestination() {
        assertEquals("""", rmb.getDestination());
    }

    @Test
    public void testSetCrossTrackError() {
        double crossTrackError = 10.0;
        rmb.setCrossTrackError(crossTrackError);
        assertEquals(crossTrackError, rmb.getCrossTrackError(), 0.00001);
    }
}"
111,"import java.util.List;

public class GetFilePath {
  private static final String FILE_SYSTEM_MASTER = ""fileSystemMaster"";
  private static final long FILE_ID = 12345L;

  public static void main(String[] args) {
    FileSystemMaster mFileSystemMaster = new FileSystemMaster();
    List<Long> lostFiles = mFileSystemMaster.getLostFiles();
    List<WorkerInfo> workerInfoList = mFileSystemMaster.getWorkerInfoList();
    List<FileBlockInfo> fileBlockInfoList = mFileSystemMaster.getFileBlockInfoList(FILE_ID);
    FileInfo fileInfo = mFileSystemMaster.getFileInfo(FILE_ID);
    PersistenceState filePersistenceState = fileInfo.getPersistenceState();

    System.out.println(""File path: "" + filePersistenceState.getPath());
  }
}"
112,"import java.io.File;
import java.math.BigInteger;
import java.nio.file.Files;
import java.security.MessageDigest;

public class Sha256Hash {
    private final byte[] bytes;

    public static final Sha256Hash ZERO_HASH = new Sha256Hash(new byte[32]);

    public Sha256Hash(byte[] bytes) {
        this.bytes = bytes;
    }

    public static Sha256Hash createDouble(Sha256Hash hash1, Sha256Hash hash2) {
        byte[] combinedBytes = new byte[hash1.getBytes().length + hash2.getBytes().length];
        System.arraycopy(hash1.getBytes(), 0, combinedBytes, 0, hash1.getBytes().length);
        System.arraycopy(hash2.getBytes(), 0, combinedBytes, hash1.getBytes().length, hash2.getBytes().length);

        return new Sha256Hash(combinedBytes);
    }

    public static Sha256Hash create(File file) throws Exception {
        byte[] bytes = Files.readAllBytes(file.toPath());
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        return new Sha256Hash(md.digest(bytes));
    }

    public boolean equals(Object other) {
        if (other instanceof Sha256Hash) {
            byte[] otherBytes = ((Sha256Hash) other).getBytes();
            return Arrays.equals(this.bytes, otherBytes);
        } else {
            return false;
        }
    }

    public BigInteger toBigInteger() {
        return new BigInteger(1, this.bytes);
    }

    public String toString() {
        return bytesToHex(this.bytes);
    }

    public Sha256Hash duplicate() {
        return new Sha256Hash(this.bytes.clone());
    }

    public int compareTo(Sha256Hash other) {
        byte[] otherBytes = other.getBytes();
        return Arrays.compareUnsigned(this.bytes, otherBytes);
    }

    public byte[] getBytes() {
        return this.bytes;
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < bytes.length; i++) {
            sb.append(String.format(""%02x"", bytes[i]));
        }
        return sb.toString();
    }
}"
113,"public class ConstantPool {
    private final Map<Integer, Object> pool;

    public ConstantPool() {
        this.pool = new HashMap<>();
    }

    public void addConstant(int tag, Object value) {
        pool.put(tag, value);
    }

    public Object getValue(int index) {
        return pool.get(index);
    }

    // Methods for different types of constants

    public byte getByte(int index) {
        return (byte) pool.get(index);
    }

    public boolean getBoolean(int index) {
        return (boolean) pool.get(index);
    }

    public int getInt(int index) {
        return (int) pool.get(index);
    }

    public long getLong(int index) {
        return (long) pool.get(index);
    }

    public float getFloat(int index) {
        return (float) pool.get(index);
    }

    public double getDouble(int index) {
        return (double) pool.get(index);
    }

    public String getString(int index) {
        return (String) pool.get(index);
    }

    public MethodHandle getMethodHandle(int index) {
        return (MethodHandle) pool.get(index);
    }

    public InterfaceMethodRef getInterfaceMethodRef(int index) {
        return (InterfaceMethodRef) pool.get(index);
    }

    public NameAndType getNameAndType(int index) {
        return (NameAndType) pool.get(index);
    }

    public MethodType getMethodType(int index) {
        return (MethodType) pool.get(index);
    }

    // Utility methods for hashing and comparing constants

    @Override
    public int hashCode() {
        return pool.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof ConstantPool) {
            ConstantPool other = (ConstantPool) obj;
            return pool.equals(other.pool);
        }
        return false;
    }
}"
114,"import java.math.BigInteger;

public class StoredBlock {
    private BigInteger chainWork;
    private int height;
    private byte[] emptyBytes = new byte[0];
    private long serialVersionUID = 1L;

    public StoredBlock(int height, BigInteger chainWork) {
        this.height = height;
        this.chainWork = chainWork;
    }

    public int getHeight() {
        return height;
    }

    public BigInteger getChainWork() {
        return chainWork;
    }

    public void deserializeCompact(byte[] compact) {
        // TODO: Implement deserialization logic
    }

    public StoredBlock build(StoredBlock prev) {
        // TODO: Implement building logic
        return this;
    }

    public void serializeCompact() {
        // TODO: Implement serialization logic
    }

    @Override
    public int hashCode() {
        return Objects.hash(height, chainWork);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof StoredBlock)) {
            return false;
        }
        StoredBlock other = (StoredBlock) obj;
        return Objects.equals(height, other.getHeight()) && Objects.equals(chainWork, other.getChainWork());
    }

    @Override
    public String toString() {
        return ""StoredBlock{"" +
                ""height="" + height +
                "", chainWork="" + chainWork +
                '}';
    }

    public StoredBlock getPrev() {
        return this.prev;
    }
}"
115,"package com.example;

import java.util.*;
import javax.servlet.http.*;

public class FCKeditorConfig {
    private HttpServletRequest request;
    private String toolbarSet;
    private String instanceName;
    private String height;
    private String basePath;
    private FCKeditorConfig config;
    private String value;
    private String width;

    public FCKeditorConfig(HttpServletRequest request) {
        this.request = request;
    }

    public void setToolbarSet(String toolbarSet) {
        this.toolbarSet = toolbarSet;
    }

    public void setInstanceName(String instanceName) {
        this.instanceName = instanceName;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public void setWidth(String width) {
        this.width = width;
    }

    public void setHeight(String height) {
        this.height = height;
    }

    public void setBasePath(String basePath) {
        this.basePath = basePath;
    }

    public void setConfig(FCKeditorConfig config) {
        this.config = config;
    }

    public String getToolbarSet() {
        return toolbarSet;
    }

    public String getInstanceName() {
        return instanceName;
    }

    public String getValue() {
        return value;
    }

    public String getWidth() {
        return width;
    }

    public String getHeight() {
        return height;
    }

    public String getBasePath() {
        return basePath;
    }

    public FCKeditorConfig getConfig() {
        return config;
    }
}"
116,"public class AdditionDifference {
    private int additionDifference;
    private int deletionDifference;

    public void setAdditionDifference(int additionDifference) {
        this.additionDifference = additionDifference;
    }

    public void setDeletionDifference(int deletionDifference) {
        this.deletionDifference = deletionDifference;
    }

    public int getAdditionDifference() {
        return additionDifference;
    }

    public int getDeletionDifference() {
        return deletionDifference;
    }
}"
117,"public class LanguageVersion {
    private String name;
    private Icon icon;
    private ArrayList<NotationName> notations;
    private String version;

    public LanguageVersion(String name, Icon icon, ArrayList<NotationName> notations, String version) {
        this.name = name;
        this.icon = icon;
        this.notations = notations;
        this.version = version;
    }

    // Accessor for the language version name
    public String getName() {
        return this.name;
    }

    // Accessor for the language version icon
    public Icon getIcon() {
        return this.icon;
    }

    // Accessor for the language version notations
    public ArrayList<NotationName> getNotations() {
        return this.notations;
    }

    // Accessor for the language version version
    public String getVersion() {
        return this.version;
    }

    // Getter method for the notation name string
    public String getNotationNameString(NotationName notation) {
        if (notation != null) {
            return notation.getName();
        } else {
            return null;
        }
    }

    // Method to fire an event for a notation change
    public void fireEvent() {
        // TODO: Implement the logic for firing an event
    }

    // Method to remove a notation from the list of available notations
    public boolean removeNotation(NotationName notation) {
        if (notation != null && this.notations.contains(notation)) {
            this.notations.remove(notation);
            return true;
        } else {
            return false;
        }
    }

    // Method to get the configuration value for a notation
    public String getConfigurationValue(NotationName notation) {
        if (notation != null && this.notations.contains(notation)) {
            return this.notations.get(notation).getConfigurationValue();
        } else {
            return null;
        }
    }

    // Method to get the title for a notation
    public String getTitle(NotationName notation) {
        if (notation != null && this.notations.contains(notation)) {
            return this.notations.get(notation).getTitle();
        } else {
            return null;
        }
    }

    // Method to find a notation by its name
    public NotationName findNotation(String name) {
        if (name != null && !name.isEmpty()) {
            for (NotationName notation : this.notations) {
                if (notation.getName().equals(name)) {
                    return notation;
                }
            }
        }
        return null;
    }

    // Method to get the notation with a given name
    public NotationName getNotation(String name) {
        if (name != null && !name.isEmpty()) {
            for (NotationName notation : this.notations) {
                if (notation.getName().equals(name)) {
                    return notation;
                }
            }
        }
        return null;
    }

    // Method to get the available notations
    public List<NotationName> getAvailableNotations() {
        return this.notations;
    }

    // Method to convert the language version to a string
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""LanguageVersion: "").append(this.name).append(""\n"");
        sb.append(""Icon: "").append(this.icon).append(""\n"");
        sb.append(""Notations: "").append(this.notations).append(""\n"");
        sb.append(""Version: "").append(this.version);
        return sb.toString();
    }

    // Method to make a notation for the given language version
    public NotationName makeNotation(String name) {
        if (name != null && !name.isEmpty()) {
            NotationName notation = new NotationName(name);
            this.notations.add(notation);
            return notation;
        } else {
            return null;
        }
    }

    // Method to check if two notations are the same
    public boolean sameNotationAs(NotationName other) {
        if (other != null && this.notations.contains(other)) {
            return true;
        } else {
            return false;
        }
    }
}"
118,"[PYTHON]
void transferElementToVirtualStack() {
    // check if the virtual stack is empty
    if (vstack.empty()) {
        // get the next element from the real stack
        int next = real_next();
        // push the element to the virtual stack
        vstack.push(next);
    }
}
[/PYTHON]
[TESTS]
# Test case 1:
# Test that the element is transferred from the real to the virtual stack
real_stack = []
vstack = []
real_next = lambda: 5
transferElementToVirtualStack()
assert vstack == [5]

# Test case 2:
# Test that the function does nothing if the virtual stack is not empty
real_stack = []
vstack = [1]
real_next = lambda: 5
transferElementToVirtualStack()
assert vstack == [1]

# Test case 3:
# Test that the function returns true if the element was transferred from the real to the virtual stack
real_stack = []
vstack = []
real_next = lambda: 5
result = transferElementToVirtualStack()
assert result is True

# Test case 4:
# Test that the function returns false if the virtual stack is not empty
real_stack = []
vstack = [1]
real_next = lambda: 5
result = transferElementToVirtualStack()
assert result is False
[/TESTS]"
119,"import java.util.concurrent.CountDownLatch;

public class Test {
  public static void main(String[] args) throws InterruptedException {
    // Create a CountDownLatch to wait for the listener to complete
    CountDownLatch countDownLatch = new CountDownLatch(1);
    
    // Create a ListenableFuture that will be completed in a reasonable amount of time
    ListenableFuture<?> future = ...;
    
    // Add a listener to the future that will wait for it to complete and then decrement the countdown latch
    future.addListener(new Runnable() {
      public void run() {
        // Assert that the future returns the expected data
        assertEquals(""Expected data"", future.get());
        
        // Decrement the countdown latch to unblock the main thread
        countDownLatch.countDown();
      }
    }, MoreExecutors.directExecutor());
    
    // Start the listener and wait for it to complete
    future.start();
    countDownLatch.await(10, TimeUnit.SECONDS);
  }
}"
12,"import java.util.*;

class TSTNode {
    char data;
    TSTNode left, right;
    ArrayList<String> al;
    boolean isEndOfString;

    public TSTNode(char data) {
        this.data = data;
        this.al = new ArrayList<>();
        this.isEndOfString = false;
    }

    public void traverse() {
        // traverse the tree recursively and print the data of each node
    }

    public void makeEmpty() {
        // clear all nodes in the tree
    }

    public boolean isEmpty() {
        // check if the tree is empty
    }

    public TSTNode insert(char data) {
        // insert a new node with the given data into the tree
    }

    public String toString() {
        // convert the tree to a string representation
    }

    public void main(String[] args) {
        // test the functions of the class
    }
}"
120,"public class Peak {
    private int internalId;
    private boolean AMPLIFIED;
    private boolean DELETED;
    private int gisticID;
    private int peakStart;
    private ArrayList<CanonicalGene> genes_in_ROI;
    private String cytoband;
    private int cancerStudyId;
    private int chromosome;
    private int peakEnd;
    private double qValue;

    public void setPeakEnd(int peakEnd) {
        this.peakEnd = peakEnd;
    }

    public void setAmp(boolean amp) {
        this.amp = amp;
    }

    public String getCytoband() {
        return cytoband;
    }

    public void setPeakStart(int peakStart) {
        this.peakStart = peakStart;
    }

    public int getPeakStart() {
        return peakStart;
    }

    public void setqValue(double qValue) {
        this.qValue = qValue;
    }

    public boolean getAmp() {
        return amp;
    }

    public int getInternalId() {
        return internalId;
    }

    public void setGenes_in_ROI(ArrayList<CanonicalGene> genes_in_ROI) {
        this.genes_in_ROI = genes_in_ROI;
    }

    public int getPeakSize() {
        return peakEnd - peakStart + 1;
    }

    public int getCancerStudyId() {
        return cancerStudyId;
    }

    public int getChromosome() {
        return chromosome;
    }

    public int getPeakEnd() {
        return peakEnd;
    }

    public void addGene(CanonicalGene gene) {
        genes_in_ROI.add(gene);
    }

    public void setCancerStudyId(int cancerStudyId) {
        this.cancerStudyId = cancerStudyId;
    }

    public double getqValue() {
        return qValue;
    }

    @Override
    public String toString() {
        return ""Peak{"" +
                ""internalId="" + internalId +
                "", AMPLIFIED="" + AMPLIFIED +
                "", DELETED="" + DELETED +
                "", gisticID="" + gisticID +
                "", peakStart="" + peakStart +
                "", genes_in_ROI="" + genes_in_ROI +
                "", cytoband='"" + cytoband + '\'' +
                "", cancerStudyId="" + cancerStudyId +
                "", chromosome="" + chromosome +
                "", peakEnd="" + peakEnd +
                "", qValue="" + qValue +
                '}';
    }

    public ArrayList<CanonicalGene> getGenes_in_ROI() {
        return genes_in_ROI;
    }

    public void setCytoband(String cytoband) {
        this.cytoband = cytoband;
    }

    public void setChromosome(int chromosome) {
        this.chromosome = chromosome;
    }
}"
121,"import java.util.concurrent.ConcurrentHashMap;

public class AtomicLongMap<K> {
    private ConcurrentHashMap<K, Long> map = new ConcurrentHashMap<>();

    public long getAndIncrement(K key) {
        return map.get(key).incrementAndGet();
    }

    public boolean removeIfZero(K key) {
        if (map.containsKey(key)) {
            long value = map.get(key);
            if (value == 0) {
                map.remove(key);
                return true;
            }
        }
        return false;
    }

    public boolean replace(K key, Long oldValue, Long newValue) {
        if (map.containsKey(key)) {
            long value = map.get(key);
            if (value == oldValue) {
                map.put(key, newValue);
                return true;
            }
        }
        return false;
    }

    public long decrementAndGet(K key) {
        long value = map.get(key).decrementAndGet();
        if (value == 0) {
            map.remove(key);
        }
        return value;
    }

    public long updateAndGet(K key, Long newValue) {
        if (map.containsKey(key)) {
            long oldValue = map.get(key);
            map.put(key, newValue);
            return oldValue;
        } else {
            map.put(key, newValue);
            return 0;
        }
    }

    public long sum() {
        long sum = 0;
        for (long value : map.values()) {
            sum += value;
        }
        return sum;
    }

    public void put(K key, Long value) {
        map.put(key, value);
    }

    public long remove(K key) {
        if (map.containsKey(key)) {
            long value = map.remove(key);
            return value;
        } else {
            return 0;
        }
    }

    public boolean remove() {
        if (map.isEmpty()) {
            map.clear();
            return true;
        }
        return false;
    }

    public void removeAllZeros() {
        for (K key : map.keySet()) {
            long value = map.get(key);
            if (value == 0) {
                map.remove(key);
            }
        }
    }

    public long get(K key) {
        return map.containsKey(key) ? map.get(key) : 0;
    }

    public void putAll(Map<K, Long> m) {
        for (K key : m.keySet()) {
            put(key, m.get(key));
        }
    }

    public static AtomicLongMap<K> create() {
        return new AtomicLongMap<>();
    }

    public long getAndAdd(K key, Long value) {
        long oldValue = map.get(key);
        map.put(key, oldValue + value);
        return oldValue;
    }

    public long getAndAccumulate(K key, Long value) {
        long oldValue = map.get(key);
        map.put(key, oldValue + value);
        return oldValue;
    }

    public long accumulateAndGet(K key, Long value) {
        long newValue = map.get(key) + value;
        if (newValue == 0) {
            map.remove(key);
            return 0;
        } else {
            map.put(key, newValue);
            return newValue;
        }
    }

    public boolean containsKey(K key) {
        return map.containsKey(key);
    }

    public boolean isEmpty() {
        return map.isEmpty();
    }

    public int size() {
        return map.size();
    }

    @Override
    public String toString() {
        return ""AtomicLongMap{"" +
                ""map="" + map +
                '}';
    }
}"
122,"import java.io.*;
import java.net.*;
import java.util.*;

public class SshExample {
    public static void main(String[] args) {
        // Initialize variables
        boolean connected = false;

        // Set up SSH connection
        try {
            JSch jsch = new JSch();
            Session session = jsch.getSession(""username"", ""hostname"");
            session.setPassword(""password"");
            Properties config = new Properties();
            config.put(""StrictHostKeyChecking"", ""no"");
            session.setConfig(config);
            session.connect();
        } catch (JSchException e) {
            System.err.println(""Error: "" + e.getMessage());
            return;
        }

        // Check if connection is established
        connected = true;

        // If connection is established, start listening for data
        while (connected) {
            try {
                InputStream inputStream = session.getStdout();
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
                String line = null;
                while ((line = reader.readLine()) != null) {
                    System.out.println(""Received data: "" + line);
                }
            } catch (IOException e) {
                System.err.println(""Error: "" + e.getMessage());
            }
        }

        // Disconnect from SSH server
        session.disconnect();
    }
}"
123,"public class PluginContainer {
    private List<PluginManagerListener> listeners;
    private Logger LOG = Logger.getLogger(this.getClass().getName());
    private PluginManager singleton;
    private Map<String, AbstractPlugin> allPlugins;

    public void removePluginFromAvailableList(String pluginName) {
        if (isActive(pluginName)) {
            LOG.info(""Removing active plugin: "" + pluginName);
            AbstractPlugin plugin = getByName(pluginName);
            pluginStateChanged(plugin, PluginState.DEACTIVATED);
            removeListener(plugin);
        } else {
            LOG.info(""Removing inactive plugin: "" + pluginName);
        }
    }

    private boolean isActive(String pluginName) {
        return allPlugins.containsKey(pluginName) && allPlugins.get(pluginName).isActive();
    }

    public void addPlugin(AbstractPlugin plugin) {
        if (allPlugins.containsKey(plugin.getName())) {
            throw new IllegalArgumentException(""Plugin with name "" + plugin.getName() + "" already exists"");
        }
        allPlugins.put(plugin.getName(), plugin);
        loadAvailableJars(plugin.getClass().getClassLoader());
    }

    private void loadPlugins() {
        List<AbstractPlugin> availablePlugins = getAvailablePlugins();
        for (AbstractPlugin plugin : availablePlugins) {
            addPlugin(plugin);
        }
    }

    private Iterator<AbstractPlugin> iterator() {
        return allPlugins.values().iterator();
    }

    public int countActivePlugins() {
        return allPlugins.size();
    }

    private AbstractPlugin getByName(String pluginName) {
        if (!allPlugins.containsKey(pluginName)) {
            throw new IllegalArgumentException(""Plugin with name "" + pluginName + "" does not exist"");
        }
        return allPlugins.get(pluginName);
    }

    private void loadAvailableJars(ClassLoader classLoader) {
        Set<URL> availableJars = PluginUtils.findAvailableJars(classLoader);
        for (URL jar : availableJars) {
            addToClasspath(jar);
        }
    }

    private void addListener(AbstractPlugin plugin) {
        if (!listeners.contains(plugin)) {
            listeners.add(plugin);
        }
    }

    private void removeAllPlugins() {
        for (Iterator<AbstractPlugin> iterator = allPlugins.values().iterator(); iterator.hasNext(); ) {
            AbstractPlugin plugin = iterator.next();
            removeListener(plugin);
            iterator.remove();
        }
    }

    private Iterator<AbstractPlugin> getActivePluginIterator() {
        return allPlugins.values().iterator();
    }

    private void setAllActive(boolean active) {
        for (AbstractPlugin plugin : allPlugins.values()) {
            plugin.setActive(active);
        }
    }

    private AbstractPlugin getByIndex(int index) {
        return allPlugins.values().toArray()[index];
    }

    private void notifyActiveChanged(AbstractPlugin plugin, PluginState newState) {
        if (newState == PluginState.ACTIVATED) {
            loadAvailableJars(plugin.getClass().getClassLoader());
        } else {
            removeListener(plugin);
        }
    }

    private void addToClasspath(URL jar) {
        LOG.info(""Adding URL to classpath: "" + jar.toString());
        PluginUtils.addToClasspath(jar, this.getClass().getClassLoader());
    }

    private void removeListener(AbstractPlugin plugin) {
        if (listeners.contains(plugin)) {
            listeners.remove(plugin);
        }
    }

    private void pluginStateChanged(AbstractPlugin plugin, PluginState newState) {
        LOG.info(""Plugin state changed: "" + plugin.getName() + "", new state is: "" + newState.toString());
        notifyActiveChanged(plugin, newState);
    }

    private int indexOf(String pluginName) {
        return allPlugins.values().indexOf(getByName(pluginName));
    }

    private void setAllActive() {
        for (AbstractPlugin plugin : allPlugins.values()) {
            plugin.setActive(true);
        }
    }

    public int indexOfActivePlugin(String pluginName) {
        return allPlugins.values().indexOf(getByName(pluginName));
    }

    private void savePlugins() {
        for (AbstractPlugin plugin : allPlugins.values()) {
            LOG.info(""Saving plugin: "" + plugin.getName());
            plugin.save();
        }
    }

    public void setActive(String pluginName) {
        AbstractPlugin plugin = getByName(pluginName);
        plugin.setActive(true);
        pluginStateChanged(plugin, PluginState.ACTIVATED);
        savePlugins();
    }
}"
124,"import java.util.List;

public class GroupService {
    public List<Group> getGroupsForUser(String username) {
        // Implement the logic to retrieve the list of groups for the given user
        return null;
    }
}"
125,"package com.example;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServiceID;

public class Socket {
    private ServalNetworkStack netImpl;
    private boolean streaming;
    private ServiceID localServiceID;
    private InetAddress address;
    private ServiceID remoteServiceID;
    private FileDescriptor fd;

    public Socket(ServalNetworkStack netImpl, boolean streaming, ServiceID localServiceID, InetAddress address, ServiceID remoteServiceID, FileDescriptor fd) {
        this.netImpl = netImpl;
        this.streaming = streaming;
        this.localServiceID = localServiceID;
        this.address = address;
        this.remoteServiceID = remoteServiceID;
        this.fd = fd;
    }

    public void bind(InetAddress address, ServiceID localServiceID) throws IOException {
        // TODO: Implement the binding logic here
    }

    public boolean shutdownInput() {
        // TODO: Implement the shutdown input logic here
        return false;
    }

    public void listen(int backlog) throws IOException {
        // TODO: Implement the listening logic here
    }

    public void shutdownOutput() throws IOException {
        // TODO: Implement the shutdown output logic here
    }

    public void accept(Socket s) throws IOException {
        // TODO: Implement the accepting logic here
    }

    public void shutdownInput() throws IOException {
        // TODO: Implement the shutdown input logic here
    }

    public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
        // TODO: Implement the performance preferences logic here
    }

    public void sendUrgentData(int data) throws IOException {
        // TODO: Implement the urgent data sending logic here
    }

    public boolean supportsUrgentData() {
        return false;
    }

    public ServiceID getLocalServiceID() {
        return localServiceID;
    }

    public FileDescriptor getFileDescriptor() {
        return fd;
    }

    public void create(boolean streaming, ServiceID localServiceID) throws IOException {
        // TODO: Implement the creation logic here
    }

    public OutputStream getOutputStream() throws IOException {
        // TODO: Implement the output stream logic here
        return null;
    }

    @Override
    public String toString() {
        return ""Socket{"" +
                ""netImpl="" + netImpl +
                "", streaming="" + streaming +
                "", localServiceID="" + localServiceID +
                "", address="" + address +
                "", remoteServiceID="" + remoteServiceID +
                "", fd="" + fd +
                '}';
    }

    public void close() throws IOException {
        // TODO: Implement the closing logic here
    }

    public void connect(InetAddress address, int port) throws IOException {
        // TODO: Implement the connecting logic here
    }
}"
126,"package com.example;

import org.junit.Test;

import static org.junit.Assert.*;

public class LogEntryRequestTest {
    @Test
    public void testGetResponseStringCSV() {
        LogEntryRequest request = new LogEntryRequest();
        assertEquals("""", request.getResponseStringCSV());
    }

    @Test
    public void testGetTsSend() {
        LogEntryRequest request = new LogEntryRequest();
        assertEquals(0, request.getTsSend());
    }

    @Test
    public void testGetTsReceived() {
        LogEntryRequest request = new LogEntryRequest();
        assertEquals(0, request.getTsReceived());
    }

    @Test
    public void testSetResponseString() {
        LogEntryRequest request = new LogEntryRequest();
        request.setResponseString(""Hello, World!"");
        assertEquals(""Hello, World!"", request.getResponseString());
    }

    @Test
    public void testGetResponseString() {
        LogEntryRequest request = new LogEntryRequest();
        request.setResponseString(""Hello, World!"");
        assertEquals(""Hello, World!"", request.getResponseString());
    }

    @Test
    public void testGetFaultFlag() {
        LogEntryRequest request = new LogEntryRequest();
        assertFalse(request.getFaultFlag());
    }

    @Test
    public void testSetFaultFlag() {
        LogEntryRequest request = new LogEntryRequest();
        request.setFaultFlag(true);
        assertTrue(request.getFaultFlag());
    }

    @Test
    public void testSetDuration() {
        LogEntryRequest request = new LogEntryRequest();
        request.setDuration(10L);
        assertEquals(10L, request.getDuration());
    }

    @Test
    public void testGetErrorFlag() {
        LogEntryRequest request = new LogEntryRequest();
        assertFalse(request.getErrorFlag());
    }

    @Test
    public void testSetThreadNumber() {
        LogEntryRequest request = new LogEntryRequest();
        request.setThreadNumber(123);
        assertEquals(123, request.getThreadNumber());
    }

    @Test
    public void testSetTsSend() {
        LogEntryRequest request = new LogEntryRequest();
        request.setTsSend(System.currentTimeMillis());
        assertTrue(request.getTsSend() > 0);
    }

    @Test
    public void testSetTsReceived() {
        LogEntryRequest request = new LogEntryRequest();
        request.setTsReceived(System.currentTimeMillis());
        assertTrue(request.getTsReceived() > 0);
    }

    @Test
    public void testGetDuration() {
        LogEntryRequest request = new LogEntryRequest();
        request.setDuration(10L);
        assertEquals(10L, request.getDuration());
    }

    @Test
    public void testGetThreadNumber() {
        LogEntryRequest request = new LogEntryRequest();
        request.setThreadNumber(123);
        assertEquals(123, request.getThreadNumber());
    }
}"
127,"public class TextButton {
    private String label;
    private Image image;
    private PlaceHolder placeHolder;

    public TextButton(String label, Image image, PlaceHolder placeHolder) {
        this.label = label;
        this.image = image;
        this.placeHolder = placeHolder;
    }

    // getters and setters for label, image, and placeHolder
}"
128,"import java.util.TreeMap;
import org.apache.commons.codec.binary.BaseEncoding;
import org.bitcoinj.core.NetworkParameters;
import org.bitcoinj.core.Sha256Hash;
import org.slf4j.Logger;

public class CheckpointManager {
    private final TreeMap<Long, StoredBlock> checkpoints;
    private final Sha256Hash dataHash;
    private final String TEXTUAL_MAGIC;
    private final Logger log;
    private final int MAX_SIGNATURES;
    private final String BINARY_MAGIC;
    private final NetworkParameters params;
    private final BaseEncoding BASE64;

    public CheckpointManager(TreeMap<Long, StoredBlock> checkpoints, Sha256Hash dataHash, String TEXTUAL_MAGIC, Logger log, int MAX_SIGNATURES, String BINARY_MAGIC, NetworkParameters params, BaseEncoding BASE64) {
        this.checkpoints = checkpoints;
        this.dataHash = dataHash;
        this.TEXTUAL_MAGIC = TEXTUAL_MAGIC;
        this.log = log;
        this.MAX_SIGNATURES = MAX_SIGNATURES;
        this.BINARY_MAGIC = BINARY_MAGIC;
        this.params = params;
        this.BASE64 = BASE64;
    }

    public Sha256Hash getCheckpointBefore(StoredBlock block) {
        return readTextual(block);
    }

    private Sha256Hash readBinary(int numCheckpoints) {
        // implementation of reading binary checkpoints
        return null;
    }

    public Sha256Hash getCheckpointAfter(StoredBlock block) {
        return readBinary(numCheckpoints);
    }

    private String readTextual(StoredBlock block) {
        // implementation of reading textual checkpoints
        return null;
    }
}"
129,"public class AddRecordFieldToStream {
    private ByteArrayOutputStream packed;
    private PackFormatInputStream format;

    public AddRecordFieldToStream(byte[] intBuf, int MAX_INT_BYTES) {
        this.packed = new ByteArrayOutputStream();
        this.format = new PackFormatInputStream(intBuf, MAX_INT_BYTES);
    }

    public void addRecordField(byte[] value) {
        // Add the record field to the stream
        packLong(value);
    }

    private void packLong(byte[] value) {
        // Pack the long value into the output stream
        this.packed.write(value);
    }

    public String getFormat() {
        return format.getFormat();
    }

    public void addShort(short value) {
        // Add the short value to the stream
        packed.write((byte) value);
    }

    public void addByte(byte value) {
        // Add the byte value to the stream
        packed.write(value);
    }

    public void addInt(int value) {
        // Add the int value to the stream
        packed.write((byte) (value >> 24));
        packed.write((byte) (value >> 16));
        packed.write((byte) (value >> 8));
        packed.write((byte) (value >> 0));
    }

    public void addLong(long value) {
        // Add the long value to the stream
        packed.write((byte) (value >> 56));
        packed.write((byte) (value >> 48));
        packed.write((byte) (value >> 40));
        packed.write((byte) (value >> 32));
        packed.write((byte) (value >> 24));
        packed.write((byte) (value >> 16));
        packed.write((byte) (value >> 8));
        packed.write((byte) (value >> 0));
    }

    public void addByteArray(byte[] value) {
        // Add the byte array to the stream
        for (int i = 0; i < value.length; i++) {
            packed.write(value[i]);
        }
    }

    public void addString(String value) {
        // Add the string to the stream
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            packed.write((byte) c);
        }
    }

    public byte[] getPacked() {
        return packed.toByteArray();
    }
}"
13,"// This code will close the current scans.
public void closeScans(Transaction tx, TableInfo ti, int nextblknum, Scan lhsscan, int chunksize, int filesize, Scan prodscan, Scan rhsscan) {
    if (tx != null) {
        tx.close();
    }
    if (ti != null) {
        ti.close();
    }
    if (lhsscan != null) {
        lhsscan.close();
    }
    if (chunksize > 0) {
        chunksize = 0;
    }
    if (filesize > 0) {
        filesize = 0;
    }
    if (prodscan != null) {
        prodscan.close();
    }
    if (rhsscan != null) {
        rhsscan.close();
    }
}"
130,"package net.sf.marineapi.nmea.parser;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;

public class HDTParserTest {
    private HDTParser hdtParser;

    @Before
    public void setUp() {
        hdtParser = new HDTParser();
    }

    @Test
    public void testConstructor() {
        assertNotNull(hdtParser);
    }

    @Test
    public void testSetHeading() {
        String heading = ""123.45"";
        hdtParser.setHeading(heading);
        assertEquals(heading, hdtParser.getHeading());
    }

    @Test
    public void testGetHeading() {
        String heading = ""123.45"";
        hdtParser.setHeading(heading);
        assertEquals(heading, hdtParser.getHeading());
    }

    @Test
    public void testSetNegativeHeading() {
        String heading = ""-123.45"";
        hdtParser.setHeading(heading);
        assertEquals(heading, hdtParser.getHeading());
    }

    @Test
    public void testSetHeadingTooHigh() {
        String heading = ""900.123456"";
        hdtParser.setHeading(heading);
        assertEquals(""360.0"", hdtParser.getHeading());
    }
}"
131,"[PYTHON]
class Signature:
    class Visibility:
        PUBLIC = 1
        PROTECTED = 2
        PRIVATE = 3
    
    def __init__(self, visMask):
        self.visMask = visMask
    
    def restrictVisibilitiesTo(self, other):
        self.visMask &= other.visMask
    
    def coverAllVisibilities(self):
        self.visMask |= Signature.Visibility.ALL
    
    @property
    def covers(self):
        return self.visMask == Signature.Visibility.ALL
[/PYTHON]
[TESTS]
# Test case 1:
assert Signature(Signature.Visibility.PUBLIC).coverAllVisibilities()
assert Signature(Signature.Visibility.PROTECTED).coverAllVisibilities()
assert Signature(Signature.Visibility.PRIVATE).coverAllVisibilities()
# Test case 2:
assert not Signature(Signature.Visibility.PUBLIC).covers
assert not Signature(Signature.Visibility.PROTECTED).covers
assert not Signature(Signature.Visibility.PRIVATE).covers
# Test case 3:
assert Signature(Signature.Visibility.PUBLIC).restrictVisibilitiesTo(Signature(Signature.Visibility.ALL)) == Signature(Signature.Visibility.PUBLIC)
assert Signature(Signature.Visibility.PROTECTED).restrictVisibilitiesTo(Signature(Signature.Visibility.ALL)) == Signature(Signature.Visibility.PROTECTED)
assert Signature(Signature.Visibility.PRIVATE).restrictVisibilitiesTo(Signature(Signature.Visibility.ALL)) == Signature(Signature.Visibility.PRIVATE)
# Test case 4:
assert Signature(Signature.Visibility.PUBLIC).restrictVisibilitiesTo(Signature(Signature.Visibility.PUBLIC)) == Signature(Signature.Visibility.PUBLIC)
assert Signature(Signature.Visibility.PROTECTED).restrictVisibilitiesTo(Signature(Signature.Visibility.PROTECTED)) == Signature(Signature.Visibility.PROTECTED)
assert Signature(Signature.Visibility.PRIVATE).restrictVisibilitiesTo(Signature(Signature.Visibility.PRIVATE)) == Signature(Signature.Visibility.PRIVATE)
# Test case 5:
assert Signature(Signature.Visibility.PUBLIC).restrictVisibilitiesTo(Signature(Signature.Visibility.PROTECTED)) == Signature(Signature.Visibility.PROTECTED)
assert Signature(Signature.Visibility.PROTECTED).restrictVisibilitiesTo(Signature(Signature.Visibility.PUBLIC)) == Signature(Signature.Visibility.PUBLIC)
# Test case 6:
assert Signature(Signature.Visibility.PUBLIC).restrictVisibilitiesTo(Signature(Signature.Visibility.PRIVATE)) == Signature(Signature.Visibility.PRIVATE)
assert Signature(Signature.Visibility.PROTECTED).restrictVisibilitiesTo(Signature(Signature.Visibility.PUBLIC)) == Signature(Signature.Visibility.PUBLIC)
# Test case 7:
assert Signature(Signature.Visibility.PRIVATE).restrictVisibilitiesTo(Signature(Signature.Visibility.PROTECTED)) == Signature(Signature.Visibility.PROTECTED)
assert Signature(Signature.Visibility.PUBLIC).restrictVisibilitiesTo(Signature(Signature.Visibility.PRIVATE)) == Signature(Signature.Visibility.PRIVATE)
# Test case 8:
assert Signature(Signature.Visibility.PUBLIC).coverAllVisibilities()
assert Signature(Signature.Visibility.PROTECTED).coverAllVisibilities()
assert Signature(Signature.Visibility.PRIVATE).coverAllVisibilities()
# Test case 9:
assert not Signature(Signature.Visibility.PUBLIC).covers
assert not Signature(Signature.Visibility.PROTECTED).covers
assert not Signature(Signature.Visibility.PRIVATE).covers
[/TESTS]"
132,"import java.util.Scanner;
public class UserInput {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Please enter a string: "");
        String input = scanner.nextLine();
        System.out.print(""Your input was: "" + input);
        char getChar;
        int getInt;
        double getDouble;
        boolean getBoolean;
        do {
            System.out.print(""Please enter a char: "");
            getChar = scanner.next().charAt(0);
            System.out.print(""Your input was: "" + getChar);
            if (getChar != '\n') {
                System.out.print(""You must enter only one character. Please try again."");
            } else {
                break;
            }
        } while (true);
        do {
            System.out.print(""Please enter an integer: "");
            getInt = scanner.nextInt();
            System.out.print(""Your input was: "" + getInt);
            if (!scanner.hasNextInt()) {
                System.out.print(""You must enter only integers. Please try again."");
            } else {
                break;
            }
        } while (true);
        do {
            System.out.print(""Please enter a double: "");
            getDouble = scanner.nextDouble();
            System.out.print(""Your input was: "" + getDouble);
            if (!scanner.hasNextDouble()) {
                System.out.print(""You must enter only double numbers. Please try again."");
            } else {
                break;
            }
        } while (true);
        do {
            System.out.print(""Please enter a boolean: "");
            getBoolean = scanner.nextBoolean();
            System.out.print(""Your input was: "" + getBoolean);
            if (!scanner.hasNextBoolean()) {
                System.out.print(""You must enter only booleans. Please try again."");
            } else {
                break;
            }
        } while (true);
    }
}"
133,"import java.util.List;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;

public class SupportedOptions {
    public static void main(String[] args) {
        Options options = new Options();

        // Mount shared option
        Option mountSharedOption = new Option(""m"", ""mount-shared"");
        mountSharedOption.setRequired(false);
        options.addOption(mountSharedOption);

        // Recursive option
        Option recursiveOption = new Option(""r"", ""recursive"");
        recursiveOption.setRequired(false);
        options.addOption(recursiveOption);

        // Force option
        Option forceOption = new Option(""f"", ""force"");
        forceOption.setRequired(false);
        options.addOption(forceOption);

        // Property file option
        Option propertyFileOption = new Option(""p"", ""property-file"");
        propertyFileOption.setRequired(false);
        options.addOption(propertyFileOption);

        // Readonly option
        Option readonlyOption = new Option(""ro"", ""readonly"");
        readonlyOption.setRequired(false);
        options.addOption(readonlyOption);

        CommandLine commandLine = null;
        try {
            commandLine = parseAndValidateArgs(options, args);
        } catch (Exception e) {
            System.out.println(""Error: "" + e.getMessage());
            return;
        }

        if (commandLine != null) {
            int numOfArgs = getNumOfArgs(args);
            boolean validateArgs = validateArgs(options, args);

            if (!validateArgs) {
                System.out.println(""Error: Invalid arguments"");
                return;
            }

            // Do something with the validated command line options
        }
    }

    public static CommandLine parseAndValidateArgs(Options options, String[] args) throws Exception {
        CommandLineParser parser = new DefaultParser();
        CommandLine commandLine = parser.parse(options, args);

        if (commandLine == null || commandLine.getArgList().isEmpty()) {
            throw new Exception(""Invalid arguments"");
        }

        return commandLine;
    }

    public static int getNumOfArgs(String[] args) {
        return args.length;
    }

    public static boolean validateArgs(Options options, String[] args) {
        // Validate the command line options
        for (Option option : options.getOptions()) {
            if (!option.getOpt().equals(""m"") && !option.getOpt().equals(""r"") && !option.getOpt().equals(""f"") && !option.getOpt().equals(""p"") && !option.getOpt().equals(""ro"")) {
                return false;
            }
        }

        // Validate the arguments
        for (String arg : args) {
            if (!arg.startsWith(""-"")) {
                return false;
            }
        }

        return true;
    }
}"
134,"package net.sf.marineapi.nmea.parser;

import static org.junit.Assert.assertEquals;
import org.junit.Before;
import org.junit.Test;

public class VHWParserTest {
    private VHWParser vhw;

    @Before
    public void setUp() throws Exception {
        vhw = new VHWParser();
    }

    @Test
    public void testConstructorString() {
        String sentence = ""$VHW,180.0,T"";
        assertEquals(sentence, vhw.getSentence());
    }

    @Test
    public void testConstructorTalkerId() {
        String talkerId = ""VHW"";
        assertEquals(talkerId, vhw.getTalkerId());
    }

    @Test
    public void testIsTrue() {
        boolean isTrue = true;
        assertEquals(isTrue, vhw.isValid());
    }

    @Test
    public void testGetHeading() {
        double heading = 180;
        assertEquals(heading, vhw.getHeading(), 0.001);
    }

    @Test
    public void testSetHeading() {
        String sentence = ""$VHW,180.0,T"";
        vhw.setSentence(sentence);
        assertEquals(heading, vhw.getHeading(), 0.001);
    }

    @Test
    public void testGetMagneticHeading() {
        double magneticHeading = 180;
        assertEquals(magneticHeading, vhw.getMagneticHeading(), 0.001);
    }

    @Test
    public void testSetMagneticHeading() {
        String sentence = ""$VHW,180.0,T"";
        vhw.setSentence(sentence);
        assertEquals(magneticHeading, vhw.getMagneticHeading(), 0.001);
    }

    @Test
    public void testGetSpeedKilometres() {
        double speed = 180;
        assertEquals(speed, vhw.getSpeedKilometres(), 0.001);
    }

    @Test
    public void testSetSpeedKilometres() {
        String sentence = ""$VHW,180.0,T"";
        vhw.setSentence(sentence);
        assertEquals(speed, vhw.getSpeedKilometres(), 0.001);
    }

    @Test
    public void testGetSpeedKnots() {
        double speed = 180;
        assertEquals(speed, vhw.getSpeedKnots(), 0.001);
    }

    @Test
    public void testSetSpeedKnots() {
        String sentence = ""$VHW,180.0,T"";
        vhw.setSentence(sentence);
        assertEquals(speed, vhw.getSpeedKnots(), 0.001);
    }
}"
135,"// Returns for binary constraints the other variable from the scope.
private static Variable getOtherVariable(Variable var, Constraint c) {
    // Check if the constraint is a binary constraint
    if (c instanceof BinaryConstraint) {
        BinaryConstraint binCon = (BinaryConstraint) c;
        // If yes, return the other variable from the scope
        return binCon.getOtherVariable(var);
    } else {
        // Otherwise, return null
        return null;
    }
}

// Returns a list of variables for the given constraints.
public static List<Variable> getVariables(List<Constraint> constraints) {
    // Create an empty list to store the variables
    List<Variable> variables = new ArrayList<>();
    // Iterate over the constraints and add their variables to the list
    for (Constraint c : constraints) {
        variables.addAll(c.getVariables());
    }
    return variables;
}

// Returns a list of domains for the given variables.
public static List<Domain> getDomains(List<Variable> variables) {
    // Create an empty list to store the domains
    List<Domain> domains = new ArrayList<>();
    // Iterate over the variables and add their domains to the list
    for (Variable v : variables) {
        domains.add(v.getDomain());
    }
    return domains;
}

// Returns a list of constraints for the given variables.
public static List<Constraint> getConstraints(List<Variable> variables) {
    // Create an empty list to store the constraints
    List<Constraint> constraints = new ArrayList<>();
    // Iterate over the variables and add their constraints to the list
    for (Variable v : variables) {
        constraints.addAll(v.getConstraints());
    }
    return constraints;
}

// Returns a domain for the given variable.
public static Domain getDomain(Variable var) {
    // Return the domain of the variable
    return var.getDomain();
}

// Returns a list of constraints for the given domain.
public static List<Constraint> getConstraints(Domain domain) {
    // Create an empty list to store the constraints
    List<Constraint> constraints = new ArrayList<>();
    // Iterate over the variables in the domain and add their constraints to the list
    for (Variable v : domain.getVariables()) {
        constraints.addAll(v.getConstraints());
    }
    return constraints;
}

// Returns a list of variables for the given constraint.
public static List<Variable> getVariables(Constraint c) {
    // Create an empty list to store the variables
    List<Variable> variables = new ArrayList<>();
    // Add the variables from the constraint to the list
    variables.addAll(c.getVariables());
    return variables;
}

// Removes a value from the domain of the given variable.
public static void removeValueFromDomain(Variable var, Object value) {
    var.removeValueFromDomain(value);
}

// Sets the domain of the given variable to the given list of values.
public static void setDomain(Variable var, List<Object> values) {
    var.setDomain(values);
}

// Adds a constraint to the given variable.
public static void addConstraint(Variable var, Constraint c) {
    var.addConstraint(c);
}

// Returns the index of the given value in the list of values for the given domain.
public static int indexOf(Domain domain, Object value) {
    return domain.indexOf(value);
}

// Copies the domains of the variables in the given list to a new CSP object.
public static CSP copyDomains(List<Variable> variables) {
    // Create a new CSP object with an empty set of constraints
    CSP csp = new CSP();
    // Iterate over the variables and add their domains to the new CSP object
    for (Variable v : variables) {
        csp.addDomain(v.getDomain());
    }
    return csp;
}"
136,"package com.example;

import java.sql.Timestamp;

public class TrafficLane {
    private int volume;
    private double occupancy;
    private Timestamp measurementDate;
    private int laneId;
    private long id;
    private double speed;
    private int quality;

    public void setOccupancy(double occupancy) {
        this.occupancy = occupancy;
    }

    public Timestamp getMeasurement_date() {
        return measurementDate;
    }

    public void setMeasurement_date(Timestamp measurementDate) {
        this.measurementDate = measurementDate;
    }

    public int getLane_id() {
        return laneId;
    }

    public void setLane_id(int laneId) {
        this.laneId = laneId;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public void setVolume(int volume) {
        this.volume = volume;
    }

    public int getVolume() {
        return volume;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public int getQuality() {
        return quality;
    }

    public void setQuality(int quality) {
        this.quality = quality;
    }

    @Override
    public String toString() {
        return ""TrafficLane{"" +
                ""volume="" + volume +
                "", occupancy="" + occupancy +
                "", measurementDate="" + measurementDate +
                "", laneId="" + laneId +
                "", id="" + id +
                "", speed="" + speed +
                "", quality="" + quality +
                '}';
    }
}"
137,"public enum ScopeKind {
    CLASSIFIER(java.util.List<String> typeName) {
        return ""ScopeKindEnum SK_CLASSIFIER"";
    },
    INSTANCE(String literalName) {
        return ""ScopeKindEnum SK_INSTANCE"";
    };
    
    private final java.lang.Object readResolve() {
        try {
            ScopeKind kind = ScopeKind.forName(this.getClass().getName());
            if (kind != null) {
                return kind;
            }
        } catch (Exception e) {
            System.out.println(""Error occurred while reading resolved ScopeKind: "" + e);
        }
        return this;
    };
    
    private final java.util.List<String> refTypeName() {
        switch (this) {
            case CLASSIFIER:
                return java.util.Collections.singletonList(""ScopeKindEnum SK_CLASSIFIER"");
            case INSTANCE:
                return java.util.Collections.singletonList(""ScopeKindEnum SK_INSTANCE"");
        }
    };
    
    private final int hashCode() {
        return this.name().hashCode();
    };
    
    private final boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        
        if (!(other instanceof ScopeKind)) {
            return false;
        }
        
        ScopeKind otherScopeKind = (ScopeKind) other;
        return this.name().equals(otherScopeKind.name());
    };
}"
138,"import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import javax.swing.*;

public class XHTMLPanel extends JComponent {
    private SharedContext sharedContext;

    public void setSharedContext(SharedContext sharedContext) {
        this.sharedContext = sharedContext;
    }

    public BufferedImage renderToImageAutoSize() {
        Dimension dim = getMinimumSize();
        return renderToImage(dim);
    }

    private BufferedImage renderToImage(Dimension dim) {
        JPanel panel = getPanel();
        SharedContext sharedContext = getSharedContext();

        BufferedImage image = new BufferedImage(dim.width, dim.height, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = image.createGraphics();
        try {
            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        } catch (NullPointerException e) {
            // ignore, this is just a fallback in case the sharedContext or panel is null
        }

        panel.paint(g2d);

        return image;
    }
}"
139,"public class TodoItem {
    private String priority;
    private String moreInfoURL;
    private String description;

    public String getPriority() {
        return this.priority;
    }

    public void setPriority(String priority) {
        this.priority = priority;
    }

    public String getMoreInfoURL() {
        return this.moreInfoURL;
    }

    public void setMoreInfoURL(String moreInfoURL) {
        this.moreInfoURL = moreInfoURL;
    }

    public String getDescription() {
        return this.description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String encodeHeadline() {
        // Encode the headline in an XML safe way
        String encodedHeadline = XmlUtils.encodeXmlText(this.getPriority());
        return encodedHeadline;
    }
}"
14,"package com.example;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class UserStoreManager {
    private Map<String, Map<String, String>> userStoreManagers = new HashMap<>();

    public void clearUserStoreManager() {
        this.userStoreManagers.clear();
    }

    public void addUserStoreManager(String propertyname, String propertyvalue) {
        this.userStoreManagers.put(propertyname, Map.of(""propertyvalue"", propertyvalue));
    }

    public Set<String> getAvailableDomainNames() {
        return this.userStoreManagers.keySet();
    }

    public Map<String, String> getUserStoreManager(String propertyname) {
        return this.userStoreManagers.get(propertyname);
    }
}"
140,"import java.util.List;

public class Bank {
    private List<Customer> customers;

    public void addCustomer(Customer customer) {
        customers.add(customer);
    }

    public double totalInterestPaid() {
        double total = 0.0;
        for (Customer customer : customers) {
            total += customer.getAccountNumberSummary();
        }
        return total;
    }

    public String format(double total) {
        return String.format(""Total interest paid: $%.2f"", total);
    }
}"
141,"import java.util.ArrayList;

public class Stats {
    private long count = 0;
    private double max = Double.NEGATIVE_INFINITY;
    private double min = Double.POSITIVE_INFINITY;
    private double sum = 0;
    private double sumOfSquaresOfDeltas = 0;

    public void add(double value) {
        count++;
        sum += value;
        if (value > max) {
            max = value;
        }
        if (value < min) {
            min = value;
        }
        sumOfSquaresOfDeltas += (value - mean()) * (value - mean());
    }

    public void addAll(ArrayList<Double> values) {
        for (double value : values) {
            add(value);
        }
    }

    public double mean() {
        if (count == 0) {
            return Double.NaN;
        }
        return sum / count;
    }

    public long count() {
        return count;
    }

    public double sampleVariance() {
        if (count <= 1) {
            return Double.NaN;
        }
        return sumOfSquaresOfDeltas / (count - 1);
    }

    public double populationVariance() {
        if (count == 0) {
            return Double.NaN;
        }
        return sumOfSquaresOfDeltas / count;
    }

    public double sampleStandardDeviation() {
        if (count <= 1) {
            return Double.NaN;
        }
        return Math.sqrt(sampleVariance());
    }

    public double populationStandardDeviation() {
        if (count == 0) {
            return Double.NaN;
        }
        return Math.sqrt(populationVariance());
    }

    public Stats snapshot() {
        Stats stats = new Stats();
        stats.addAll(values);
        return stats;
    }
}"
142,"import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class DeviceTest {
    private Device dev;

    @BeforeEach
    void setUp() {
        dev = new Device();
    }

    @Test
    void testGetDeviceName_0args() {
        assertEquals("""", dev.getDeviceName());
    }

    @Test
    void testAddToPane() {
        // TODO: Add test for addToPane method
    }

    @Test
    void testGetAddress() {
        // TODO: Add test for getAddress method
    }

    @Test
    void testGetDeviceName_Locale() {
        // TODO: Add test for getDeviceName(Locale) method
    }

    @Test
    void testAddCapability() {
        // TODO: Add test for addCapability method
    }

    @Test
    void testGetImage() {
        // TODO: Add test for getImage method
    }

    @Test
    void testGetDeviceID() {
        // TODO: Add test for getDeviceID method
    }

    @Test
    void testGetCapabilityBlock() {
        // TODO: Add test for getCapabilityBlock method
    }

    @Test
    void testGetCapabilities() {
        // TODO: Add test for getCapabilities method
    }

    @Test
    void testRemoveCapability() {
        // TODO: Add test for removeCapability method
    }
}"
143,"public class GeneralMotorCon {
    private static final String TAG = ""GeneralMotorCon"";

    // instance variables
    private int spin90Time;
    private String batLvl;
    private long threadTimer;
    private int spinSpeed;
    private CommandManager cmd;
    private int hoverTime;
    private int speed;
    private int spin90Speed;
    private ARDrone drone;
    private int spinTime;

    // constructor
    public GeneralMotorCon() {
        this.spin90Time = 250;
        this.batLvl = ""FULL"";
        this.threadTimer = 1000;
        this.spinSpeed = 30;
        this.cmd = new CommandManager(this);
        this.hoverTime = 1000;
        this.speed = 50;
        this.spin90Speed = 90;
        this.drone = new ARDrone();
        this.spinTime = 200;
    }

    // methods
    public void spin90Left() {
        drone.move(speed, speed, -1 * spinSpeed);
    }

    public void spinRight() {
        drone.move(-1 * speed, speed, spinSpeed);
    }

    public void takeoff() {
        drone.takeoff();
    }

    public void forward() {
        drone.forward(speed);
    }

    public void spinLeft() {
        drone.move(speed, speed, -1 * spinSpeed);
    }

    public void right() {
        drone.right(speed);
    }

    public void spin90Right() {
        drone.move(-1 * speed, speed, spinSpeed);
    }

    public void landing() {
        drone.landing();
    }

    public void setDrone(ARDrone drone) {
        this.drone = drone;
    }

    public void left() {
        drone.left(speed);
    }

    public void backward() {
        drone.backward(speed);
    }

    public static GeneralMotorCon getInstance() {
        return new GeneralMotorCon();
    }

    public void setBatLvl(String batLvl) {
        this.batLvl = batLvl;
    }

    public void waitFor(int time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public int getBatLvl() {
        return batLvl;
    }

    public void onStop() {
        drone.stop();
    }

    public void raiseAltitude(int altitude) {
        drone.moveUp(altitude);
    }
}"
144,"// Class to represent a buffer
class Buffer {
    // Initial capacity of the buffer
    private static final int INITIAL_BUFFER_CAPACITY = 10;
    
    // Current size of the buffer
    private int bufferSize;
    
    // Underlying byte array
    private byte[] buffer;
    
    public Buffer() {
        this.bufferSize = INITIAL_BUFFER_CAPACITY;
        this.buffer = new byte[INITIAL_BUFFER_CAPACITY];
    }
    
    // Method to clear the buffer
    public void clear() {
        this.bufferSize = 0;
        this.buffer = null;
    }
    
    // Method to add data to the buffer
    public void add(byte[] data) {
        if (this.buffer == null) {
            this.buffer = new byte[INITIAL_BUFFER_CAPACITY];
        } else if (this.bufferSize + data.length > this.buffer.length) {
            // Increase the size of the buffer if needed
            int newCapacity = Math.max(this.buffer.length * 2, this.bufferSize + data.length);
            byte[] newBuffer = new byte[newCapacity];
            System.arraycopy(this.buffer, 0, newBuffer, 0, this.bufferSize);
            this.buffer = newBuffer;
        }
        
        // Copy the data to the buffer
        System.arraycopy(data, 0, this.buffer, this.bufferSize, data.length);
        this.bufferSize += data.length;
    }
    
    // Method to get the contents of the buffer as a byte array
    public byte[] toArray() {
        return Arrays.copyOf(this.buffer, this.bufferSize);
    }
    
    // Method to check if the buffer is empty
    public boolean isEmpty() {
        return this.bufferSize == 0;
    }
    
    // Method to convert the buffer to a string
    @Override
    public String toString() {
        return new String(this.toArray());
    }
}"
145,"public class NetworkParameters {
    private int addressHeader;
    private int interval;
    private byte[] alertSigningKey;
    private int[] acceptableAddressCodes;
    private long packetMagic;
    private int p2shHeader;
    private List<NetworkParameters> paramSet;
    private int protocolVersion;
    private Block genesisBlock;
    private BigInteger proofOfWorkLimit;
    private int subsidyDecreaseBlockCount;
    private int port;
    private BigInteger maxMoney;
    private int targetTimespan;
    private String[] dnsSeeds;
    private Map<Integer,Sha256Hash> checkpoints;
    private byte[] satoshiKey;

    public NetworkParameters(int addressHeader, int interval, byte[] alertSigningKey, int[] acceptableAddressCodes, long packetMagic, int p2shHeader, List<NetworkParameters> paramSet, int protocolVersion, Block genesisBlock, BigInteger proofOfWorkLimit, int subsidyDecreaseBlockCount, int port, BigInteger maxMoney, int targetTimespan, String[] dnsSeeds, Map<Integer,Sha256Hash> checkpoints, byte[] satoshiKey) {
        this.addressHeader = addressHeader;
        this.interval = interval;
        this.alertSigningKey = alertSigningKey;
        this.acceptableAddressCodes = acceptableAddressCodes;
        this.packetMagic = packetMagic;
        this.p2shHeader = p2shHeader;
        this.paramSet = paramSet;
        this.protocolVersion = protocolVersion;
        this.genesisBlock = genesisBlock;
        this.proofOfWorkLimit = proofOfWorkLimit;
        this.subsidyDecreaseBlockCount = subsidyDecreaseBlockCount;
        this.port = port;
        this.maxMoney = maxMoney;
        this.targetTimespan = targetTimespan;
        this.dnsSeeds = dnsSeeds;
        this.checkpoints = checkpoints;
        this.satoshiKey = satoshiKey;
    }

    public int getAddressHeader() {
        return addressHeader;
    }

    public int getInterval() {
        return interval;
    }

    public byte[] getAlertSigningKey() {
        return alertSigningKey;
    }

    public int[] getAcceptableAddressCodes() {
        return acceptableAddressCodes;
    }

    public long getPacketMagic() {
        return packetMagic;
    }

    public int getP2SHHeader() {
        return p2shHeader;
    }

    public List<NetworkParameters> getParamSet() {
        return paramSet;
    }

    public int getProtocolVersion() {
        return protocolVersion;
    }

    public Block getGenesisBlock() {
        return genesisBlock;
    }

    public BigInteger getProofOfWorkLimit() {
        return proofOfWorkLimit;
    }

    public int getSubsidyDecreaseBlockCount() {
        return subsidyDecreaseBlockCount;
    }

    public int getPort() {
        return port;
    }

    public BigInteger getMaxMoney() {
        return maxMoney;
    }

    public int getTargetTimespan() {
        return targetTimespan;
    }

    public String[] getDnsSeeds() {
        return dnsSeeds;
    }

    public Map<Integer,Sha256Hash> getCheckpoints() {
        return checkpoints;
    }

    public byte[] getSatoshiKey() {
        return satoshiKey;
    }
}"
146,"import android.content.ContentResolver;
import android.content.UriMatcher;
import android.net.Uri;
import android.util.Log;

import java.util.List;
import java.util.Map;

public class MimeTypeUtil {
    private static final String TAG = ""MimeTypeUtil"";

    public static String getFullMimeType(Uri uri) {
        // Get the authority of the URI
        String authority = uri.getAuthority();

        // Get the instance of the UriMatcher for this authority
        UriMatcher uriMatcher = ContentResolver.getInstance().getAuthority(authority);

        // Get the table name from the URI
        String tableName = uri.getPathSegments().get(0);

        // Get the entry for this table in the UriMatcher
        E matcherEntry = getMatcherEntry(uriMatcher, tableName);

        // If the entry is not null, return its mime type
        if (matcherEntry != null) {
            return matcherEntry.getMimeType();
        } else {
            Log.w(TAG, ""Could not find a match for URI: "" + uri);
            return null;
        }
    }

    private static E getMatcherEntry(UriMatcher uriMatcher, String tableName) {
        List<E> entries = uriMatcher.getEntries();
        for (E entry : entries) {
            if (entry.getTableName().equals(tableName)) {
                return entry;
            }
        }
        return null;
    }
}"
147,"public static void writeShortToLittleEndian(short x, OutputStream stream) {
    byte[] bytes = new byte[2];
    ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN).putShort(x);
    stream.write(bytes);
}"
148,"import java.util.*;

class HouseholderReflection {
    private static final double EPSILON = 1e-6;

    public static void mult(double[] y, double[] x, double gamma) {
        int n = x.length;
        double u = Math.sqrt((gamma * gamma) / (2.0 * (n - 1)));
        for (int i = 0; i < n; i++) {
            y[i] = i + u * x[i];
        }
    }

    public static double innerProdA(double[] y, double[] x) {
        int n = x.length;
        double sum = 0.0;
        for (int i = 0; i < n; i++) {
            sum += y[i] * x[i];
        }
        return sum;
    }

    public static double innerProdTranA(double[] y, double[] x) {
        int n = x.length;
        double sum = 0.0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                sum += y[j] * x[i];
            }
        }
        return sum;
    }

    public static void addOuterProd(double[] y, double[] x, double[] a) {
        int n = x.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                y[i] += a[j] * x[j];
            }
        }
    }

    public static void rank1Update(double[] x, double[] u, double[] v) {
        int n = x.length;
        for (int i = 0; i < n; i++) {
            x[i] += u[i] * v[i];
        }
    }

    public static void rank1Update(double[] x, double[] u, double[] v) {
        int n = x.length;
        for (int i = 0; i < n; i++) {
            x[i] -= u[i] * v[i];
        }
    }

    public static double innerProd(double[] y, double[] x) {
        int n = x.length;
        double sum = 0.0;
        for (int i = 0; i < n; i++) {
            sum += y[i] * x[i];
        }
        return sum;
    }

    public static void outerProd(double[] y, double[] x) {
        int n = x.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                y[i] += x[j] * x[i];
            }
        }
    }
}"
149,"import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.output.CountingOutputStream;

public class TarXZ {
    private static final Logger LOGGER = Logger.getLogger(TarXZ.class.getName());

    public void tarXZ(String revision, String basepath, OutputStream outputStream) throws IOException {
        boolean zip = false;
        boolean gz = true;
        boolean tar = true;
        boolean bzip2 = false;

        TarArchiveOutputStream os = new TarArchiveOutputStream(outputStream);
        CountingOutputStream cos = new CountingOutputStream(os);

        try {
            File file = new File(basepath);
            if (file.exists()) {
                File[] files = file.listFiles();
                for (File f : files) {
                    TarArchiveEntry entry = new TarArchiveEntry(f, f.getName());
                    os.putArchiveEntry(entry);
                    IOUtils.copy(new FileInputStream(f), cos);
                    os.closeArchiveEntry();
                }
            } else {
                LOGGER.warning(""Cannot find file "" + basepath);
            }
        } catch (IOException e) {
            throw new IOException(""Error occurred while tarXZ"", e);
        } finally {
            cos.close();
        }
    }
}"
15,"import java.io.InputStream;
import java.net.URI;
import java.util.Map;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.events.XMLEvent;
import org.w3c.dom.Document;

public class XMLUtils {
    public static Map<String, String> namespaces(InputStream stream) throws XMLStreamException {
        XMLEventReader reader = XMLEventReaderFactory.newInstance().createXMLEventReader(stream);
        URI[] links = getLinks(reader);
        return Arrays.asList(links).stream()
            .map(link -> getPrefix(link))
            .collect(Collectors.toMap(prefix -> prefix, prefix -> getNamespaceURI(prefix)));
    }

    private static URI[] getLinks(XMLEventReader reader) {
        List<URI> links = new ArrayList<>();
        while (reader.hasNext()) {
            XMLEvent event = reader.nextEvent();
            if (event instanceof StartElement || event instanceof EndElement) {
                URI link = getLink(event);
                if (link != null) {
                    links.add(link);
                }
            }
        }
        return links.toArray(new URI[0]);
    }

    private static String getPrefix(URI uri) {
        return uri.toString();
    }

    private static String getNamespaceURI(String prefix) {
        // TODO: Implement logic to retrieve the namespace URI for a given prefix
        return null;
    }

    public static T[] getNodes(InputStream stream, Class<T> clazz) throws XMLStreamException {
        XMLEventReader reader = XMLEventReaderFactory.newInstance().createXMLEventReader(stream);
        List<T> nodes = new ArrayList<>();
        while (reader.hasNext()) {
            XMLEvent event = reader.nextEvent();
            if (event instanceof StartElement || event instanceof EndElement) {
                T node = getNode(event, clazz);
                if (node != null) {
                    nodes.add(node);
                }
            }
        }
        return nodes.toArray(new T[0]);
    }

    private static <T> T getNode(XMLEvent event, Class<T> clazz) throws XMLStreamException {
        // TODO: Implement logic to create an instance of the given class from the provided XML event
        return null;
    }

    public static void setBuffering(InputStream stream, boolean buffered) {
        // TODO: Implement logic to set the buffering flag for the input stream
    }

    public static String getValue(XMLEventReader reader) throws XMLStreamException {
        if (reader.hasNext()) {
            XMLEvent event = reader.nextEvent();
            return event.toString();
        } else {
            return null;
        }
    }

    public static String getValue(XMLEventReader reader, Class<T> clazz) throws XMLStreamException {
        // TODO: Implement logic to read the value of a given XML event for a given class type
        return null;
    }

    public static URI getLink(XMLEvent event) {
        // TODO: Implement logic to extract the link from an XML event
        return null;
    }

    public static URI getBaseURI(XMLEventReader reader) {
        // TODO: Implement logic to retrieve the base URI for a given XML event reader
        return null;
    }

    public static Object evaluate(XMLEventReader reader, XPathExpression expr) throws XPathExpressionException {
        // TODO: Implement logic to evaluate an XPath expression on the provided XML event reader
        return null;
    }

    public static T readNode(InputStream stream, Class<T> clazz) throws XMLStreamException {
        XMLEventReader reader = XMLEventReaderFactory.newInstance().createXMLEventReader(stream);
        return readNode(reader, clazz);
    }

    private static <T> T readNode(XMLEventReader reader, Class<T> clazz) throws XMLStreamException {
        // TODO: Implement logic to read an instance of the given class from the provided XML event reader
        return null;
    }
}"
150,"[PYTHON]
class Builder:
    def __init__(self, language):
        self.language = language

    def build(self, query):
        return f""{self.language} {query}""

builder = Builder(""en"")
result = builder.build(""Hello World"")
print(result)
[/PYTHON]
[TESTS]
# Test case 1:
assert Builder(""en"").build(""Hello World"") == ""en Hello World""
# Test case 2:
assert Builder(""es"").build(""Hola Mundo"") == ""es Hola Mundo""
# Test case 3:
assert Builder(""fr"").build(""Bonjour le monde"") == ""fr Bonjour le monde""
[/TESTS]"
151,"import java.util.*;

class Node {
    private String name;
    private List<Node> subnodes = new ArrayList<>();

    public Node(String name) {
        this.name = name;
    }

    public void addSubnode(Node node) {
        subnodes.add(node);
    }

    public void removeSubnode(Node node) {
        subnodes.remove(node);
    }

    public List<Node> getSubnodes() {
        return subnodes;
    }

    // If clazz is not null, only nodes of the given class are put in the set of nodes
    public void assertNumberOfNodes(Class<? extends Node> clazz) {
        if (clazz != null) {
            for (Node node : subnodes) {
                if (!node.getClass().equals(clazz)) {
                    throw new IllegalArgumentException(""Node "" + node.getName() + "" is not of class "" + clazz);
                }
            }
        } else {
            for (Node node : subnodes) {
                if (node.getClass().equals(clazz)) {
                    throw new IllegalArgumentException(""Node "" + node.getName() + "" is not of class "" + clazz);
                }
            }
        }
    }

    // If clazz is not null, only nodes of the given class are put in the set of nodes
    public Set<T> getNodesOfType(Class<? extends Node> clazz) {
        if (clazz != null) {
            Set<T> result = new HashSet<>();
            for (Node node : subnodes) {
                if (node.getClass().equals(clazz)) {
                    result.add((T) node);
                }
            }
            return result;
        } else {
            return null;
        }
    }
}"
152,"// Java code for the HandwriterView view class
package com.example.handwriterview;

import android.content.Context;
import android.graphics.Rect;
import android.graphics.RectF;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

public class HandwriterView extends View {
    private RectF mRectF;
    private boolean getOnlyPenInput;
    private float getScaledPenThickness;

    public HandwriterView(Context context) {
        this(context, null);
    }

    public HandwriterView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mRectF = new RectF();
        getOnlyPenInput = false;
        getScaledPenThickness = 10f;
    }

    public boolean onTouchEvent(MotionEvent event) {
        Page page = getPage();
        if (page != null && !getDoubleTapWhileWriting() && !getMoveGestureWhileWriting()) {
            switch (event.getActionMasked()) {
                case MotionEvent.ACTION_DOWN:
                    if (!useForWriting(event)) {
                        return false;
                    }
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (getMoveGestureMinDistance() > 0) {
                        float currentX = event.getRawX();
                        float currentY = event.getRawY();
                        if (Math.abs(currentX - mRectF.centerX()) > getMoveGestureMinDistance() || Math.abs(currentY - mRectF.centerY()) > getMoveGestureMinDistance()) {
                            return false;
                        }
                    }
                    break;
                case MotionEvent.ACTION_UP:
                    if (getOnlyPenInput && !useForWriting(event)) {
                        return false;
                    }
                    break;
            }
        }
        return true;
    }

    public Page getPage() {
        return null;
    }

    public boolean getDoubleTapWhileWriting() {
        return false;
    }

    public boolean getMoveGestureWhileWriting() {
        return false;
    }

    public void drawPinchZoomPreview(Canvas canvas) {}

    public void destroy() {}

    private Transformation pinchZoomTransform = new Transformation();

    public void draw(Canvas canvas) {
        if (getOnlyPenInput && !useForWriting()) {
            return;
        }
        if (pinchZoomScaleFactor != 1f) {
            drawPinchZoomPreview(canvas);
            return;
        }
        mRectF.set(getScaledPenThickness / 2, getScaledPenThickness / 2, getWidth() - getScaledPenThickness / 2, getHeight() - getScaledPenThickness / 2);
        canvas.drawRect(mRectF, getPaint());
    }

    public boolean useForWriting() {
        return false;
    }

    public void redraw() {}

    public float pinchZoomScaleFactor = 1f;

    public void interrupt() {}

    private Context getContext() {
        return null;
    }

    public int getMoveGestureMinDistance() {
        return 0;
    }
}"
153,"package com.example;

import javax.ws.rs.client.Client;
import javax.ws.rs.core.MultivaluedMap;

public class OAuthDataProvider {
    private boolean writeOptionalParameters = true;
    private boolean blockUnsecureRequests = false;

    public boolean isWriteOptionalParameters() {
        return writeOptionalParameters;
    }

    public void setWriteOptionalParameters(boolean writeOptionalParameters) {
        this.writeOptionalParameters = writeOptionalParameters;
    }

    public boolean isBlockUnsecureRequests() {
        return blockUnsecureRequests;
    }

    public void setBlockUnsecureRequests(boolean blockUnsecureRequests) {
        this.blockUnsecureRequests = blockUnsecureRequests;
    }
}"
154,"import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationContext;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Presence;
import org.jivesoftware.smack.util.StringUtils;
import org.jivesoftware.smackx.ping.PingManager;

public class XMPPListener {
    private ConfigurationContext configurationContext;
    private int workersMaxThreads;
    private Map<String, String> connectionFactories;
    private TimeUnit timeUnit;
    private Log log;
    private ExecutorService workerPool;
    private XMPPConnection xmppConnection;
    private EndpointReference eprForService;

    public void init() {
        // Initialize the configuration context
        configurationContext = new ConfigurationContext();

        // Set the maximum number of threads for the worker pool
        workersMaxThreads = WORKERS_MAX_THREADS;

        // Create a map to store connection factories
        connectionFactories = new HashMap<>();

        // Initialize the ping manager
        PingManager pingManager = new PingManager();

        // Set the keep alive time for the worker pool
        timeUnit = TIME_UNIT;

        // Create a log object
        log = LogFactory.getLog(XMPPListener.class);

        // Create an executor service for the worker pool
        workerPool = Executors.newFixedThreadPool(workersMaxThreads);

        // Initialize the XMPP connection
        xmppConnection = new XMPPConnection();
    }

    public EndpointReference getEPRForService() {
        // Get the endpoint reference for the service
        return eprForService;
    }

    public void initializeConnectionFactories() throws Exception {
        // Initialize connection factories for all available services
        for (String serviceName : connectionFactories.keySet()) {
            String factoryName = connectionFactories.get(serviceName);
            ConnectionFactory factory = new ConnectionFactory(factoryName);
            EndpointReference epr = new EndpointReference();
            xmppConnection.addConnectionFactory(epr, factory);
        }
    }

    public void start() {
        // Start the XMPP connection
        try {
            xmppConnection.connect(serverCredentials);
            log.info(""XMPP connection started"");
        } catch (Exception e) {
            log.error(""Error starting XMPP connection"", e);
        }
    }

    public void destroy() {
        // Destroy the XMPP connection
        try {
            xmppConnection.disconnect();
            log.info(""XMPP connection destroyed"");
        } catch (Exception e) {
            log.error(""Error destroying XMPP connection"", e);
        }
    }

    public SessionContext getSessionContext() {
        // Get the session context for the current user
        return null;
    }

    public EndpointReference[] getEPRsForService(String serviceName) {
        // Return all endpoint references for a given service
        return new EndpointReference[0];
    }
}"
155,"// Get string value from the map
String strValue = (String) mMap.get(""key"");

// Get JSONObject from the map
JSONObject jsonObj = (JSONObject) mMap.get(""key"");

// Iterate over the keys in the JSONObject
Iterator<String> itr = jsonObj.keys();
while(itr.hasNext()) {
    String key = itr.next();
    // Get double value from the JSONObject
    double dValue = jsonObj.getDouble(key);
    
    // Get JSONArray from the JSONObject
    JSONArray jsonArr = jsonObj.getJSONArray(key);
    
    // Iterate over the elements in the JSONArray
    for (int i = 0; i < jsonArr.length(); i++) {
        Object obj = jsonArr.get(i);
        if (obj instanceof Float) {
            float fValue = (Float) obj;
            System.out.println(""Float value: "" + fValue);
        } else {
            System.out.println(""Non-float value"");
        }
    }
}

// Get long value from the map
long lValue = mMap.getLong(""key"");

// Get int value from the map
int iValue = mMap.getInt(""key"");

// Check if a key exists in the map
boolean containsKey = mMap.containsKey(""key"");

// Get an object from the map
Object obj = mMap.get(""key"");

// Put a value in the map
mMap.put(""key"", ""value"");

// Write JSON data to a file
JSONObject jsonObj = new JSONObject();
jsonObj.put(""name"", ""John"");
jsonObj.put(""age"", 30);
FileWriter fw = new FileWriter(""file.json"");
fw.write(jsonObj.toString());
fw.close();

// Put all key-value pairs from a map to another map
Map<String, Object> m1 = new HashMap<>();
m1.put(""key1"", ""value1"");
m1.put(""key2"", ""value2"");
Map<String, Object> m2 = new HashMap<>();
m2.putAll(m1);"
156,"import java.io.*;
import javax.sound.sampled.*;
import org.gragravarr.flac.*;

public class PCMProcessor {
    private List<PCMProcessorListener> listeners;
    private SourceDataLine line;
    private String filePath;
    private Thread playerThread;
    private FLACDecoder decoder;
    private AudioFormat fmt;
    private DataLine.Info info;

    public PCMProcessor(String filePath) throws LineUnavailableException {
        this.filePath = filePath;
        listeners = new ArrayList<>();
        decoder = new FLACDecoder();
        try {
            InputStream in = new FileInputStream(filePath);
            fmt = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, 44100, 16, 2, 4, 44100, true);
            info = new DataLine.Info(SourceDataLine.class, fmt, AudioSystem.NOT_SPECIFIED);
            line = (SourceDataLine) AudioSystem.getLine(info);
        } catch (IOException | LineUnavailableException e) {
            throw new LineUnavailableException(""Error initializing audio device: "" + e.getMessage());
        }
    }

    public void play() {
        playerThread = new Thread(() -> {
            byte[] buffer = new byte[1024];
            try (InputStream in = decoder.getBitStream(filePath)) {
                while (!Thread.interrupted()) {
                    int bytesRead = in.read(buffer);
                    if (bytesRead == -1) {
                        break;
                    }
                    line.write(buffer, 0, bytesRead);
                    update();
                }
            } catch (IOException e) {
                System.err.println(""Error reading audio data: "" + e.getMessage());
            } finally {
                stop();
            }
        });
        playerThread.start();
    }

    public void stop() {
        if (playerThread != null && playerThread.isAlive()) {
            playerThread.interrupt();
        }
        try {
            line.drain();
            line.close();
        } catch (LineUnavailableException e) {
            System.err.println(""Error closing audio device: "" + e.getMessage());
        }
    }

    public void update() {
        for (PCMProcessorListener listener : listeners) {
            listener.onUpdate(line);
        }
    }

    public void addListener(PCMProcessorListener listener) {
        listeners.add(listener);
    }

    public void removeListener(PCMProcessorListener listener) {
        listeners.remove(listener);
    }
}"
157,"package com.example;

import java.io.IOException;

public class VarInt {
    private int originalSize;
    private byte[] encodedValue;

    public VarInt(int value) {
        this.originalSize = value;
    }

    public void encode() throws IOException {
        // Encoding logic goes here
        this.encodedValue = new byte[4];
        for (int i = 0; i < 4; i++) {
            this.encodedValue[i] = (byte) ((this.originalSize & 0xff000000) >> (8 * i));
        }
    }

    public int getOriginalSizeInBytes() {
        return this.originalSize;
    }
}"
158,"package com.example;

import java.util.Map;

public class Serializer {
    private Map<Class<? extends Message>, String> names;
    private int size;
    private Logger log;
    private boolean parseLazy;
    private int HEADER_LENGTH = 24;
    private byte[] checksum;
    private byte[] header;
    private NetworkParameters params;
    private int COMMAND_LEN = 12;
    private String command;
    private boolean parseRetain = false;

    public Serializer(Map<Class<? extends Message>, String> names, int size, Logger log, boolean parseLazy) {
        this.names = names;
        this.size = size;
        this.log = log;
        this.parseLazy = parseLazy;
    }

    public void seekPastMagicBytes() {
        // TODO: Implement method
    }

    public void serialize() {
        // TODO: Implement method
    }

    public void deserialize(byte[] data) {
        // TODO: Implement method
    }

    public Message makeMessage(String command, NetworkParameters params) {
        // TODO: Implement method
    }

    public Message deserializePayload(byte[] payload) {
        // TODO: Implement method
    }

    public boolean isParseLazyMode() {
        return parseLazy;
    }

    public BitcoinPacketHeader deserializeHeader(byte[] header) {
        // TODO: Implement method
    }
}"
159,"import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.Arrays;

public class FeedRunStatus {
    private long runId;
    private BigDecimal feedId;
    private Timestamp startDate;
    private Timestamp endDate;
    private String resultCode;
    private String resultMessage;
    private BigDecimal fileCount;
    private BigDecimal downloadSize;
    private BigDecimal feedConfigId;
    private Timestamp maxReceiptDate;
    private byte[] errors;
    private String configInfo;

    public FeedRunStatus() {}

    public long getRunId() { return runId; }
    public void setRunId(long runId) { this.runId = runId; }

    public BigDecimal getFeedId() { return feedId; }
    public void setFeedId(BigDecimal feedId) { this.feedId = feedId; }

    public Timestamp getStartDate() { return startDate; }
    public void setStartDate(Timestamp startDate) { this.startDate = startDate; }

    public Timestamp getEndDate() { return endDate; }
    public void setEndDate(Timestamp endDate) { this.endDate = endDate; }

    public String getResultCode() { return resultCode; }
    public void setResultCode(String resultCode) { this.resultCode = resultCode; }

    public String getResultMessage() { return resultMessage; }
    public void setResultMessage(String resultMessage) { this.resultMessage = resultMessage; }

    public BigDecimal getFileCount() { return fileCount; }
    public void setFileCount(BigDecimal fileCount) { this.fileCount = fileCount; }

    public BigDecimal getDownloadSize() { return downloadSize; }
    public void setDownloadSize(BigDecimal downloadSize) { this.downloadSize = downloadSize; }

    public BigDecimal getFeedConfigId() { return feedConfigId; }
    public void setFeedConfigId(BigDecimal feedConfigId) { this.feedConfigId = feedConfigId; }

    public Timestamp getMaxReceiptDate() { return maxReceiptDate; }
    public void setMaxReceiptDate(Timestamp maxReceiptDate) { this.maxReceiptDate = maxReceiptDate; }

    public byte[] getErrors() { return errors; }
    public void setErrors(byte[] errors) { this.errors = errors; }

    public String getConfigInfo() { return configInfo; }
    public void setConfigInfo(String configInfo) { this.configInfo = configInfo; }
}"
16,"import java.util.*;
import javax.tools.*;
import org.apache.maven.plugins.annotations.*;

@Mojo(name = ""validate-sources"", defaultPhase = LifecyclePhase.COMPILE)
public class ValidateSourcesMojo extends AbstractMojo {
    @Parameter(defaultValue = ""${project.build.sourceDirectory}"")
    private File sources;

    @Parameter(defaultValue = ""${project.build.outputDirectory}"")
    private File outputDirectory;

    public void execute() throws MojoExecutionException, MojoFailureException {
        List<ExtensionInfo> allExtensions = new ArrayList<>();

        // Create a ClassFileLoader to load the classes from the sources directory
        ClassFileLoader loader = new ClassFileLoader(sources);

        // Create an ErrorQueue to collect any errors that occur during validation
        ErrorQueue eq = new ErrorQueue();

        // Get the list of Java files in the outputDirectory
        Collection<JavaFileObject> outputFiles = outputDirectory.listFiles();

        // For each file in the outputDirectory, validate its passes and add them to the allExtensions collection
        for (JavaFileObject file : outputFiles) {
            ExtensionInfo extensionInfo = new ExtensionInfo(file);
            if (extensionInfo.isValid()) {
                allExtensions.add(extensionInfo);
            }
        }

        // If any errors occurred during validation, throw an exception
        if (!eq.isEmpty()) {
            throw new MojoExecutionException(""Validation failed"", eq);
        }
    }
}"
160,"public class GeneralMotorCon {
  private static final String TAG = ""GeneralMotorCon"";
  private int spin90Time;
  private int batLvl;
  private long threadTimer;
  private int spinSpeed;
  private CommandManager cmd;
  private int hoverTime;
  private int speed;
  private int spin90Speed;
  private ARDrone drone;
  private int spinTime;

  public GeneralMotorCon() {
    this.spin90Time = 5000; // default value for spin90Time
    this.batLvl = 100; // default value for batLvl
    this.threadTimer = 1000; // default value for threadTimer
    this.spinSpeed = 250; // default value for spinSpeed
    this.cmd = new CommandManager();
    this.hoverTime = 3000; // default value for hoverTime
    this.speed = 150; // default value for speed
    this.spin90Speed = 250; // default value for spin90Speed
    this.drone = new ARDrone();
    this.spinTime = 500; // default value for spinTime
  }

  public void spin90Right() {
    this.cmd.addCommand(new Spin90Right());
  }

  public void spinRight() {
    this.cmd.addCommand(new SpinRight());
  }

  public void takeoff() {
    this.cmd.addCommand(new TakeOff());
  }

  public void forward() {
    this.cmd.addCommand(new Forward());
  }

  public void spinLeft() {
    this.cmd.addCommand(new SpinLeft());
  }

  public void right() {
    this.cmd.addCommand(new Right());
  }

  public void lowerAltitude() {
    this.cmd.addCommand(new LowerAltitude());
  }

  public void landing() {
    this.cmd.addCommand(new Landing());
  }

  public void setDrone(ARDrone drone) {
    this.drone = drone;
  }

  public void left() {
    this.cmd.addCommand(new Left());
  }

  public void backward() {
    this.cmd.addCommand(new Backward());
  }

  public static GeneralMotorCon getInstance() {
    return new GeneralMotorCon();
  }

  public void setBatLvl(int batLvl) {
    this.batLvl = batLvl;
  }

  public int getBatLvl() {
    return this.batLvl;
  }

  public void waitFor(int milliseconds) {
    try {
      Thread.sleep(milliseconds);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void onStop() {
    this.cmd.addCommand(new Stop());
  }

  public void raiseAltitude() {
    this.cmd.addCommand(new RaiseAltitude());
  }
}"
161,"package com.example;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

public class ApprovedSiteService {
    private final Supplier<Map<Long, Integer>> byClientIdCache;
    private final ClientDetailsEntityService clientService;
    private final Supplier<Map<String, Integer>> summaryCache;

    public ApprovedSiteService(Supplier<Map<Long, Integer>> byClientIdCache, ClientDetailsEntityService clientService, Supplier<Map<String, Integer>> summaryCache) {
        this.byClientIdCache = byClientIdCache;
        this.clientService = clientService;
        this.summaryCache = summaryCache;
    }

    public Integer getCountForClientId(Long clientId) {
        Map<String, Integer> summaryStats = getSummaryStats();
        return summaryStats.getOrDefault(clientId.toString(), 0);
    }

    public Map<Long, Integer> computeByClientId() {
        // Compute the count of approved sites for each client id
        Map<Long, Integer> byClientId = new HashMap<>();
        for (Map.Entry<String, Integer> entry : getSummaryStats().entrySet()) {
            Long clientId = Long.valueOf(entry.getKey());
            Integer count = entry.getValue();
            byClientId.put(clientId, count);
        }
        return byClientId;
    }

    public void resetCache() {
        summaryCache.get().clear();
        byClientIdCache.get().clear();
    }

    private Map<String, Integer> getSummaryStats() {
        if (summaryCache.get().isEmpty()) {
            computeSummaryStats();
        }
        return summaryCache.get();
    }

    private Map<Long, Integer> getByClientId() {
        if (byClientIdCache.get().isEmpty()) {
            computeByClientId();
        }
        return byClientIdCache.get();
    }

    public void computeSummaryStats() {
        // Compute the summary stats for all approved sites
        Map<String, Integer> summaryStats = new HashMap<>();
        for (Map.Entry<Long, String> entry : clientService.getAllClientIds().entrySet()) {
            Long clientId = entry.getKey();
            String name = entry.getValue();
            summaryStats.put(clientId.toString(), 0);
        }
        // Update the cache with the new summary stats
        summaryCache.get().putAll(summaryStats);
    }

    public Supplier<Map<Long, Integer>> createByClientIdCache() {
        return () -> new HashMap<>();
    }

    public Supplier<Map<String, Integer>> createSummaryCache() {
        return () -> new HashMap<>();
    }
}"
162,"import java.util.*;

public class XPathContext {
    private String open;
    private String expression;
    private String pi;
    private String text;
    private short type;
    private String empty;
    private Map<String, String> uri2Prefix;
    private Map<QName, Level> attributes;
    private Deque<Level> path;
    private String sep;
    private String comment;
    private String xpath;
    private String attr;
    private List<Level> children;
    private QName name;

    public XPathContext() {
        this.open = null;
        this.expression = null;
        this.pi = null;
        this.text = null;
        this.type = (short) 0;
        this.empty = null;
        this.uri2Prefix = new HashMap<>();
        this.attributes = new HashMap<>();
        this.path = new ArrayDeque<>();
        this.sep = null;
        this.comment = null;
        this.xpath = null;
        this.attr = null;
        this.children = new ArrayList<>();
        this.name = null;
    }

    public void navigateToParent() {
        if (this.path.isEmpty()) {
            return;
        }
        Level parentLevel = this.path.pop();
        this.type = parentLevel.getType();
        this.name = parentLevel.getName();
        this.xpath = null;
    }

    public String getName() {
        if (this.name == null) {
            return """";
        } else {
            return this.name.toString();
        }
    }

    public QName getName() {
        return this.name;
    }

    public QName getName() {
        return this.name;
    }

    public void appendChildren(List<Level> children) {
        this.children.addAll(children);
    }

    public Map<String, String> invert() {
        Map<String, String> invertedMap = new HashMap<>();
        for (QName name : this.attributes.keySet()) {
            invertedMap.put(name.toString(), this.attributes.get(name).toString());
        }
        return invertedMap;
    }

    public void addAttribute(String name, String value) {
        this.attributes.put(new QName(name), value);
    }

    public short getType() {
        return this.type;
    }

    public short getType() {
        return this.type;
    }

    public int add1OrIncrement() {
        return ++this.children.size();
    }

    public String getXPath() {
        if (this.xpath == null) {
            return """";
        } else {
            return this.xpath;
        }
    }

    public void navigateToChild(int index) {
        Level childLevel = this.children.get(index);
        this.type = childLevel.getType();
        this.name = childLevel.getName();
        this.xpath = null;
    }

    public void setChildren(List<Level> children) {
        this.children = children;
    }

    public void navigateToAttribute() {
        if (this.path.isEmpty()) {
            return;
        }
        Level parentLevel = this.path.pop();
        this.type = parentLevel.getType();
        this.name = parentLevel.getName();
        this.xpath = null;
    }
}"
163,"public class HashTable {
    private final int mKeyCount;
    private final int BUCKET_SIZE_BYTES;
    private final ByteBuffer mBuf;
    private final int INDEX_HASHER_SEED;
    private final int FINGERPRINT_HASHER_SEED;
    private final HashFunction FINGERPRINT_HASHER;
    private final HashFunction INDEX_HASHER;
    private final ByteBuffer mHashTableBuf;
    private final int MAX_PROBES;
    private final int mNumBuckets;

    public HashTable(int keyCount, int BUCKET_SIZE_BYTES, ByteBuffer buf, int INDEX_HASHER_SEED, int FINGERPRINT_HASHER_SEED, HashFunction FINGERPRINT_HASHER, HashFunction INDEX_HASHER, ByteBuffer hashTableBuf, int MAX_PROBES, int numBuckets) {
        this.mKeyCount = keyCount;
        this.BUCKET_SIZE_BYTES = BUCKET_SIZE_BYTES;
        this.mBuf = buf;
        this.INDEX_HASHER_SEED = INDEX_HASHER_SEED;
        this.FINGERPRINT_HASHER_SEED = FINGERPRINT_HASHER_SEED;
        this.FINGERPRINT_HASHER = FINGERPRINT_HASHER;
        this.INDEX_HASHER = INDEX_HASHER;
        this.mHashTableBuf = hashTableBuf;
        this.MAX_PROBES = MAX_PROBES;
        this.mNumBuckets = numBuckets;
    }

    public int hashKey(byte[] key) {
        // Calculate the fingerprint of the key using the fingerprint hasher
        byte[] fingerprint = FINGERPRINT_HASHER.hash(key, FINGERPRINT_HASHER_SEED);

        // Use the index hasher to calculate the bucket index for the fingerprint
        int bucketIndex = INDEX_HASHER.hash(fingerprint, INDEX_HASHER_SEED) % mNumBuckets;

        return bucketIndex;
    }

    public boolean put(byte[] key) {
        // Calculate the fingerprint of the key using the fingerprint hasher
        byte[] fingerprint = FINGERPRINT_HASHER.hash(key, FINGERPRINT_HASHER_SEED);

        // Use the index hasher to calculate the bucket index for the fingerprint
        int bucketIndex = INDEX_HASHER.hash(fingerprint, INDEX_HASHER_SEED) % mNumBuckets;

        // Check if the key is already in the hash table
        if (get(bucketIndex, fingerprint)) {
            return false;
        }

        // Put the key-value pair into the hash table
        put(bucketIndex, fingerprint);

        return true;
    }

    public byte[] get(int bucketIndex) {
        // Get the next available key from the specified bucket index
        byte[] key = null;

        // Iterate over the keys in the hash table until we find one that matches the specified bucket index
        for (int i = 0; i < mNumBuckets; i++) {
            byte[] fingerprint = FINGERPRINT_HASHER.hash(key, FINGERPRINT_HASHER_SEED);
            if (INDEX_HASHER.hash(fingerprint, INDEX_HASHER_SEED) % mNumBuckets == bucketIndex) {
                key = getBytes(i);
                break;
            }
        }

        return key;
    }

    public byte[] getBytes(int index) {
        // Get the byte array for the specified index in the hash table
        return mHashTableBuf.get(index * BUCKET_SIZE_BYTES, BUCKET_SIZE_BYTES);
    }
}"
164,"package net.sf.marineapi.nmea.parser;

import org.junit.Test;

public class SentenceFactoryTest {
    private SentenceFactory factory;

    @Before
    public void setUp() {
        factory = SentenceFactory.getInstance();
    }

    @Test
    public void testRegisterInvalidParser() {
        // Arrange
        String sentenceId = ""INVALID"";
        Parser parser = new MyCustomParser();

        // Act
        boolean result = factory.registerParser(sentenceId, parser);

        // Assert
        assertFalse(result);
    }

    @Test
    public void testUnregisterParser() {
        // Arrange
        String sentenceId = ""TEST"";
        Parser parser = new MyCustomParser();
        factory.registerParser(sentenceId, parser);

        // Act
        boolean result = factory.unregisterParser(sentenceId);

        // Assert
        assertTrue(result);
    }

    @Test
    public void testListParsers() {
        // Arrange
        String sentenceId1 = ""TEST"";
        Parser parser1 = new MyCustomParser();
        factory.registerParser(sentenceId1, parser1);

        String sentenceId2 = ""TEST2"";
        Parser parser2 = new MyCustomParser();
        factory.registerParser(sentenceId2, parser2);

        // Act
        List<Parser> parsers = factory.listParsers();

        // Assert
        assertEquals(2, parsers.size());
        assertTrue(parsers.contains(parser1));
        assertTrue(parsers.contains(parser2));
    }

    @Test
    public void testCreateParserWithNull() {
        // Arrange
        String sentenceId = null;

        // Act
        Parser parser = factory.createParser(sentenceId);

        // Assert
        assertNull(parser);
    }

    @Test
    public void testCreateEmptyParserWithSentenceIdStr() {
        // Arrange
        String sentenceId = """";

        // Act
        Parser parser = factory.createParser(sentenceId);

        // Assert
        assertNull(parser);
    }

    @Test
    public void testCreateEmptyCustomParser() {
        // Arrange
        String sentenceId = ""TEST"";
        Parser parser = new MyCustomParser();

        // Act
        boolean result = factory.createParser(sentenceId, parser);

        // Assert
        assertFalse(result);
    }

    @Test
    public void testCreateParserWithUnregistered() {
        // Arrange
        String sentenceId = ""TEST"";

        // Act
        Parser parser = factory.createParser(sentenceId);

        // Assert
        assertNull(parser);
    }

    @Test
    public void testCreateEmptyParserWithSentenceId() {
        // Arrange
        String sentenceId = """";

        // Act
        Parser parser = factory.createParser(sentenceId);

        // Assert
        assertNull(parser);
    }

    @Test
    public void testCreateCustomParser() {
        // Arrange
        String sentenceId = ""TEST"";
        Parser parser = new MyCustomParser();
        factory.registerParser(sentenceId, parser);

        // Act
        boolean result = factory.createParser(sentenceId, parser);

        // Assert
        assertTrue(result);
    }

    @Test
    public void testRegisterParserWithAlternativeBeginChar() {
        // Arrange
        String sentenceId = ""TEST"";
        Parser parser = new MyCustomParser();
        factory.registerParser(sentenceId, parser);

        // Act
        boolean result = factory.createParser(""$TEST"");

        // Assert
        assertTrue(result);
    }

    @Test
    public void testSupportedTypesRegistered() {
        // Arrange
        List<String> supportedTypes = new ArrayList<>();
        supportedTypes.add(""TEST"");

        // Act
        boolean result = factory.supportedTypes(supportedTypes);

        // Assert
        assertTrue(result);
    }

    @Test
    public void testCreateParser() {
        // Arrange
        String sentenceId = ""TEST"";
        Parser parser = new MyCustomParser();
        factory.registerParser(sentenceId, parser);

        // Act
        Parser result = factory.createParser(sentenceId);

        // Assert
        assertEquals(parser, result);
    }

    @Test
    public void testCreateParserWithRandom() {
        // Arrange
        String sentenceId = ""TEST"";
        Parser parser = new MyCustomParser();
        factory.registerParser(sentenceId, parser);

        // Act
        Parser result = factory.createParser(""$RANDOM"");

        // Assert
        assertEquals(parser, result);
    }
}

class MyCustomParser implements Parser {
    @Override
    public Sentence parse(String sentence) {
        return null;
    }
}"
165,"import java.util.regex.Pattern;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.client.utils.URLEncodedUtils;

public class ModRemoteIp {
    private static final String DEFAULT_PROXIES_HEADER = ""x-forwarded-by"";
    private static final Pattern COMMA_SEPARATED_VALUES_PATTERN = Pattern.compile(""\\s*,\\s*"");
    private static final ESLogger log = LogManager.getLogger(ModRemoteIp.class);

    // http header that holds the list of trusted proxies
    private String proxiesHeader;

    // pattern for internal proxies
    private Pattern internalProxies;

    // pattern for trusted proxies
    private Pattern trustedProxies;

    public ModRemoteIp() {
        this.proxiesHeader = DEFAULT_PROXIES_HEADER;
        this.internalProxies = null;
        this.trustedProxies = null;
    }

    // setter for proxiesHeader
    public void setProxiesHeader(String proxiesHeader) {
        this.proxiesHeader = proxiesHeader;
    }

    // getter for proxiesHeader
    public String getProxiesHeader() {
        return proxiesHeader;
    }

    // setter for internalProxies
    public void setInternalProxies(String[] internalProxies) {
        this.internalProxies = Pattern.compile(""\\s*,\\s*"");
    }

    // getter for internalProxies
    public String getInternalProxies() {
        return internalProxies;
    }

    // setter for trustedProxies
    public void setTrustedProxies(String[] trustedProxies) {
        this.trustedProxies = Pattern.compile(""\\s*,\\s*"");
    }

    // getter for trustedProxies
    public String getTrustedProxies() {
        return trustedProxies;
    }

    // method to detect the remote ip address
    public String detect(URIBuilder uri) {
        // extract the proxies header from the request
        String proxiesHeader = uri.getHeaders().get(this.proxiesHeader);

        // if the proxies header is not present, return the request's remote ip address
        if (proxiesHeader == null) {
            return uri.getRemoteIpAddress();
        }

        // split the list of trusted proxies from the proxies header
        String[] trustedProxies = URLEncodedUtils.split(proxiesHeader, COMMA_SEPARATED_VALUES_PATTERN);

        // if there are no trusted proxies, return the request's remote ip address
        if (trustedProxies == null || trustedProxies.length == 0) {
            return uri.getRemoteIpAddress();
        }

        // loop through the list of trusted proxies and check if any of them match the request's remote ip address
        for (String trustedProxy : trustedProxies) {
            if (trustedProxy.equals(uri.getRemoteIpAddress())) {
                return trustedProxy;
            }
        }

        // if none of the trusted proxies match, return the request's remote ip address
        return uri.getRemoteIpAddress();
    }
}"
166,"import java.util.*;
import javax.xml.namespace.QName;

class XPathContext {
    private String open;
    private String expression;
    private String pi;
    private String text;
    private short type;
    private String empty;
    private Map<String, String> uri2Prefix;
    private Map<QName, Level> attributes;
    private Deque<Level> path;
    private String sep;
    private String comment;
    private String xpath;
    private String attr;
    private List<Level> children;
    private QName name;

    public void stringifyXPath() {
        // TODO: implement the logic to generate the XPath expression for the current node
    }
}

class Level {
    private XPathContext context;
    private int index;
    private String xpath;

    public Level(XPathContext context, int index) {
        this.context = context;
        this.index = index;
    }

    public void setChildren(List<Level> children) {
        // TODO: implement the logic to set the children of the current level
    }

    public String getName() {
        return name;
    }

    public void addAttribute(QName name, short type) {
        // TODO: implement the logic to add an attribute to the current level
    }

    public void clone(Level other) {
        // TODO: implement the logic to clone the current level from another level
    }
}"
167,"public class Run {
    private long serialVersionUID;
    private boolean isSystemDerived;
    private boolean isActive;
    private BigDecimal predecessorId;
    private String srcFileName;
    private BigDecimal successorId;
    private BigDecimal feedId;
    private String checksum;
    private String transmissionDatasetId;
    private String comments;
    private String inactivationReasonType;
    private boolean isFormatValid;
    private long dataUnitId;
    private Timestamp receiptDate;
    private String srcUniqueFileName;
    private Timestamp createdDate;
    private Long dataSetId;
    private BigDecimal fileSize;
    private String destFileName;
    private String loadedInCats;
    private String checksumType;
    private Timestamp modifiedDate;
    private BigDecimal runId;
    private boolean isPrepopulated;
    private boolean isBulk;
    private boolean isUpdate;
    private String receiptDateType;
    private String status;

    public void setIsSystemDerived(boolean isSystemDerived) {
        this.isSystemDerived = isSystemDerived;
    }

    public void setIsPrepopulated(boolean isPrepopulated) {
        this.isPrepopulated = isPrepopulated;
    }

    public String getStatus() {
        return status;
    }

    public boolean getIsUpdate() {
        return isUpdate;
    }

    public long getDataUnitId() {
        return dataUnitId;
    }

    public BigDecimal getFileSize() {
        return fileSize;
    }

    public void setInactivationReasonType(String inactivationReasonType) {
        this.inactivationReasonType = inactivationReasonType;
    }

    public void setDataUnitId(long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }

    public String getComments() {
        return comments;
    }

    public Timestamp getCreatedDate() {
        return createdDate;
    }

    public void setFileSize(BigDecimal fileSize) {
        this.fileSize = fileSize;
    }

    public BigDecimal getPredecessorId() {
        return predecessorId;
    }

    public void setIsUpdate(boolean isUpdate) {
        this.isUpdate = isUpdate;
    }

    public String getReceiptDateType() {
        return receiptDateType;
    }

    public BigDecimal getFeedId() {
        return feedId;
    }

    public void setReceiptDate(Timestamp receiptDate) {
        this.receiptDate = receiptDate;
    }

    public Timestamp getModifiedDate() {
        return modifiedDate;
    }

    public void setSuccessorId(BigDecimal successorId) {
        this.successorId = successorId;
    }

    public void setDestFileName(String destFileName) {
        this.destFileName = destFileName;
    }

    public String getIsFormatValid() {
        return isFormatValid;
    }

    public void setIsFormatValid(boolean isFormatValid) {
        this.isFormatValid = isFormatValid;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }

    public String getIsBulk() {
        return isBulk;
    }

    public void setIsBulk(String isBulk) {
        this.isBulk = isBulk;
    }

    public String getIsActive() {
        return isActive;
    }

    public void setIsActive(boolean isActive) {
        this.isActive = isActive;
    }

    public void setChecksumType(String checksumType) {
        this.checksumType = checksumType;
    }

    public String getInactivationReasonType() {
        return inactivationReasonType;
    }

    public String getSrcUniqueFileName() {
        return srcUniqueFileName;
    }

    public void setSrcUniqueFileName(String srcUniqueFileName) {
        this.srcUniqueFileName = srcUniqueFileName;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setReceiptDateType(String receiptDateType) {
        this.receiptDateType = receiptDateType;
    }

    public BigDecimal getRunId() {
        return runId;
    }

    public void setRunId(BigDecimal runId) {
        this.runId = runId;
    }

    public String getIsPrepopulated() {
        return isPrepopulated;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public String getChecksumType() {
        return checksumType;
    }

    public String getSrcFileName() {
        return srcFileName;
    }

    public String getChecksum() {
        return checksum;
    }

    public void setIsFormatValid(String isFormatValid) {
        this.isFormatValid = isFormatValid;
    }

    public String getDestFileName() {
        return destFileName;
    }

    public void setLoadedInCats(String loadedInCats) {
        this.loadedInCats = loadedInCats;
    }

    public String getIsBulk() {
        return isBulk;
    }

    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }

    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }

    public String getLoadedInCats() {
        return loadedInCats;
    }

    public void setModifiedDate(Timestamp modifiedDate) {
        this.modifiedDate = modifiedDate;
    }

    public void setSuccessorId(BigDecimal successorId) {
        this.successorId = successorId;
    }

    public String getIsActive() {
        return isActive;
    }

    public Timestamp getReceiptDate() {
        return receiptDate;
    }

    public void setCreatedDate(Timestamp createdDate) {
        this.createdDate = createdDate;
    }
}"
168,"// This code is a Java implementation of the ""dot at the end of the production"" task.
  
public class DotAtEndOfProduction {
    private final String production;
    private final int coreHashCache;
    private final Symbol symbolAfterDot;
    private final int dotPos;
  
    public DotAtEndOfProduction(String production) {
        this.production = production;
        this.coreHashCache = calculateCoreHash();
        this.symbolAfterDot = getSymbolAfterDot();
        this.dotPos = getDotPos();
    }
  
    private int calculateCoreHash() {
        // Calculate the core hash code of the production.
        return 0;
    }
  
    private Symbol getSymbolAfterDot() {
        // Get the symbol after the dot in the production.
        return null;
    }
  
    private int getDotPos() {
        // Get the position of the dot in the production.
        return 0;
    }
  
    public boolean isDotAtEndOfProduction() {
        return this.symbolAfterDot == null || this.dotPos != this.production.length();
    }
  
    @Override
    public int hashCode() {
        // Calculate the hash code of the production.
        return 0;
    }
  
    @Override
    public boolean equals(Object other) {
        if (other == null || !(other instanceof DotAtEndOfProduction)) {
            return false;
        }
  
        DotAtEndOfProduction that = (DotAtEndOfProduction) other;
        return this.production.equals(that.production);
    }
  
    @Override
    public String toString() {
        // Return the string representation of the production.
        return """";
    }
}
  // This code is a Java implementation of the ""dot at the end of the production"" task.
  
public class DotAtEndOfProduction {
    private final String production;
    private final int coreHashCache;
    private final Symbol symbolAfterDot;
    private final int dotPos;
  
    public DotAtEndOfProduction(String production) {
        this.production = production;
        this.coreHashCache = calculateCoreHash();
        this.symbolAfterDot = getSymbolAfterDot();
        this.dotPos = getDotPos();
    }
  
    private int calculateCoreHash() {
        // Calculate the core hash code of the production.
        return 0;
    }
  
    private Symbol getSymbolAfterDot() {
        // Get the symbol after the dot in the production.
        return null;
    }
  
    private int getDotPos() {
        // Get the position of the dot in the production.
        return 0;
    }
  
    public boolean isDotAtEndOfProduction() {
        return this.symbolAfterDot == null || this.dotPos != this.production.length();
    }
  
    @Override
    public int hashCode() {
        // Calculate the hash code of the production.
        return 0;
    }
  
    @Override
    public boolean equals(Object other) {
        if (other == null || !(other instanceof DotAtEndOfProduction)) {
            return false;
        }
  
        DotAtEndOfProduction that = (DotAtEndOfProduction) other;
        return this.production.equals(that.production);
    }
  
    @Override
    public String toString() {
        // Return the string representation of the production.
        return """";
    }
}"
169,"import org.junit.Assert;
import org.junit.Test;

public class FileOptionsTest {
    @Test
    public void testDefaultBuilder() throws Exception {
        // Build a default FileOptions object using the builder
        FileOptions options = new FileOptions.Builder().build();
        
        // Test that all fields are set to their default values
        Assert.assertEquals(options.getFieldA(), """");
        Assert.assertEquals(options.getFieldB(), 0);
        Assert.assertEquals(options.getFieldC(), false);
        
        // Test the equals method by comparing the built object to itself
        Assert.assertTrue(options.equals(options));
    }
}"
17,"// Get the GPS status
boolean isGPSEnabled = context.getSystemService(Context.LOCATION_SERVICE).getBoolean(LocationManager.GPS_ENABLED, false);

// Enable/disable GPS
if (isGPSEnabled) {
    // Disable GPS
    LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
    locationManager.setProviderEnabled(LocationManager.GPS_PROVIDER, false);
} else {
    // Enable GPS
    LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
    locationManager.setProviderEnabled(LocationManager.GPS_PROVIDER, true);
}"
170,"import java.io.Serializable;
import java.util.Map;
import java.util.HashMap;

public class Permission implements Serializable {
    private static final long serialVersionUID = 1L;

    public static final int NOT_SHARED = 0;
    public static final int FRIENDS = 1;
    public static final int ALL = 2;
    public static final int FRIEND_FRIEND = 3;
    public static final int PUBLIC = 4;
    public static final int FRIEND_PUBLIC = 5;

    private String m_key;
    private int m_permissionIndex;

    public Permission(String key, int permissionIndex) {
        this.m_key = key;
        this.m_permissionIndex = permissionIndex;
    }

    public static Map<Integer, Permission> getPermissions() {
        return PERMISSIONS;
    }

    public String getKey() {
        return m_key;
    }

    public int getID() {
        return m_permissionIndex;
    }

    @Override
    public String toString() {
        return ""Permission{"" +
                ""m_key='"" + m_key + '\'' +
                "", m_permissionIndex="" + m_permissionIndex +
                '}';
    }

    private static final Map<Integer, Permission> PERMISSIONS = new HashMap<>();

    static {
        PERMISSIONS.put(NOT_SHARED, new Permission(""NOT_SHARED"", NOT_SHARED));
        PERMISSIONS.put(FRIENDS, new Permission(""FRIENDS"", FRIENDS));
        PERMISSIONS.put(ALL, new Permission(""ALL"", ALL));
        PERMISSIONS.put(FRIEND_FRIEND, new Permission(""FRIEND_FRIEND"", FRIEND_FRIEND));
        PERMISSIONS.put(PUBLIC, new Permission(""PUBLIC"", PUBLIC));
        PERMISSIONS.put(FRIEND_PUBLIC, new Permission(""FRIEND_PUBLIC"", FRIEND_PUBLIC));
    }
}"
171,"import android.content.Context;
import android.net.Uri;
import java.util.List;

public class DuplicateProvider<T> {
    private Context context;
    private List<T> items;
    private DuplicateProviderListener<T, DuplicateProvider<T>> listener;

    public void setListener(DuplicateProviderListener<T, DuplicateProvider<T>> listener) {
        this.listener = listener;
    }

    public String[] getReadPermissions() {
        return new String[]{};
    }

    public String getCursorSelection() {
        return """";
    }

    public String[] getCursorProjection() {
        return new String[]{};
    }

    public boolean isCancelled() {
        return false;
    }

    public void deletePairs(Uri uri) {}

    public Uri getContentUri() {
        return null;
    }

    public List<T> getItems() {
        return items;
    }

    public String empty() {
        return """";
    }

    public void fetchItems() {}

    public boolean deleteItem(T item) {
        return false;
    }

    public T createItem() {
        return null;
    }

    public void onPreExecute() {}

    public void populateItem(T item, String[] fields) {}

    public void onPostExecute() {}

    public boolean deleteItems(List<T> items) {
        return false;
    }
}"
172,"import com.google.gson.Gson;
import org.slf4j.Logger;

public class StringTranslator {
    private Gson gson;
    private Logger logger;

    public StringTranslator(Gson gson, Logger logger) {
        this.gson = gson;
        this.logger = logger;
    }

    public String translateToStringArray(Set<String> input) {
        if (input == null || input.isEmpty()) {
            return null;
        } else {
            List<String> output = new ArrayList<>();
            for (String str : input) {
                output.add(str);
            }
            return gson.toJson(output);
        }
    }

    public String translateToJWEAlgorithmList(Set<EncryptionMethod> input) {
        if (input == null || input.isEmpty()) {
            return null;
        } else {
            List<JWEAlgorithm> output = new ArrayList<>();
            for (EncryptionMethod method : input) {
                output.add(method.getAsJweAlgorithm());
            }
            return gson.toJson(output);
        }
    }

    public String translateToJWSAlgorithmList(Set<JWSAlgorithm> input) {
        if (input == null || input.isEmpty()) {
            return null;
        } else {
            List<String> output = new ArrayList<>();
            for (JWSAlgorithm algo : input) {
                output.add(algo.getName());
            }
            return gson.toJson(output);
        }
    }

    public String translateToLong(Date date) {
        if (date == null) {
            return null;
        } else {
            return Long.toString(date.getTime());
        }
    }

    public String translateToBoolean(boolean bool) {
        return Boolean.toString(bool);
    }

    public String translateToJWSAlgorithm(String algoName) {
        if (algoName == null || algoName.isEmpty()) {
            return null;
        } else {
            JWSAlgorithm algo = JWSAlgorithm.forName(algoName);
            return gson.toJson(algo);
        }
    }

    public String translateToJWEAlgorithm(String algoName) {
        if (algoName == null || algoName.isEmpty()) {
            return null;
        } else {
            JWEAlgorithm algo = JWEAlgorithm.forName(algoName);
            return gson.toJson(algo);
        }
    }
}"
173,"package net.sf.marineapi.nmea.parser;

import java.util.Arrays;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class VHWParserTest {
    private VHWParser vhw;

    @Before
    public void setUp() throws Exception {
        vhw = new VHWParser(""$VHW,103.6,T,45.2,M*7A"");
    }

    @Test
    public void testConstructorString() {
        Assert.assertEquals(""$VHW,103.6,T,45.2,M*7A"", vhw.getSentence());
    }

    @Test
    public void testGetHeadingTrue() {
        Assert.assertEquals(true, vhw.isTrueHeading());
    }

    @Test
    public void testGetHeadingMagnetic() {
        Assert.assertEquals(false, vhw.isMagneticHeading());
    }

    @Test
    public void testGetSpeedKilometres() {
        Assert.assertEquals(103.6f, vhw.getSpeedKilometres(), 0.001);
    }

    @Test
    public void testGetSpeedKnots() {
        Assert.assertEquals(45.2f, vhw.getSpeedKnots(), 0.001);
    }

    @Test
    public void testSetHeadingTrue() {
        VHWParser vhw2 = new VHWParser(""$VHW,,T,45.2,M*7A"");
        Assert.assertEquals(true, vhw2.isTrueHeading());
    }

    @Test
    public void testSetHeadingMagnetic() {
        VHWParser vhw2 = new VHWParser(""$VHW,,T,45.2,M*7A"");
        Assert.assertEquals(false, vhw2.isMagneticHeading());
    }

    @Test
    public void testSetSpeedKilometres() {
        VHWParser vhw2 = new VHWParser(""$VHW,103.6,,M*7A"");
        Assert.assertEquals(103.6f, vhw2.getSpeedKilometres(), 0.001);
    }

    @Test
    public void testSetSpeedKnots() {
        VHWParser vhw2 = new VHWParser(""$VHW,103.6,,M*7A"");
        Assert.assertEquals(45.2f, vhw2.getSpeedKnots(), 0.001);
    }
}"
174,"package com.example;

import java.nio.ByteBuffer;
import java.util.List;

public class RPCMessageValidator {
    public void validateMessage(int mId) throws InvalidMessageException {
        if (mId < 0 || mId > 100) {
            throw new InvalidMessageException(""Invalid message ID: "" + mId);
        }
    }

    public ByteBuffer encode() {
        // TODO: Implement encoding logic here
        return null;
    }

    public static class Type {
        private int id;
        private String name;

        public Type(int id, String name) {
            this.id = id;
            this.name = name;
        }

        public int getId() {
            return id;
        }

        public String getName() {
            return name;
        }
    }

    public static class DataBuffer {
        private byte[] data;

        public DataBuffer(byte[] data) {
            this.data = data;
        }

        public int getPayloadDataBuffer() {
            // TODO: Implement logic to extract payload data buffer from the received message
            return 0;
        }
    }

    public static class RPCMessage {
        private Type type;
        private DataBuffer payloadDataBuffer;

        public RPCMessage(Type type, DataBuffer payloadDataBuffer) {
            this.type = type;
            this.payloadDataBuffer = payloadDataBuffer;
        }

        public boolean hasPayload() {
            return payloadDataBuffer != null && payloadDataBuffer.data.length > 0;
        }

        public Type getType() {
            return type;
        }

        public DataBuffer getPayloadDataBuffer() {
            return payloadDataBuffer;
        }
    }

    public static class InvalidMessageException extends Exception {
        public InvalidMessageException(String message) {
            super(message);
        }
    }
}"
175,"import java.util.Scanner;

public class MyScanner {
    private Scanner s1, s2;

    public MyScanner(Scanner s1, Scanner s2) {
        this.s1 = s1;
        this.s2 = s2;
    }

    public boolean next() {
        return s1.next() || s2.next();
    }

    public int getInt() {
        if (s1.hasNextInt()) {
            return s1.nextInt();
        } else if (s2.hasNextInt()) {
            return s2.nextInt();
        } else {
            throw new IllegalStateException(""No more integers to read"");
        }
    }

    public Constant getVal() {
        if (s1.hasNextDouble()) {
            return s1.nextDouble();
        } else if (s2.hasNextDouble()) {
            return s2.nextDouble();
        } else {
            throw new IllegalStateException(""No more doubles to read"");
        }
    }

    public void beforeFirst() {
        s1.reset();
        s2.reset();
    }

    public String getString() {
        if (s1.hasNext()) {
            return s1.nextLine();
        } else if (s2.hasNext()) {
            return s2.nextLine();
        } else {
            throw new IllegalStateException(""No more strings to read"");
        }
    }

    public void close() {
        s1.close();
        s2.close();
    }
}"
176,"import java.util.*;

public class UserSession {
    private static Map<String, Boolean> userSessions = new HashMap<>();

    public static void registerUserSession(String email) {
        userSessions.put(email, true);
    }

    public static void logoutUser(String email) {
        userSessions.remove(email);
    }

    public static String getEmailId() {
        return userSessions.keySet().stream().findFirst();
    }
}"
177,"import java.util.List;

public class HandlerConfig {
    private String handlerClass;
    private List<String> soapRole;
    private List<ParamValueType> initParam;
    private List<DisplayNameType> displayName;
    private List<XsdQNameType> soapHeader;
    private List<IconType> icon;
    private String id;
    private List<CString> handlerName;
    private List<DescriptionType> description;
    
    public void setHandlerClass(String handlerClass) {
        this.handlerClass = handlerClass;
    }
    
    public void setHandlerName(List<CString> handlerName) {
        this.handlerName = handlerName;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public List<ParamValueType> getInitParam() {
        return initParam;
    }
    
    public List<DisplayNameType> getDisplayName() {
        return displayName;
    }
    
    public String getHandlerClass() {
        return handlerClass;
    }
    
    public List<CString> getHandlerName() {
        return handlerName;
    }
    
    public String getId() {
        return id;
    }
    
    public List<DescriptionType> getDescription() {
        return description;
    }
    
    public List<XsdQNameType> getSoapHeader() {
        return soapHeader;
    }
    
    public List<IconType> getIcon() {
        return icon;
    }
    
    public List<String> getSoapRole() {
        return soapRole;
    }
}"
178,"import java.util.*;
import org.apache.jena.rdf.model.*;
import org.apache.jena.reasoner.rulesys.*;

public class GraphMerging {
    private HashMap<String, String> oldRevisionGraphMap;
    private Logger logger;
    private String revisionInformation;

    public GraphMerging(HashMap<String, String> oldRevisionGraphMap, Logger logger) {
        this.oldRevisionGraphMap = oldRevisionGraphMap;
        this.logger = logger;
    }

    public void saveGraphVorMergingInMap() {
        // Get the URI of the add/set triple
        String addSetUri = getAddSetUri();

        // Get the URI of the patch user
        String patchUserUri = getPatchUserUri();

        // Get the revision number
        String revisionNumber = getRevisionNumber();

        // Get the commit URI
        String commitUri = getCommitUri();

        // Check if the merge is a fast-forward merge
        boolean isFastForwardMerge = isFastForward();

        // Create a set of added or removed triples
        LinkedList<String> addedOrRemovedTripleSet = createAddedOrRemovedTripleSet();

        // Load the graph from the map and merge it with the new revision
        String loadedGraphVorMerging = loadGraphVorMergingFromMap();

        // Get the patch message
        String patchMessage = getPatchMessage();

        // Get the URI of the delete set triple
        String deleteSetUri = getdeleteSetUri();

        // Create a rebase query
        String rebaseQuery = createRebaseQuery(addSetUri, patchUserUri, revisionNumber, commitUri, isFastForwardMerge, addedOrRemovedTripleSet);
    }

    private String getAddSetUri() {
        // Implement the logic to retrieve the URI of the add/set triple here
    }

    private String getPatchUserUri() {
        // Implement the logic to retrieve the URI of the patch user here
    }

    private String getRevisionNumber() {
        // Implement the logic to retrieve the revision number here
    }

    private String getCommitUri() {
        // Implement the logic to retrieve the commit URI here
    }

    private boolean isFastForward() {
        // Implement the logic to check if the merge is a fast-forward merge here
    }

    private LinkedList<String> createAddedOrRemovedTripleSet() {
        // Implement the logic to create a set of added or removed triples here
    }

    private String loadGraphVorMergingFromMap() {
        // Implement the logic to load the graph from the map and merge it with the new revision here
    }

    private String getPatchMessage() {
        // Implement the logic to retrieve the patch message here
    }

    private String getdeleteSetUri() {
        // Implement the logic to retrieve the URI of the delete set triple here
    }

    private String createRebaseQuery(String addSetUri, String patchUserUri, String revisionNumber, String commitUri, boolean isFastForwardMerge, LinkedList<String> addedOrRemovedTripleSet) {
        // Implement the logic to create a rebase query here
    }
}"
179,"public class ParseTable {
    private int defaultReduce;
    private int[] reductionCount;
    private int[] underTerm;
    private int size;

    public void clear() {
        this.defaultReduce = 0;
        this.reductionCount = new int[0];
        this.underTerm = new int[0];
        this.size = 0;
    }

    public void computeDefault() {
        // TODO: Implement the computation of default reduce and under term
        // based on the input grammar and the parse table
    }
}"
18,"public class ViewUtils {
    private static TypedValue mTmpValue = new TypedValue();

    public static boolean isRightToLeft(View view) {
        return view.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }

    public static int getSystemBarHeightInDp(Context context) {
        return context.getResources().getDimensionPixelSize(R.dimen.system_bar_height);
    }

    public static int getStatusBarHeight(Activity activity) {
        Rect rect = new Rect();
        activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);
        return rect.top;
    }

    public static int getActionBarHeightInDp(Context context) {
        TypedArray styledAttributes = context.obtainStyledAttributes(new int[] { android.R.attr.actionBarSize });
        int actionBarHeight = (int) styledAttributes.getDimension(0, 0);
        styledAttributes.recycle();
        return actionBarHeight;
    }

    public static void hideSystemUI(Activity activity) {
        View decorView = activity.getWindow().getDecorView();
        int uiOptions = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
        decorView.setSystemUiVisibility(uiOptions);
    }

    public static int getSystemBarHeight(Activity activity) {
        return activity.getWindow().findViewById(android.R.id.statusBarBackground).getHeight();
    }

    public static int pxToDp(int px, Context context) {
        DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_PX, px, displayMetrics);
    }

    public static int dpToPx(int dp, Context context) {
        DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, displayMetrics);
    }

    public static int getActionBarHeight(Context context) {
        return context.getResources().getDimensionPixelSize(R.dimen.action_bar_height);
    }

    public static T findById(int id, View view) {
        return (T) view.findViewById(id);
    }

    public static Point getScreenRawSize(Context context) {
        WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        Display display = windowManager.getDefaultDisplay();
        Point size = new Point();
        display.getRealSize(size);
        return size;
    }
}"
180,"import java.util.ArrayList;
import java.util.List;

public class SpringChain {
  private static final int DEFAULT_ATTACHMENT_TENSION = 100;
  private static final int DEFAULT_MAIN_TENSION = 200;
  private static final int DEFAULT_ATTACHMENT_FRICTION = 50;
  private static final int DEFAULT_MAIN_FRICTION = 100;

  private List<Spring> mSprings;
  private SpringConfig mMainSpringConfig;
  private SpringConfig mAttachmentSpringConfig;
  private int mControlSpringIndex;
  private SpringSystem mSpringSystem;

  public SpringChain(int id) {
    this.mId = id;
    this.mSprings = new ArrayList<>();
    this.mMainSpringConfig = new SpringConfig(DEFAULT_MAIN_TENSION, DEFAULT_MAIN_FRICTION);
    this.mAttachmentSpringConfig = new SpringConfig(DEFAULT_ATTACHMENT_TENSION, DEFAULT_ATTACHMENT_FRICTION);
  }

  public void addSpring(int id) {
    mSprings.add(new Spring(id));
  }

  public Spring getMainSpring() {
    return mSprings.get(mControlSpringIndex);
  }

  public List<Spring> getAllSprings() {
    return mSprings;
  }

  public void setControlSpringIndex(int index) {
    mControlSpringIndex = index;
  }

  public SpringConfig getMainSpringConfig() {
    return mMainSpringConfig;
  }

  public SpringConfig getAttachmentSpringConfig() {
    return mAttachmentSpringConfig;
  }

  public void onSpringActivate(int springId) {
    // TODO: handle activate event for spring with id = springId
  }

  public void onSpringAtRest(int springId) {
    // TODO: handle at rest event for spring with id = springId
  }

  public void onSpringUpdate(int springId, float position, float velocity) {
    // TODO: handle update event for spring with id = springId
  }

  public void onSpringEndStateChange(int springId) {
    // TODO: handle end state change event for spring with id = springId
  }
}"
181,"package com.example;

import java.util.Collection;
import java.util.List;
import javax.tools.JavaFileObject;

public class ExtensionInfo {
    private ClassFileLoader loader;
    private ErrorQueue eq;
    private Collection<JavaFileObject> outputFiles;
    private int outputWidth;

    public ExtensionInfo(ClassFileLoader loader, ErrorQueue eq, Collection<JavaFileObject> outputFiles, int outputWidth) {
        this.loader = loader;
        this.eq = eq;
        this.outputFiles = outputFiles;
        this.outputWidth = outputWidth;
    }

    public ClassFileLoader getLoader() {
        return loader;
    }

    public ErrorQueue getErrorQueue() {
        return eq;
    }

    public Collection<JavaFileObject> getOutputFiles() {
        return outputFiles;
    }

    public int getOutputWidth() {
        return outputWidth;
    }
}

class ClassFileLoader {
    private List<ExtensionInfo> allExtensions;
    private List<Job> jobs;

    public ClassFileLoader(List<ExtensionInfo> allExtensions, List<Job> jobs) {
        this.allExtensions = allExtensions;
        this.jobs = jobs;
    }

    public List<ExtensionInfo> getAllExtensions() {
        return allExtensions;
    }

    public List<Job> getJobs() {
        return jobs;
    }
}

class ErrorQueue {
    private boolean useFullyQualifiedNames;
    private boolean compile;
    private Goal goal;
    private boolean compileFiles;

    public ErrorQueue(boolean useFullyQualifiedNames, boolean compile, Goal goal, boolean compileFiles) {
        this.useFullyQualifiedNames = useFullyQualifiedNames;
        this.compile = compile;
        this.goal = goal;
        this.compileFiles = compileFiles;
    }

    public boolean getUseFullyQualifiedNames() {
        return useFullyQualifiedNames;
    }

    public boolean getCompile() {
        return compile;
    }

    public Goal getGoal() {
        return goal;
    }

    public boolean getCompileFiles() {
        return compileFiles;
    }
}

class Goal {
    private boolean runToGoal;
    private boolean validate;
    private List<ExtensionInfo> allExtensions;

    public Goal(boolean runToGoal, boolean validate, List<ExtensionInfo> allExtensions) {
        this.runToGoal = runToGoal;
        this.validate = validate;
        this.allExtensions = allExtensions;
    }

    public boolean getRunToGoal() {
        return runToGoal;
    }

    public boolean getValidate() {
        return validate;
    }

    public List<ExtensionInfo> getAllExtensions() {
        return allExtensions;
    }
}

class Job {
    private CodeWriter codeWriter;
    private boolean serializeClassInfo;

    public Job(CodeWriter codeWriter, boolean serializeClassInfo) {
        this.codeWriter = codeWriter;
        this.serializeClassInfo = serializeClassInfo;
    }

    public CodeWriter getCodeWriter() {
        return codeWriter;
    }

    public boolean getSerializeClassInfo() {
        return serializeClassInfo;
    }
}

class CodeWriter {
    private List<Job> jobs;

    public CodeWriter(List<Job> jobs) {
        this.jobs = jobs;
    }

    public List<Job> getJobs() {
        return jobs;
    }
}

public class Main {
    public static void main(String[] args) {
        // Initialize the extensions and jobs
        List<ExtensionInfo> allExtensions = new ArrayList<>();
        List<Job> jobs = new ArrayList<>();

        // Add an extension to the list of extensions
        ExtensionInfo extensionInfo = new ExtensionInfo(new ClassFileLoader(), new ErrorQueue(true, true, new Goal(false, false, null), false), null, 0);
        allExtensions.add(extensionInfo);

        // Add a job to the list of jobs
        Job job = new Job(new CodeWriter(jobs), true);
        jobs.add(job);

        // Print the information about the extension and job
        System.out.println(""Extension Info: "" + extensionInfo);
        System.out.println(""Job: "" + job);
    }
}"
182,"// Setup
String EXAMPLE = ""RMBSentence"";

// Tests
void testGetVelocity() {
    RMBSentence rmb = new RMBSentence();
    assertEquals(0.0, rmb.getVelocity(), 0.0);
}

void testGetCrossTrackError() {
    RMBSentence rmb = new RMBSentence();
    assertEquals(0.0, rmb.getCrossTrackError(), 0.0);
}

void testArrivalStatus() {
    RMBSentence rmb = new RMBSentence();
    assertEquals("""", rmb.getArrivalStatus());
}

void testSetDestination() {
    RMBSentence rmb = new RMBSentence();
    String destination = ""destination"";
    rmb.setDestination(destination);
    assertEquals(destination, rmb.getDestination());
}

void testSetBearing() {
    RMBSentence rmb = new RMBSentence();
    double bearing = 10;
    rmb.setBearing(bearing);
    assertEquals(bearing, rmb.getBearing(), 0.0);
}

void testSetSteerToWithNull() {
    RMBSentence rmb = new RMBSentence();
    String steerTo = null;
    rmb.setSteerTo(steerTo);
    assertEquals("""", rmb.getSteerTo());
}

void testSetOriginId() {
    RMBSentence rmb = new RMBSentence();
    String originId = ""origin"";
    rmb.setOriginId(originId);
    assertEquals(originId, rmb.getOriginId());
}

void testSetStatus() {
    RMBSentence rmb = new RMBSentence();
    String status = ""status"";
    rmb.setStatus(status);
    assertEquals(status, rmb.getStatus());
}

void testConstructor() {
    RMBSentence rmb = new RMBSentence();
    assertNotNull(rmb);
}

void testGetBearing() {
    RMBSentence rmb = new RMBSentence();
    double bearing = 10;
    rmb.setBearing(bearing);
    assertEquals(bearing, rmb.getBearing(), 0.0);
}

void testSetBearingWithNegativeValue() {
    RMBSentence rmb = new RMBSentence();
    double bearing = -1;
    rmb.setBearing(bearing);
    assertEquals(0.0, rmb.getBearing(), 0.0);
}

void testSetSteerTo() {
    RMBSentence rmb = new RMBSentence();
    String steerTo = ""steer to"";
    rmb.setSteerTo(steerTo);
    assertEquals(steerTo, rmb.getSteerTo());
}

void testGetSteerTo() {
    RMBSentence rmb = new RMBSentence();
    String steerTo = ""steer to"";
    rmb.setSteerTo(steerTo);
    assertEquals(steerTo, rmb.getSteerTo());
}

void testSetVelocity() {
    RMBSentence rmb = new RMBSentence();
    double velocity = 10;
    rmb.setVelocity(velocity);
    assertEquals(velocity, rmb.getVelocity(), 0.0);
}

void testGetOriginId() {
    RMBSentence rmb = new RMBSentence();
    String originId = ""origin"";
    rmb.setOriginId(originId);
    assertEquals(originId, rmb.getOriginId());
}

void testSetVelocityWithNegativeValue() {
    RMBSentence rmb = new RMBSentence();
    double velocity = -1;
    rmb.setVelocity(velocity);
    assertEquals(0.0, rmb.getVelocity(), 0.0);
}

void testGetStatus() {
    RMBSentence rmb = new RMBSentence();
    String status = ""status"";
    rmb.setStatus(status);
    assertEquals(status, rmb.getStatus());
}

void testSetBearingWithValueGreaterThanAllowed() {
    RMBSentence rmb = new RMBSentence();
    double bearing = 361;
    rmb.setBearing(bearing);
    assertEquals(359, rmb.getBearing(), 0.0);
}

void testGetRange() {
    RMBSentence rmb = new RMBSentence();
    double range = 10;
    rmb.setRange(range);
    assertEquals(range, rmb.getRange(), 0.0);
}

void testSetRange() {
    RMBSentence rmb = new RMBSentence();
    double range = 10;
    rmb.setRange(range);
    assertEquals(range, rmb.getRange(), 0.0);
}

void testGetDestination() {
    RMBSentence rmb = new RMBSentence();
    String destination = ""destination"";
    rmb.setDestination(destination);
    assertEquals(destination, rmb.getDestination());
}

void testSetCrossTrackError() {
    RMBSentence rmb = new RMBSentence();
    double crossTrackError = 10;
    rmb.setCrossTrackError(crossTrackError);
    assertEquals(crossTrackError, rmb.getCrossTrackError(), 0.0);
}"
183,"// Define the OAuthScope class
public class OAuthScope {
    private long issuedAt;
    private List<OAuthPermission> scopes;
    private UserSubject subject;
    private Client client;
    private boolean preAuthorized;
    private String tokenString;
    private long lifetime;
    private String tokenSecret;

    // Getters and setters for the fields
    public long getIssuedAt() {
        return issuedAt;
    }

    public void setIssuedAt(long issuedAt) {
        this.issuedAt = issuedAt;
    }

    public List<OAuthPermission> getScopes() {
        return scopes;
    }

    public void setScopes(List<OAuthPermission> scopes) {
        this.scopes = scopes;
    }

    public UserSubject getSubject() {
        return subject;
    }

    public void setSubject(UserSubject subject) {
        this.subject = subject;
    }

    public Client getClient() {
        return client;
    }

    public void setClient(Client client) {
        this.client = client;
    }

    public boolean isPreAuthorized() {
        return preAuthorized;
    }

    public void setPreAuthorized(boolean preAuthorized) {
        this.preAuthorized = preAuthorized;
    }

    public String getTokenKey() {
        return tokenString;
    }

    public void setTokenKey(String tokenString) {
        this.tokenString = tokenString;
    }

    public long getLifetime() {
        return lifetime;
    }

    public void setLifetime(long lifetime) {
        this.lifetime = lifetime;
    }

    public String getTokenSecret() {
        return tokenSecret;
    }

    public void setTokenSecret(String tokenSecret) {
        this.tokenSecret = tokenSecret;
    }
}"
184,"package com.example;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class IngredientService {

    @Autowired
    private IngredientRepository ingredientRepository;

    public List<String> getAutoSuggest(int max_suggest) {
        return ingredientRepository.getAllIngredients();
    }

    public Ingredient save(Ingredient ingredient) {
        return ingredientRepository.save(ingredient);
    }

    public List<Ingredient> save(List<Ingredient> ingredients) {
        return ingredientRepository.save(ingredients);
    }

    public Ingredient findOne(Long id) {
        return ingredientRepository.findOne(id);
    }

    public void delete(Long id) {
        ingredientRepository.delete(id);
    }
}"
185,"public class DataLine {
    private Map<String, Object> columns;

    public DataLine(Map<String, Object> columns) {
        this.columns = columns;
    }

    public String getTrimmedPartString(int column) {
        if (column < 0 || !columns.containsKey(column)) {
            return """";
        }

        Object value = columns.get(column);

        if (value instanceof String) {
            return ((String) value).trim();
        } else {
            return """";
        }
    }

    public Long getPartLong(int column) {
        if (column < 0 || !columns.containsKey(column)) {
            return null;
        }

        Object value = columns.get(column);

        if (value instanceof Long) {
            return (Long) value;
        } else {
            return null;
        }
    }

    public Float getPartFloat(int column) {
        if (column < 0 || !columns.containsKey(column)) {
            return null;
        }

        Object value = columns.get(column);

        if (value instanceof Float) {
            return (Float) value;
        } else {
            return null;
        }
    }

    public String adjustDataLine() {
        // This method adjusts the data line by removing any unnecessary leading or trailing spaces from each part.
        for (int i = 0; i < columns.size(); i++) {
            Object value = columns.get(i);

            if (value instanceof String) {
                columns.put(i, ((String) value).trim());
            } else if (value instanceof Long || value instanceof Float) {
                // Don't trim numbers, as they may have leading or trailing zeros.
            } else {
                throw new RuntimeException(""Invalid data type: "" + value.getClass().getName());
            }
        }

        return columns;
    }
}"
186,"// Java code for setting a receive timeout on a connection

import java.util.Timer;
import java.util.TimerTask;

class Connection {
  private Timer timer;
  private TimerTask task;
  private boolean timeoutEnabled;
  private long timeoutMillis;

  public void setTimeoutEnabled(boolean enabled) {
    this.timeoutEnabled = enabled;
  }

  public void resetTimeout() {
    if (this.timer != null && this.task != null) {
      this.task.cancel();
      this.task = null;
    }

    if (this.timeoutEnabled) {
      this.timer = new Timer();
      this.task = new TimerTask() {
        @Override
        public void run() {
          System.out.println(""Timeout occurred!"");
          // Handle timeout here
        }
      };
      this.timer.schedule(this.task, this.timeoutMillis);
    }
  }
}"
187,"package com.example;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.boxsdk.BoxAPIConnection;
import com.boxsdk.BoxFile;
import com.boxsdk.BoxFolder;
import com.boxsdk.BoxItem;
import com.boxsdk.BoxNotification;

public class BoxUtils {
    private static final String LOGIN_MESSAGE = ""Logging into Box account..."";
    private static final String MISSING_FOLDER_MESSAGE = ""Could not find folder with name "";

    private BoxAPIConnection apiConnection;
    private BoxFolder rootFolder;
    private TextBot tb;
    private String devToken;
    private List<String> currentFiles = new ArrayList<>();

    public BoxUtils(BoxAPIConnection apiConnection, BoxFolder rootFolder, TextBot tb, String devToken) {
        this.apiConnection = apiConnection;
        this.rootFolder = rootFolder;
        this.tb = tb;
        this.devToken = devToken;
    }

    public void goToFolder(String folderName) throws IOException {
        BoxFolder currentFolder = rootFolder.getSubfolder(folderName);
        if (currentFolder == null) {
            tb.notify(""Error"", MISSING_FOLDER_MESSAGE + folderName);
        } else {
            System.out.println(""Current folder: "" + currentFolder.getName());
        }
    }

    public void uploadFile(String fileName) throws IOException {
        BoxFile file = rootFolder.uploadFile(fileName, devToken).getResource();
        tb.notify(""Success"", ""Uploaded file: "" + file.getName());
        currentFiles.add(file.getName());
    }

    public void downloadFromCurrent() throws IOException {
        for (BoxItem item : rootFolder) {
            if (item instanceof BoxFile) {
                BoxFile file = (BoxFile) item;
                file.download(devToken);
                tb.notify(""Success"", ""Downloaded file: "" + file.getName());
            }
        }
    }

    public void createNewFolder(String folderName) throws IOException {
        BoxFolder newFolder = rootFolder.createFolder(folderName).getResource();
        tb.notify(""Success"", ""Created new folder: "" + newFolder.getName());
    }

    public void deleteFolder(String folderName) throws IOException {
        BoxFolder folderToDelete = rootFolder.getSubfolder(folderName);
        if (folderToDelete == null) {
            tb.notify(""Error"", MISSING_FOLDER_MESSAGE + folderName);
        } else {
            folderToDelete.delete(devToken);
            tb.notify(""Success"", ""Deleted folder: "" + folderName);
        }
    }

    public void uploadFolder(String folderName) throws IOException {
        BoxAPIConnection api = new BoxAPIConnection(apiConnection.getAccessToken());
        api.setRequestInterceptor(devToken);
        BoxFolder destinationFolder = rootFolder.getSubfolder(folderName);
        if (destinationFolder == null) {
            tb.notify(""Error"", MISSING_FOLDER_MESSAGE + folderName);
        } else {
            for (BoxItem item : rootFolder) {
                if (item instanceof BoxFile) {
                    BoxFile file = (BoxFile) item;
                    file.upload(destinationFolder, devToken).getResource();
                    tb.notify(""Success"", ""Uploaded file: "" + file.getName());
                }
            }
        }
    }

    public void uploadFolderToFolder(String folderName) throws IOException {
        BoxAPIConnection api = new BoxAPIConnection(apiConnection.getAccessToken());
        api.setRequestInterceptor(devToken);
        BoxFolder destinationFolder = rootFolder.getSubfolder(folderName);
        if (destinationFolder == null) {
            tb.notify(""Error"", MISSING_FOLDER_MESSAGE + folderName);
        } else {
            for (BoxItem item : rootFolder) {
                if (item instanceof BoxFile) {
                    BoxFile file = (BoxFile) item;
                    file.upload(destinationFolder, devToken).getResource();
                    tb.notify(""Success"", ""Uploaded file: "" + file.getName());
                }
            }
        }
    }

    public void listFolders() throws IOException {
        for (BoxItem item : rootFolder) {
            if (item instanceof BoxFolder) {
                BoxFolder folder = (BoxFolder) item;
                System.out.println(folder.getName());
            }
        }
    }

    public void notify() throws IOException {
        for (String fileName : currentFiles) {
            tb.notify(""Success"", ""Uploaded file: "" + fileName);
        }
    }

    public List<String> getCurrentFiles() {
        return currentFiles;
    }

    public BoxFolder getFolder(String folderName) throws IOException {
        return rootFolder.getSubfolder(folderName);
    }

    public void setUpNotifications(String callbackURL, String eventTypes) throws IOException {
        BoxNotification notification = new BoxNotification();
        notification.setCallbackURL(callbackURL);
        notification.setEventTypes(eventTypes);
        rootFolder.addListener(notification);
    }

    public void goToRootFolder() throws IOException {
        System.out.println(""Current folder: "" + rootFolder.getName());
    }
}"
188,"public class SocketConnection {
    private final ByteBuffer dbuf;
    private final int BUFFER_SIZE_LOWER_BOUND = 1024;
    private final int BUFFER_SIZE_UPPER_BOUND = 8192;
    private final boolean vCloseRequested = false;

    public SocketConnection(Socket socket) {
        this.socket = socket;
        this.dbuf = ByteBuffer.allocate(BUFFER_SIZE_LOWER_BOUND);
    }

    public void writeBytes(byte[] bytes) {
        int length = bytes.length;
        if (length > BUFFER_SIZE_UPPER_BOUND) {
            throw new IllegalArgumentException(""Buffer size exceeded maximum limit"");
        }
        this.dbuf.put(bytes);
        while (this.dbuf.position() >= BUFFER_SIZE_LOWER_BOUND) {
            int bytesWritten = socket.getOutputStream().write(this.dbuf.array(), 0, Math.min(BUFFER_SIZE_UPPER_BOUND, this.dbuf.position()));
            if (bytesWritten < 0) {
                break;
            }
            this.dbuf.compact();
        }
    }

    public void close() throws IOException {
        if (this.vCloseRequested) {
            socket.close();
            dbuf.clear();
            log.info(""Connection closed"");
        }
    }
}"
189,"import android.media.MediaCodec;
import android.media.MediaMuxer;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class MediaRecorder {
    private String mOutputPath;
    private boolean DEBUG;
    private String TAG;
    private SimpleDateFormat mDateTimeFormat;
    private int mStartedCount;
    private boolean mIsStarted;
    private int mEncoderCount;
    private MediaEncoder mAudioEncoder;
    private MediaEncoder mVideoEncoder;

    public MediaRecorder(String outputPath) {
        mOutputPath = outputPath;
        DEBUG = false;
        TAG = ""MediaRecorder"";
        mDateTimeFormat = new SimpleDateFormat(""yyyy-MM-dd_HH:mm:ss"", Locale.US);
        mStartedCount = 0;
        mIsStarted = false;
        mEncoderCount = 0;
        mAudioEncoder = null;
        mVideoEncoder = null;
    }

    public void prepare() {
        // Prepare audio and video encoders
        mAudioEncoder = new MediaEncoder();
        mVideoEncoder = new MediaEncoder();
    }

    public String getDateTimeString() {
        Date date = new Date();
        return mDateTimeFormat.format(date);
    }

    public void stop() {
        if (mIsStarted) {
            // Stop recording
            mVideoEncoder.stopRecording();
            mAudioEncoder.stopRecording();
            mIsStarted = false;
        }
    }

    public void addEncoder(MediaEncoder encoder) {
        if (mEncoderCount == 0) {
            // Add audio and video encoders
            mAudioEncoder = encoder;
            mVideoEncoder = encoder;
        } else {
            // Add additional encoders
            mAudioEncoder.addMediaCodec(encoder);
            mVideoEncoder.addMediaCodec(encoder);
        }
    }

    public void startRecording() {
        if (!mIsStarted) {
            // Start recording
            mVideoEncoder.startRecording();
            mAudioEncoder.startRecording();
            mIsStarted = true;
        }
    }

    public boolean start() {
        return true;
    }

    public File getCaptureFile(String fileName) {
        String filePath = mOutputPath + ""/"" + fileName + "".mp4"";
        return new File(filePath);
    }

    public boolean isStarted() {
        return mIsStarted;
    }

    public String getOutputPath() {
        return mOutputPath;
    }

    public void stopRecording() {
        if (mIsStarted) {
            // Stop recording
            mVideoEncoder.stopRecording();
            mAudioEncoder.stopRecording();
            mIsStarted = false;
        }
    }

    public void writeSampleData(int trackIndex, byte[] data) {
        if (mIsStarted) {
            // Write sample data to the appropriate encoder
            MediaCodec codec = getMediaCodecByTrackIndex(trackIndex);
            codec.writeSampleData(data);
        }
    }

    private MediaCodec getMediaCodecByTrackIndex(int trackIndex) {
        if (mIsStarted && mEncoderCount > 0) {
            // Get the appropriate encoder based on the track index
            if (trackIndex == MediaMuxer.TRACK_INDEX_UNKNOWN || trackIndex >= mEncoderCount) {
                return null;
            } else if (trackIndex == 0) {
                return mAudioEncoder;
            } else {
                return mVideoEncoder;
            }
        }
        return null;
    }
}"
19,"import java.util.*;

class Main {
    public static void main(String[] args) {
        // Initialize the hashtables
        Hashtable<String, String> lists = new Hashtable<>();
        Hashtable<String, ChecklistStatus> statuses = new Hashtable<>();

        // Get the checklist for an element
        String element = ""element"";
        ChecklistStatus status = getStatusFor(element);

        // Register the checklist
        register(status);
    }

    public static ChecklistStatus getStatusFor(String element) {
        // Lookup the checklist for the element in the lists hashtable
        String listName = lists.get(element);

        // If a checklist is found, return it
        if (listName != null) {
            return statuses.get(listName);
        }

        // Otherwise, create a new checklist and register it
        ChecklistStatus status = new ChecklistStatus();
        register(status);

        // Return the newly created checklist
        return status;
    }

    public static void register(ChecklistStatus status) {
        // Register the checklist in the statuses hashtable
        statuses.put(status.getListName(), status);
    }
}"
190,"package com.example;

import android.view.animation.Interpolator;

public class ScrollAnimation {
    private int mDuration; // duration of the scroll animation in milliseconds
    private Interpolator mInterpolator; // interpolator to use for the scroll animation
    private float mFinal; // final position of the scroll animation
    private boolean mFinished; // whether the scroll animation has finished or not
    private float mDurationReciprocal; // reciprocal of the duration, used for calculating the current position
    private float mStart; // starting position of the scroll animation
    private long mStartTime; // time when the scroll animation started
    private float mCurr; // current position of the scroll animation
    private float mDeltaX; // distance traveled by the scroll animation

    public ScrollAnimation(int duration, Interpolator interpolator) {
        this.mDuration = duration;
        this.mInterpolator = interpolator;
        this.mFinished = false;
    }

    public void startScroll() {
        // reset the animation if it has already finished
        if (mFinished) {
            mStartTime = 0;
            mCurr = 0;
        } else {
            mStartTime = System.currentTimeMillis();
        }
    }

    public void forceFinished() {
        mFinished = true;
    }

    public void abortAnimation() {
        mFinished = true;
        mCurr = 0;
        mStartTime = 0;
    }

    public void extendDuration(int duration) {
        this.mDuration += duration;
    }

    public int timePassed() {
        return (int) (System.currentTimeMillis() - mStartTime);
    }

    public int getDuration() {
        return mDuration;
    }

    public float getStart() {
        return mStart;
    }

    public float getCurr() {
        return mCurr;
    }

    public boolean isFinished() {
        return mFinished;
    }

    public void setFinal(float finalPosition) {
        this.mFinal = finalPosition;
    }

    public boolean computeScrollOffset() {
        // calculate the current position of the scroll animation based on the interpolator and duration
        if (mFinished) {
            mCurr = mFinal;
            return true;
        } else {
            long timePassed = System.currentTimeMillis() - mStartTime;
            float distance = mInterpolator.getInterpolation(timePassed / (float) mDuration) * mDeltaX;
            mCurr = mStart + distance;
            if (timePassed >= mDuration) {
                mFinished = true;
            }
            return false;
        }
    }
}"
191,"// Assert that the map has entries
Assert.notEmpty(map);

// Assert that the map is not null
Assert.notNull(map);

// Assert that the map has at least one entry
Assert.isTrue(!map.isEmpty());"
192,"import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

class NotificationControllerTest {
  private ServerSession mockServerSession;
  private ServerMessage mockServerMessage;
  private HashMap<String, Object> testEventProperties;
  private String MOCK_SESSION_ID;
  private NotificationController notificationController;

  @BeforeEach
  void setUp() {
    mockServerSession = Mockito.mock(ServerSession.class);
    mockServerMessage = Mockito.mock(ServerMessage.class);
    testEventProperties = new HashMap<>();
    MOCK_SESSION_ID = ""session-id"";
    notificationController = new NotificationController();
  }

  @AfterEach
  void tearDown() {
    // Clean up any resources used during the tests
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnEmptyUser() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent(null, null);
    });
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnEmptyApplication() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent("""", """");
    });
  }

  @Test
  void testDeregisterUserSessionWithNullServerSessonThrowsException() {
    assertThrows(NullPointerException.class, () -> {
      notificationController.deregisterUserSession(null);
    });
  }

  @Test
  void testDeregisterUserSessionWithNullServerSessionIdThrowsException() {
    assertThrows(NullPointerException.class, () -> {
      notificationController.deregisterUserSession("""");
    });
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnNullTitle() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent(null, """", """");
    });
  }

  @Test
  void testGetServerSessionByUserId() {
    // Test that the method returns the expected server session for a given user ID
    String userId = ""user-id"";
    ServerSession expectedServerSession = new ServerSession(userId);
    Mockito.when(mockServerSession.getUserId()).thenReturn(userId);
    assertEquals(expectedServerSession, notificationController.getServerSessionByUserId(userId));
  }

  @Test
  void testDeregisterUserSessionRemovesUserFromKnownClients() {
    // Test that the method removes the user from the known clients list
    String userId = ""user-id"";
    ServerSession serverSession = new ServerSession(userId);
    notificationController.registerUserSession(serverSession);
    notificationController.deregisterUserSession(serverSession);
    assertFalse(notificationController.knownClients.containsKey(userId));
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnEmptyMessage() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent("""", """", """");
    });
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnNullApplication() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent("""", null);
    });
  }

  @Test
  void testDeletePersistentNotificationThrowsIllegalArgumentOnNullUserId() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.deletePersistentNotification(null);
    });
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnNullUser() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent("""", """", null);
    });
  }

  @Test
  void testRegisterUserSession() {
    // Test that the method registers a new user session and returns true
    ServerSession serverSession = new ServerSession(""user-id"");
    assertTrue(notificationController.registerUserSession(serverSession));
  }

  @Test
  void testRegisterUserSessionWithNullServerSessionIdThrowsException() {
    assertThrows(NullPointerException.class, () -> {
      notificationController.registerUserSession(null);
    });
  }

  @Test
  void testHandleEventThrowsIllegalArgumentExceptionOnNullTimestamp() {
    assertThrows(IllegalArgumentException.class, () -> {
      notificationController.handleEvent("""", """", null);
    });
  }
}"
193,"public class Wizard {
    private List<JPanel> panels;
    private int step;
    private boolean started;
    private boolean finished;
    private WizardItem item;

    public Wizard() {
        this.panels = new ArrayList<>();
        this.step = 0;
        this.started = false;
        this.finished = false;
        this.item = null;
    }

    public void next() {
        if (canGoNext()) {
            this.step++;
            if (this.step >= panels.size()) {
                finish();
            } else {
                removePanel(getCurrentPanel());
                JPanel panel = makePanel(step);
                addPanel(panel);
                setToDoItem(item);
            }
        }
    }

    public void removePanel(JPanel panel) {
        panels.remove(panel);
    }

    public JPanel getCurrentPanel() {
        return panels.get(step);
    }

    public boolean canGoBack() {
        return step > 0;
    }

    public boolean canFinish() {
        return step == panels.size() - 1;
    }

    public int getStep() {
        return step;
    }

    public JPanel makePanel(int index) {
        // This method is not provided, so it should be implemented by the user.
        // It should create a new instance of a JPanel and return it.
        throw new UnsupportedOperationException(""Method makePanel() is not implemented"");
    }

    public void back() {
        if (canGoBack()) {
            this.step--;
            removePanel(getCurrentPanel());
            JPanel panel = makePanel(step);
            addPanel(panel);
            setToDoItem(item);
        }
    }

    public int getNumSteps() {
        return panels.size();
    }

    public boolean isStarted() {
        return started;
    }

    public void setToDoItem(WizardItem item) {
        this.item = item;
    }

    public boolean isFinished() {
        return finished;
    }

    public int getProgress() {
        if (getNumSteps() == 0) {
            return 0;
        } else {
            return step + 1;
        }
    }

    public WizardItem getToDoItem() {
        return item;
    }

    public boolean canGoNext() {
        return !finished && (step < panels.size());
    }

    public void finish() {
        if (canFinish()) {
            finished = true;
        }
    }

    public JPanel getPanel(int index) {
        return panels.get(index);
    }

    public void doAction(JPanel panel) {
        // This method is not provided, so it should be implemented by the user.
        // It should perform the action associated with the given JPanel and update the progress of the wizard.
        throw new UnsupportedOperationException(""Method doAction() is not implemented"");
    }
}"
194,"import java.util.Objects;

public class Tag {
    private final String key;
    private final String value;

    public Tag(String key, String value) {
        this.key = key;
        this.value = value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tag tag = (Tag) o;
        return Objects.equals(key, tag.key) &&
                Objects.equals(value, tag.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(key, value);
    }

    @Override
    public String toString() {
        return ""Tag{"" +
                ""key='"" + key + '\'' +
                "", value='"" + value + '\'' +
                '}';
    }

    public static void main(String[] args) {
        Tag tag1 = new Tag(""key"", ""value"");
        Tag tag2 = new Tag(""key"", ""value"");
        System.out.println(tag1.equals(tag2)); // prints true
    }
}"
195,"// Java code to set a default spacing value and provide fallback for different directions

public class Spacing {
    private static final int[] sFlagsMap = new int[] {
        LEFT, TOP, RIGHT, BOTTOM, START, END
    };

    private boolean mHasAliasesSet;
    private float[] mDefaultSpacing;
    private float[] mValueFlags;
    private float[] mSpacing;

    public Spacing() {
        mHasAliasesSet = false;
        mDefaultSpacing = new float[sFlagsMap.length];
        mValueFlags = new int[sFlagsMap.length];
        mSpacing = new float[sFlagsMap.length];
    }

    public boolean set(float[] newFullSpacingArray) {
        for (int i = 0; i < sFlagsMap.length; i++) {
            if (!Float.isNaN(newFullSpacingArray[i])) {
                mHasAliasesSet = true;
                mValueFlags[i] |= Spacing.ALL;
                mDefaultSpacing[i] = newFullSpacingArray[i];
                mSpacing[i] = newFullSpacingArray[i];
            } else {
                mHasAliasesSet = false;
            }
        }
        return mHasAliasesSet;
    }

    public float[] get() {
        if (!mHasAliasesSet) {
            return newSpacingResultArray(mDefaultSpacing);
        } else {
            return newSpacingResultArray(mSpacing);
        }
    }

    public void reset() {
        mHasAliasesSet = false;
        Arrays.fill(mValueFlags, 0);
        Arrays.fill(mDefaultSpacing, Float.NaN);
        Arrays.fill(mSpacing, Float.NaN);
    }

    private float[] newSpacingResultArray(float[] spacing) {
        return Arrays.copyOf(spacing, spacing.length);
    }

    public float getRaw() {
        return mHasAliasesSet ? mSpacing[Spacing.ALL] : mDefaultSpacing[Spacing.ALL];
    }

    public float getWithFallback() {
        if (!mHasAliasesSet) {
            return mDefaultSpacing[Spacing.ALL];
        } else {
            return mSpacing[Spacing.ALL];
        }
    }
}"
196,"[PYTHON]
import java.io.File;
import java.net.URL;
import java.util.*;
import java.util.regex.Pattern;

class ClasspathScanner {
    private static final String ALL_CLASS_FILES = ""**/*.class"";
    private static final String CLASSPATH_URL_SCHEME = ""file:///"";
    private static final String WILDCARD = "".*"";
    private static final String[] PACKAGES_TO_SKIP = {""java."", ""javax."", ""sun."", ""com.sun.""};

    public Map<Class<? extends Annotation>, Collection<Class<?>>> findClasses(String basePackage) {
        return findClassesInternal(basePackage);
    }

    private Map<Class<? extends Annotation>, Collection<Class<?>>> findClassesInternal(String basePackage) {
        Set<Class<?>> classes = new HashSet<>();
        for (String packageToScan : getPackagesToScan()) {
            String scanPath = CLASSPATH_URL_SCHEME + packageToScan.replace(""."", ""/"");
            try {
                List<URL> urls = findResourcesInternal(scanPath);
                for (URL url : urls) {
                    classes.addAll(getClassesFromResource(url));
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return getAnnotatedClasses(classes);
    }

    private Set<String> getPackagesToScan() {
        Set<String> packages = new HashSet<>();
        String classpath = System.getProperty(""java.class.path"");
        for (String path : classpath.split(File.pathSeparator)) {
            if (!path.endsWith("".jar"") && !path.endsWith("".JAR"")) {
                packages.add(new File(path).getName());
            }
        }
        return packages;
    }

    private List<URL> findResourcesInternal(String path) throws IOException {
        List<URL> resources = new ArrayList<>();
        Enumeration<URL> urls = ClassLoader.getSystemClassLoader().getResources(path);
        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            if (url != null) {
                resources.add(url);
            }
        }
        return resources;
    }

    private Set<Class<?>> getClassesFromResource(URL resource) throws IOException, ClassNotFoundException {
        Set<Class<?>> classes = new HashSet<>();
        try (ZipInputStream stream = new ZipInputStream(resource.openStream())) {
            for (ZipEntry entry = stream.getNextEntry(); entry != null; entry = stream.getNextEntry()) {
                if (!entry.isDirectory() && entry.getName().endsWith(ALL_CLASS_FILES)) {
                    String className = entry.getName().replace(""/"", ""."").substring(0, entry.getName().length() - ALL_CLASS_FILES.length());
                    classes.add(Class.forName(className));
                }
            }
        }
        return classes;
    }

    private Map<Class<? extends Annotation>, Collection<Class<?>>> getAnnotatedClasses(Set<Class<?>> classes) {
        Map<Class<? extends Annotation>, Collection<Class<?>>> annotatedClasses = new HashMap<>();
        for (Class<?> clazz : classes) {
            for (Annotation annotation : clazz.getDeclaredAnnotations()) {
                if (!annotatedClasses.containsKey(annotation.annotationType())) {
                    annotatedClasses.put(annotation.annotationType(), new HashSet<Class<?>>());
                }
                annotatedClasses.get(annotation.annotationType()).add(clazz);
            }
        }
        return annotatedClasses;
    }
}
[/PYTHON]
[TESTS]
import java.io.File;
import java.net.URL;
import java.util.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class ClasspathScannerTest {
    @InjectMocks
    private ClasspathScanner classpathScanner;

    @Mock
    private URLClassLoader urlClassLoader;

    @BeforeEach
    void setUp() {
        List<URL> urls = new ArrayList<>();
        urls.add(new File(""."").toURI().toURL());
        when(urlClassLoader.getURLs()).thenReturn(urls);
    }

    @Test
    void testFindClasses_withValidBasePackage() {
        String basePackage = ""com.example"";
        Map<Class<? extends Annotation>, Collection<Class<?>>> annotatedClasses = classpathScanner.findClasses(basePackage);
        assertFalse(annotatedClasses.isEmpty());
    }

    @Test
    void testFindClasses_withInvalidBasePackage() {
        String basePackage = ""invalid.package"";
        Map<Class<? extends Annotation>, Collection<Class<?>>> annotatedClasses = classpathScanner.findClasses(basePackage);
        assertTrue(annotatedClasses.isEmpty());
    }
}
[/TESTS]"
197,"import java.util.*;

public class XPathContext {
    private String name;
    private QName qname;
    private Map<String, String> uri2Prefix;
    private Map<QName, Level> attributes;
    private Deque<Level> path;
    private String sep;
    private String comment;
    private String xpath;
    private List<Level> children;
    private short type;

    public XPathContext(String name) {
        this.name = name;
        this.qname = new QName(name);
        this.uri2Prefix = new HashMap<>();
        this.attributes = new HashMap<>();
        this.path = new ArrayDeque<>();
        this.sep = ""/"";
        this.comment = """";
        this.xpath = """";
        this.children = new ArrayList<>();
        this.type = 0; // type is initialized to 0, which means the current node is an element
    }

    public void navigateToParent() {
        if (path.isEmpty()) {
            return;
        }
        Level level = path.pop();
        children.remove(level);
        invert.put(level.getName(), level.getXPath());
    }

    public String getName() {
        return name;
    }

    public QName getQName() {
        return qname;
    }

    public short getType() {
        return type;
    }

    public void addAttributes(Map<String, String> attributes) {
        this.attributes.putAll(attributes);
    }

    public XPathContext clone() {
        XPathContext clone = new XPathContext(name);
        clone.uri2Prefix = uri2Prefix;
        clone.attributes = attributes;
        clone.path = path;
        clone.sep = sep;
        clone.comment = comment;
        clone.xpath = xpath;
        clone.children = children;
        clone.type = type;
        return clone;
    }

    public int add1OrIncrement() {
        return path.size();
    }

    public String getXPath() {
        return xpath;
    }

    public void navigateToChild(String name) {
        Level level = new Level(name);
        children.add(level);
        path.push(level);
        invert.put(level.getName(), level.getXPath());
    }

    public void setChildren(List<Level> children) {
        this.children = children;
    }

    public void navigateToAttribute(String name) {
        Level level = new Level(name);
        path.push(level);
        invert.put(level.getName(), level.getXPath());
    }

    private class Level {
        private String name;
        private short type;
        private Map<String, String> attributes;
        private String xpath;

        public Level(String name) {
            this.name = name;
            this.type = 0; // type is initialized to 0, which means the current node is an element
            this.attributes = new HashMap<>();
            this.xpath = """";
        }

        public String getName() {
            return name;
        }

        public short getType() {
            return type;
        }

        public Map<String, String> getAttributes() {
            return attributes;
        }

        public String getXPath() {
            return xpath;
        }
    }
}"
198,"import java.util.List;
import java.util.Optional;

public class ContentTypeDetector {
    private final List<ContentTypeRule> rules;

    public ContentTypeDetector(String defaultContentTypeProperty) {
        this.rules = new ArrayList<>();
        addRule(new DefaultContentTypeRule(defaultContentTypeProperty));
    }

    public void addRule(ContentTypeRule rule) {
        rules.add(rule);
    }

    public Optional<String> determineContentType(String message) {
        for (ContentTypeRule rule : rules) {
            String contentType = rule.determineContentType(message);
            if (contentType != null) {
                return Optional.of(contentType);
            }
        }
        return Optional.empty();
    }
}

interface ContentTypeRule {
    String determineContentType(String message);
}

class DefaultContentTypeRule implements ContentTypeRule {
    private final String defaultContentTypeProperty;

    public DefaultContentTypeRule(String defaultContentTypeProperty) {
        this.defaultContentTypeProperty = defaultContentTypeProperty;
    }

    @Override
    public String determineContentType(String message) {
        return System.getProperty(defaultContentTypeProperty);
    }
}"
199,"package com.example;

import java.util.List;

public class GetOfferDetailsResponse {
    private Return return;

    public static class Return {
        private DetailOfferData detailOfferData;

        public DetailOfferData getDetailOfferData() {
            return detailOfferData;
        }

        public void setDetailOfferData(DetailOfferData detailOfferData) {
            this.detailOfferData = detailOfferData;
        }
    }

    public static class DetailOfferData {
        private List<FulfillmentPartner> fulfillmentPartners;
        private SourceGeos sourceGeos;
        private Seo seo;
        private Merchant merchant;
        private TargetGeos targetGeos;
        private OfferMedia offerMedia;
        private Products products;
        private RedemptionAddresses redemptionAddresses;

        public List<FulfillmentPartner> getFulfillmentPartners() {
            return fulfillmentPartners;
        }

        public void setFulfillmentPartners(List<FulfillmentPartner> fulfillmentPartners) {
            this.fulfillmentPartners = fulfillmentPartners;
        }

        public SourceGeos getSourceGeos() {
            return sourceGeos;
        }

        public void setSourceGeos(SourceGeos sourceGeos) {
            this.sourceGeos = sourceGeos;
        }

        public Seo getSeo() {
            return seo;
        }

        public void setSeo(Seo seo) {
            this.seo = seo;
        }

        public Merchant getMerchant() {
            return merchant;
        }

        public void setMerchant(Merchant merchant) {
            this.merchant = merchant;
        }

        public TargetGeos getTargetGeos() {
            return targetGeos;
        }

        public void setTargetGeos(TargetGeos targetGeos) {
            this.targetGeos = targetGeos;
        }

        public OfferMedia getOfferMedia() {
            return offerMedia;
        }

        public void setOfferMedia(OfferMedia offerMedia) {
            this.offerMedia = offerMedia;
        }

        public Products getProducts() {
            return products;
        }

        public void setProducts(Products products) {
            this.products = products;
        }

        public RedemptionAddresses getRedemptionAddresses() {
            return redemptionAddresses;
        }

        public void setRedemptionAddresses(RedemptionAddresses redemptionAddresses) {
            this.redemptionAddresses = redemptionAddresses;
        }
    }

    public static class SourceGeos {
        private List<Geo> geos;

        public List<Geo> getGeos() {
            return geos;
        }

        public void setGeos(List<Geo> geos) {
            this.geos = geos;
        }
    }

    public static class Geo {
        private String country;
        private String region;
        private String city;

        public String getCountry() {
            return country;
        }

        public void setCountry(String country) {
            this.country = country;
        }

        public String getRegion() {
            return region;
        }

        public void setRegion(String region) {
            this.region = region;
        }

        public String getCity() {
            return city;
        }

        public void setCity(String city) {
            this.city = city;
        }
    }

    public static class Seo {
        private String title;
        private String metaDescription;

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getMetaDescription() {
            return metaDescription;
        }

        public void setMetaDescription(String metaDescription) {
            this.metaDescription = metaDescription;
        }
    }

    public static class Merchant {
        private Addresses addresses;

        public Addresses getAddresses() {
            return addresses;
        }

        public void setAddresses(Addresses addresses) {
            this.addresses = addresses;
        }
    }

    public static class Addresses {
        private List<String> addresses;

        public List<String> getAddresses() {
            return addresses;
        }

        public void setAddresses(List<String> addresses) {
            this.addresses = addresses;
        }
    }

    public static class TargetGeos {
        private List<Geo> geos;

        public List<Geo> getGeos() {
            return geos;
        }

        public void setGeos(List<Geo> geos) {
            this.geos = geos;
        }
    }

    public static class OfferMedia {
        private List<OfferImage> offerImages;

        public List<OfferImage> getOfferImages() {
            return offerImages;
        }

        public void setOfferImages(List<OfferImage> offerImages) {
            this.offerImages = offerImages;
        }
    }

    public static class OfferImage {
        private List<Entry> entries;

        public List<Entry> getEntries() {
            return entries;
        }

        public void setEntries(List<Entry> entries) {
            this.entries = entries;
        }
    }

    public static class Entry {
        private String value;
        private List<Item> items;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }

        public List<Item> getItems() {
            return items;
        }

        public void setItems(List<Item> items) {
            this.items = items;
        }
    }

    public static class Item {
        private String title;
        private String description;
        private String imageUrl;
        private String linkUrl;
        private String datePublished;

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public String getImageUrl() {
            return imageUrl;
        }

        public void setImageUrl(String imageUrl) {
            this.imageUrl = imageUrl;
        }

        public String getLinkUrl() {
            return linkUrl;
        }

        public void setLinkUrl(String linkUrl) {
            this.linkUrl = linkUrl;
        }

        public String getDatePublished() {
            return datePublished;
        }

        public void setDatePublished(String datePublished) {
            this.datePublished = datePublished;
        }
    }

    public static class Products {
        private List<Product> products;

        public List<Product> getProducts() {
            return products;
        }

        public void setProducts(List<Product> products) {
            this.products = products;
        }
    }

    public static class Product {
        private String title;
        private String description;
        private String imageUrl;
        private String linkUrl;
        private String datePublished;

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public String getImageUrl() {
            return imageUrl;
        }

        public void setImageUrl(String imageUrl) {
            this.imageUrl = imageUrl;
        }

        public String getLinkUrl() {
            return linkUrl;
        }

        public void setLinkUrl(String linkUrl) {
            this.linkUrl = linkUrl;
        }

        public String getDatePublished() {
            return datePublished;
        }

        public void setDatePublished(String datePublished) {
            this.datePublished = datePublished;
        }
    }

    public static class RedemptionAddresses {
        private List<RedemptionAddress> redemptionAddresses;

        public List<RedemptionAddress> getRedemptionAddresses() {
            return redemptionAddresses;
        }

        public void setRedemptionAddresses(List<RedemptionAddress> redemptionAddresses) {
            this.redemptionAddresses = redemptionAddresses;
        }
    }

    public static class RedemptionAddress {
        private String address;

        public String getAddress() {
            return address;
        }

        public void setAddress(String address) {
            this.address = address;
        }
    }

    public static class OfferDisplay {
        private String displayName;
        private String description;
        private List<Image> images;

        public String getDisplayName() {
            return displayName;
        }

        public void setDisplayName(String displayName) {
            this.displayName = displayName;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public List<Image> getImages() {
            return images;
        }

        public void setImages(List<Image> images) {
            this.images = images;
        }
    }

    public static class Image {
        private String url;
        private int height;
        private int width;

        public String getUrl() {
            return url;
        }

        public void setUrl(String url) {
            this.url = url;
        }

        public int getHeight() {
            return height;
        }

        public void setHeight(int height) {
            this.height = height;
        }

        public int getWidth() {
            return width;
        }

        public void setWidth(int width) {
            this.width = width;
        }
    }
}"
2,"import java.util.UUID;

public class MYCLASS {
  private String id;
  private boolean canCreate;

  public MYCLASS(boolean canCreate) {
    this.canCreate = canCreate;
  }

  public String readObjectID() {
    if (id == null && canCreate) {
      id = generateID();
    }
    return id;
  }

  private String generateID() {
    return UUID.randomUUID().toString();
  }

  @Override
  public String toString() {
    return ""MYCLASS{"" +
        ""id='"" + id + '\'' +
        '}';
  }
}"
20,"package net.sf.marineapi.nmea.util;

import static org.junit.Assert.*;

import java.util.GregorianCalendar;
import java.util.TimeZone;

import org.junit.Before;
import org.junit.Test;

public class DateTest {

    private Date date;

    @Before
    public void setUp() {
        date = new Date();
    }

    @Test
    public void testConstructorWithValues() {
        int day = 10;
        int month = 5;
        int year = 2023;
        GregorianCalendar cal = new GregorianCalendar(year, month - 1, day);
        Date date = new Date(cal);
        assertEquals(day, date.getDay());
        assertEquals(month, date.getMonth());
        assertEquals(year, date.getYear());
    }

    @Test
    public void testConstructorWithString() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023-05-10"", date.toString());
    }

    @Test
    public void testSetMonth() {
        int month = 7;
        date.setMonth(month);
        assertEquals(month, date.getMonth());
    }

    @Test(expected = IllegalArgumentException.class)
    public void testSetMonthOutOfBounds() {
        int month = 13;
        date.setMonth(month);
    }

    @Test
    public void testSetDay() {
        int day = 20;
        date.setDay(day);
        assertEquals(day, date.getDay());
    }

    @Test
    public void testSetYearTwoDigit() {
        int year = 23;
        date.setYear(year);
        assertEquals(""2023"", date.toString());
    }

    @Test
    public void testSetYearFourDigit() {
        int year = 2023;
        date.setYear(year);
        assertEquals(""2023"", date.toString());
    }

    @Test
    public void testSetYearThreeDigits() {
        int year = 123;
        date.setYear(year);
        assertEquals(""0123"", date.toString());
    }

    @Test
    public void testSetYearFiveDigits() {
        int year = 12345;
        date.setYear(year);
        assertEquals(""12345"", date.toString());
    }

    @Test
    public void testSetYearNegative() {
        int year = -123;
        date.setYear(year);
        assertEquals(""-0123"", date.toString());
    }

    @Test
    public void testToISO8601FourDigitYear() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023"", date.toISO8601FourDigitYear());
    }

    @Test
    public void testToISO8601TwoDigitYear() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""23"", date.toISO8601TwoDigitYear());
    }

    @Test
    public void testToISO8601WithTime() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023-05-10T14:15:16"", date.toISO8601WithTime());
    }

    @Test
    public void testToISO8601WithTimeAndZeroZone() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023-05-10T14:15:16Z"", date.toISO8601WithTimeAndZeroZone());
    }

    @Test
    public void testToISO8601WithTimeAndPositiveOffset() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023-05-10T14:15:16+08:00"", date.toISO8601WithTimeAndPositiveOffset());
    }

    @Test
    public void testToISO8601WithTimeAndNegativeOffset() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023-05-10T14:15:16-08:00"", date.toISO8601WithTimeAndNegativeOffset());
    }

    @Test
    public void testGetYear() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023"", date.getYear());
    }

    @Test
    public void testGetMonth() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""05"", date.getMonth());
    }

    @Test
    public void testGetDay() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""10"", date.getDay());
    }

    @Test
    public void testToStringFourDigitYear() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023"", date.toStringFourDigitYear());
    }

    @Test
    public void testToStringTwoDigitYear() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""23"", date.toStringTwoDigitYear());
    }

    @Test
    public void testToString() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertEquals(""2023-05-10"", date.toString());
    }

    @Test
    public void testEqualsItself() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertTrue(date.equals(date));
    }

    @Test
    public void testEqualsWhenChanged() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        int day = 20;
        date.setDay(day);
        assertFalse(date.equals(new Date()));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testEqualsWrongType() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date = new Date(str);
        assertTrue(date.equals(""test""));
    }

    @Test
    public void testEqualsAfterInit() {
        String str = ""2023-05-10T14:15:16+08:00"";
        Date date1 = new Date(str);
        Date date2 = new Date(str);
        assertTrue(date1.equals(date2));
    }
}"
200,"import java.io.Serializable;

public class ItemResponse<T extends Serializable> implements Serializable {
    private long serialVersionUID = 1L;
    private ItemList<T> items;
    private ResponseStatus status;

    public ItemResponse() {}

    public ItemResponse(ItemList<T> items, ResponseStatus status) {
        this.items = items;
        this.status = status;
    }

    public void setItems(ItemList<T> items) {
        this.items = items;
    }

    public ItemList<T> getItems() {
        return items;
    }

    public void setStatus(ResponseStatus status) {
        this.status = status;
    }

    public ResponseStatus getStatus() {
        return status;
    }

    @Override
    public String toString() {
        return ""ItemResponse{"" +
                ""items="" + items +
                "", status="" + status +
                '}';
    }
}"
201,"import java.util.*;

class DirectedAcyclicGraph<T> {
  private Map<T, DirectedAcyclicGraphNode<T>> mIndex;
  private List<DirectedAcyclicGraphNode<T>> mRoots;

  public DirectedAcyclicGraph() {
    this.mIndex = new HashMap<>();
    this.mRoots = new ArrayList<>();
  }

  // method to check if a given payload is in the root of the dag
  public boolean contains(T payload) {
    return mIndex.containsKey(payload);
  }

  // method to add an edge between two nodes
  public void add(T from, T to) {
    DirectedAcyclicGraphNode<T> fromNode = mIndex.get(from);
    DirectedAcyclicGraphNode<T> toNode = mIndex.get(to);
    if (fromNode == null || toNode == null) {
      return;
    }
    fromNode.addChild(toNode);
  }

  // method to delete a leaf node from the dag
  public void deleteLeaf(T payload) {
    DirectedAcyclicGraphNode<T> node = mIndex.get(payload);
    if (node == null || !node.isLeaf()) {
      return;
    }
    for (DirectedAcyclicGraphNode<T> child : node.getChildren()) {
      child.removeChild(node);
    }
    mRoots.remove(payload);
    mIndex.remove(payload);
  }

  // method to get the parents of a given payload
  public List<T> getParents(T payload) {
    DirectedAcyclicGraphNode<T> node = mIndex.get(payload);
    if (node == null) {
      return Collections.emptyList();
    }
    return node.getParents();
  }

  // method to get the children of a given payload
  public List<T> getChildren(T payload) {
    DirectedAcyclicGraphNode<T> node = mIndex.get(payload);
    if (node == null) {
      return Collections.emptyList();
    }
    return node.getChildren();
  }

  // method to get the roots of the dag
  public List<T> getRoots() {
    return mRoots;
  }

  // method to get all nodes in the dag in topological order
  public List<T> getAllInTopologicalOrder() {
    List<DirectedAcyclicGraphNode<T>> sortedNodes = new ArrayList<>();
    for (DirectedAcyclicGraphNode<T> node : mIndex.values()) {
      if (!node.isLeaf()) {
        continue;
      }
      sortedNodes.add(node);
      for (DirectedAcyclicGraphNode<T> child : node.getChildren()) {
        sortedNodes.addAll(getAllInTopologicalOrder(child));
      }
    }
    return sortedNodes;
  }
}

class DirectedAcyclicGraphNode<T> {
  private T payload;
  private List<DirectedAcyclicGraphNode<T>> children;

  public DirectedAcyclicGraphNode(T payload) {
    this.payload = payload;
    this.children = new ArrayList<>();
  }

  // method to add a child node to the current node
  public void addChild(DirectedAcyclicGraphNode<T> child) {
    children.add(child);
  }

  // method to remove a child node from the current node
  public void removeChild(DirectedAcyclicGraphNode<T> child) {
    children.remove(child);
  }

  // method to get the parents of the current node
  public List<T> getParents() {
    return Collections.emptyList();
  }

  // method to get the children of the current node
  public List<DirectedAcyclicGraphNode<T>> getChildren() {
    return children;
  }
}"
202,"import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

public class FileSize {
  public static void main(String[] args) throws IOException {
    // Create a new Configuration object
    Configuration conf = new Configuration();

    // Set the path to the file you want to check the size of
    Path filePath = new Path(""/path/to/file"");

    // Get the FileSystem for the given path
    FileSystem fs = filePath.getFileSystem(conf);

    // Check if the file exists
    boolean exists = fs.exists(filePath);
    if (!exists) {
      System.out.println(""File does not exist"");
      return;
    }

    // Get the FileStatus for the file
    FileStatus status = fs.getFileStatus(filePath);

    // Check if the file is a directory
    boolean isDir = status.isDirectory();
    if (isDir) {
      System.out.println(""File is a directory"");
      return;
    }

    // Get the block size for the file
    long blockSize = status.getBlockSize();

    // Calculate the length of the file
    long len = fs.getLen();

    System.out.println(""File length: "" + len);
  }
}"
203,"package net.sf.marineapi.nmea.parser;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class SentenceFactoryTest {
    @Test
    void testRegisterInvalidParser() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertThrows(IllegalArgumentException.class, () -> factory.registerParser(parser));
    }

    @Test
    void testHasParser() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertFalse(factory.hasParser(parser));
    }

    @Test
    void testUnregisterParser() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);
        factory.registerParser(parser);

        // Act and Assert
        assertTrue(factory.hasParser(parser));
        factory.unregisterParser(parser);
        assertFalse(factory.hasParser(parser));
    }

    @Test
    void testCreateParserWithNull() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();

        // Act and Assert
        assertThrows(IllegalArgumentException.class, () -> factory.createParser((TalkerId) null, 0));
    }

    @Test
    void testCreateEmptyParserWithSentenceIdStr() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();

        // Act and Assert
        assertThrows(IllegalArgumentException.class, () -> factory.createParser((String) null, 0));
    }

    @Test
    void testCreateEmptyCustomParser() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();

        // Act and Assert
        assertThrows(IllegalArgumentException.class, () -> factory.createParser(TalkerId.GP, """"));
    }

    @Test
    void testCreateParserWithUnregistered() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertThrows(IllegalArgumentException.class, () -> factory.createParser(parser));
    }

    @Test
    void testCreateEmptyParserWithSentenceId() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();

        // Act and Assert
        assertThrows(IllegalArgumentException.class, () -> factory.createParser(TalkerId.GP, """"));
    }

    @Test
    void testCreateCustomParser() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertNotNull(factory.createParser(parser));
    }

    @Test
    void testRegisterParserWithAlternativeBeginChar() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertNotNull(factory.registerParser(parser, '!'));
    }

    @Test
    void testSupportedTypesRegistered() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertNotNull(factory.supportedTypes());
    }

    @Test
    void testCreateParser() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertNotNull(factory.createParser(parser));
    }

    @Test
    void testCreateParserWithRandom() {
        // Arrange
        SentenceFactory factory = new SentenceFactory();
        Parser parser = new Parser(TalkerId.GP, 1234);

        // Act and Assert
        assertNotNull(factory.createParser(parser));
    }
}"
204,"public class ChromosomeStop {
    private long tStart;
    private long qStart;
    private long tStop;
    private int blockSize;

    public ChromosomeStop(long tStart, long qStart, long tStop, int blockSize) {
        this.tStart = tStart;
        this.qStart = qStart;
        this.tStop = tStop;
        this.blockSize = blockSize;
    }

    public long getQStart() {
        return qStart;
    }

    public long getTStart() {
        return tStart;
    }

    public int getBlockSize() {
        return blockSize;
    }
}"
205,"public class CountDown implements Runnable {
    private TextView mTextView;
    private Animation mAnimation;
    private int mCurrentCount;
    private Handler mHandler;
    private int mStartCount;
    private CountDownListener mListener;

    public void cancel() {
        mHandler.removeCallbacks(this);
        mAnimation.cancel();
        mTextView.setVisibility(View.GONE);
    }

    public Animation getAnimation() {
        return mAnimation;
    }

    public void start() {
        mCurrentCount = mStartCount;
        mHandler.postDelayed(this, 1000);
        mListener.onCountDownEnd();
    }

    @Override
    public void run() {
        mCurrentCount--;
        if (mCurrentCount > 0) {
            mAnimation.setRepeatCount(Animation.RESTART);
            mAnimation.start();
            mListener.onCountDownTick(mCurrentCount);
            mHandler.postDelayed(this, 1000);
        } else {
            mAnimation.cancel();
            mTextView.setVisibility(View.GONE);
            mListener.onCountDownEnd();
        }
    }

    public void setCountDownListener(CountDownListener listener) {
        this.mListener = listener;
    }

    public void setStartCount(int startCount) {
        this.mStartCount = startCount;
    }

    public void setAnimation(Animation animation) {
        this.mAnimation = animation;
    }
}"
206,"import java.util.ArrayList;
import java.util.List;

public class JoinEstimator {
    public static long estimateNumberOfOutputRecords(Plan p1, Plan p2, String joinField) {
        IndexInfo ii = p1.getIndexInfo();
        Schema sch = p2.getSchema();
        int blocksAccessed = ii.getBlocksAccessed();
        int distinctValues = sch.getDistinctValues(joinField);
        Scan open = new Scan(p1);

        return (long) Math.ceil(open.getEstimatedNumberOfRecords() * blocksAccessed / distinctValues);
    }
}"
207,"public class MyTask {
    private String name;
    private String description;
    private long serialVersionUID;
    private String since;
    private String currentValue;
    private String defaultValue;
    private Map<String, String> map;
    private boolean spaceDelimited;
    private boolean caseSensitive;
    private boolean restartRequired;
    
    public MyTask(String name, String description, long serialVersionUID, String since, String currentValue, String defaultValue, Map<String, String> map, boolean spaceDelimited, boolean caseSensitive, boolean restartRequired) {
        this.name = name;
        this.description = description;
        this.serialVersionUID = serialVersionUID;
        this.since = since;
        this.currentValue = currentValue;
        this.defaultValue = defaultValue;
        this.map = map;
        this.spaceDelimited = spaceDelimited;
        this.caseSensitive = caseSensitive;
        this.restartRequired = restartRequired;
    }
    
    public List<String> getSpaceSeparatedStrings(String key) {
        return Arrays.asList(key.split("" ""));
    }
}"
208,"import java.util.List;

public class SentenceReader {
    private List<SentenceEvent> events;
    private List<ProviderListener<T>> listeners;

    public void clearEvents() {
        events.clear();
    }

    public void fireProviderEvent(T event) {
        if (isValid(event)) {
            listeners.forEach(listener -> listener.sentenceRead(event));
        }
    }

    public void readingStopped() {
        // ...
    }

    public boolean hasAll() {
        return events.size() == 0;
    }

    public T createProviderEvent() {
        // ...
    }

    public boolean isReady() {
        // ...
    }

    public boolean isValid(T event) {
        // ...
    }

    public boolean hasOne() {
        return events.size() == 1;
    }

    public void readingStarted() {
        // ...
    }

    public void removeListener(ProviderListener<T> listener) {
        listeners.remove(listener);
    }

    public void readingPaused() {
        // ...
    }

    public List<Sentence> getSentences() {
        return events;
    }

    public void addListener(ProviderListener<T> listener) {
        listeners.add(listener);
    }

    public boolean validate() {
        // ...
    }
}"
209,"// Set up the constructors before a test run
public class Test {
    private final ClientRWLock mClientRWLock = new ClientRWLock();
    private final Lock mReadLock = mClientRWLock.readLock();
    private final Lock mWriteLock = mClientRWLock.writeLock();

    @BeforeEach
    public void setUp() {
        // Set up the locks for each test method
        mReadLock.lockInterruptibly();
        mWriteLock.tryLockTestFail();
    }

    @AfterEach
    public void tearDown() {
        // Clean up the locks after each test method
        mReadLock.unlock();
        mWriteLock.notSameLock();
        referenceCounting();
    }
}"
21,"// Return the next available tile in the specified lane that is closest to the base.
public int nextAvailableTile(int lane) {
    // Get the lane with more enemies invading.
    int laneWithMoreEnemiesInvading = getLaneWithMoreEnemies();

    // If the specified lane has more enemies invading, return the next available tile in that lane.
    if (lane == laneWithMoreEnemiesInvading) {
        return nextAvailableTile(lane);
    }

    // Get the lane with less allies.
    int laneWithLessAllies = getLaneWithLessAllies();

    // If the specified lane has less allies, return the next available tile in that lane.
    if (lane == laneWithLessAllies) {
        return nextAvailableTile(lane);
    }

    // Get the distance between the base and the furthest tile on the specified lane.
    int tileFurthestFromBase = getTileFurthestFromBase(lane);

    // If there are no cards in the specified lane, return the next available tile.
    if (cardOnMap(lane, tileFurthestFromBase)) {
        return nextAvailableTile(lane);
    }

    // Get the enemy cards on the specified lane.
    Array<Card> enemyCards = getEnemyCards();

    // If there are no enemy cards on the specified lane, return the next available tile.
    if (enemyCards.isEmpty()) {
        return nextAvailableTile(lane);
    }

    // Get the enemy card that is closest to the base.
    Card enemyCard = getEnemyCardClosestToBase(enemyCards, lane);

    // If there are no enemy cards on the specified lane, return the next available tile.
    if (enemyCard == null) {
        return nextAvailableTile(lane);
    }

    // Return the tile that is closest to the base and farthest from the enemy card.
    int tileFarthestFromEnemy = getTileFurthestFromEnemy(lane, enemyCard);
    return tileFarthestFromBase - tileFarthestFromEnemy;
}

// Get the lane with more enemies invading.
private int getLaneWithMoreEnemies() {
    // Get all the lanes that have more enemies invading.
    List<Integer> lanesWithMoreEnemies = new ArrayList<>();
    for (int i = 0; i < tiles.length; i++) {
        if (tiles[i].size() > 1) {
            lanesWithMoreEnemies.add(i);
        }
    }

    // If there are no lanes with more enemies invading, return -1.
    if (lanesWithMoreEnemies.isEmpty()) {
        return -1;
    }

    // Return the lane with the most enemies invading.
    return Collections.max(lanesWithMoreEnemies);
}

// Get the lane with less allies.
private int getLaneWithLessAllies() {
    // Get all the lanes that have less allies.
    List<Integer> lanesWithLessAllies = new ArrayList<>();
    for (int i = 0; i < tiles.length; i++) {
        if (tiles[i].size() < 1) {
            lanesWithLessAllies.add(i);
        }
    }

    // If there are no lanes with less allies, return -1.
    if (lanesWithLessAllies.isEmpty()) {
        return -1;
    }

    // Return the lane with the least allies.
    return Collections.min(lanesWithLessAllies);
}

// Get the distance between the base and the furthest tile on the specified lane.
private int getTileFurthestFromBase(int lane) {
    // Get all the tiles on the specified lane.
    List<Integer> tilesOnLane = new ArrayList<>();
    for (int i = 0; i < tiles[lane].length; i++) {
        if (!tiles[lane][i].isEmpty()) {
            tilesOnLane.add(i);
        }
    }

    // If there are no tiles on the specified lane, return -1.
    if (tilesOnLane.isEmpty()) {
        return -1;
    }

    // Return the distance between the base and the furthest tile on the specified lane.
    return Collections.max(tilesOnLane);
}

// Get the enemy card that is closest to the base.
private Card getEnemyCardClosestToBase(Array<Card> enemyCards, int lane) {
    // If there are no enemy cards on the specified lane, return null.
    if (enemyCards.isEmpty()) {
        return null;
    }

    // Get the distance between the base and the enemy card.
    int baseToEnemyCardDistance = getTileFurthestFromBase(lane);

    // Find the enemy card that is closest to the base.
    Card closestEnemyCard = null;
    for (int i = 0; i < enemyCards.size(); i++) {
        int distance = getDistanceBetweenTiles(baseToEnemyCardDistance, lane);
        if (distance < baseToEnemyCardDistance) {
            closestEnemyCard = enemyCards.get(i);
            break;
        }
    }

    // Return the enemy card that is closest to the base.
    return closestEnemyCard;
}

// Get the distance between two tiles on the specified lane.
private int getDistanceBetweenTiles(int tile1, int tile2) {
    // Get the distance between the two tiles.
    int distance = Math.abs(tile1 - tile2);

    // Return the distance between the two tiles.
    return distance;
}

// Get the tile that is farthest from the enemy card on the specified lane.
private int getTileFurthestFromEnemy(int lane, Card enemyCard) {
    // Get all the tiles on the specified lane.
    List<Integer> tilesOnLane = new ArrayList<>();
    for (int i = 0; i < tiles[lane].length; i++) {
        if (!tiles[lane][i].isEmpty()) {
            tilesOnLane.add(i);
        }
    }

    // If there are no tiles on the specified lane, return -1.
    if (tilesOnLane.isEmpty()) {
        return -1;
    }

    // Get the distance between each tile and the enemy card.
    List<Integer> distances = new ArrayList<>();
    for (int i = 0; i < tilesOnLane.size(); i++) {
        int distance = getDistanceBetweenTiles(tilesOnLane.get(i), lane);
        distances.add(distance);
    }

    // Find the tile that is farthest from the enemy card.
    int furthestTile = tilesOnLane.get(0);
    for (int i = 1; i < distances.size(); i++) {
        if (distances.get(i) > distances.get(furthestTile)) {
            furthestTile = i;
        }
    }

    // Return the tile that is farthest from the enemy card on the specified lane.
    return furthestTile;
}"
210,"// Import necessary classes and interfaces
import java.util.Date;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class Time {
    private int hour;
    private int minutes;
    private double seconds;
    private int offsetHours;
    private int offsetMinutes;

    // Define the TIME_PATTERN constant
    public static final String TIME_PATTERN = ""HH:mm:ss"";

    // Constructor to set the time values
    public Time(int hour, int minutes, double seconds) {
        this.hour = hour;
        this.minutes = minutes;
        this.seconds = seconds;
    }

    // Method to set the offset hours
    public void setOffsetHours(int offsetHours) {
        this.offsetHours = offsetHours;
    }

    // Method to get the offset hours
    public int getOffsetHours() {
        return offsetHours;
    }

    // Method to set the offset minutes
    public void setOffsetMinutes(int offsetMinutes) {
        this.offsetMinutes = offsetMinutes;
    }

    // Method to get the offset minutes
    public int getOffsetMinutes() {
        return offsetMinutes;
    }

    // Method to get the time in seconds
    public double getSeconds() {
        return seconds;
    }

    // Method to set the time in seconds
    public void setSeconds(double seconds) {
        this.seconds = seconds;
    }

    // Method to get the time in minutes
    public int getMinutes() {
        return minutes;
    }

    // Method to set the time in minutes
    public void setMinutes(int minutes) {
        this.minutes = minutes;
    }

    // Method to convert the time to a Date object
    public Date toDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeZone(TimeZone.getTimeZone(""UTC""));
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minutes);
        calendar.set(Calendar.SECOND, (int) seconds);
        return calendar.getTime();
    }

    // Method to convert the time to an ISO 8601 string
    public String toISO8601() {
        SimpleDateFormat formatter = new SimpleDateFormat(TIME_PATTERN);
        formatter.setTimeZone(TimeZone.getTimeZone(""UTC""));
        return formatter.format(toDate());
    }

    // Method to set the time in milliseconds
    public void setMilliseconds(long milliseconds) {
        this.milliseconds = milliseconds;
    }

    // Method to get the time in milliseconds
    public long getMilliseconds() {
        return milliseconds;
    }

    // Method to calculate the hash code of the object
    @Override
    public int hashCode() {
        return Objects.hash(hour, minutes, seconds);
    }

    // Method to check if the object is equal to another object
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof Time)) {
            return false;
        }
        Time other = (Time) obj;
        return this.hour == other.hour && this.minutes == other.minutes && this.seconds == other.seconds;
    }
}"
211,"// Factory for Evictor
public class EvictorFactory {
    // Method to create a new instance of Evictor
    public static Evictor createEvictor(PlaceHolder placeHolder, EvictionPlan freeSpaceWithView) {
        return new Evictor(placeHolder, freeSpaceWithView);
    }
}"
212,"// Token.java

import java.util.List;

public class Token {
    private long issuedAt;
    private List<OAuthPermission> scopes;
    private UserSubject subject;
    private Client client;
    private boolean preAuthorized;
    private String tokenString;
    private long lifetime;
    private String tokenSecret;

    public Token(long issuedAt, List<OAuthPermission> scopes, UserSubject subject, Client client, boolean preAuthorized, String tokenString, long lifetime, String tokenSecret) {
        this.issuedAt = issuedAt;
        this.scopes = scopes;
        this.subject = subject;
        this.client = client;
        this.preAuthorized = preAuthorized;
        this.tokenString = tokenString;
        this.lifetime = lifetime;
        this.tokenSecret = tokenSecret;
    }

    public long getIssuedAt() {
        return issuedAt;
    }

    public List<OAuthPermission> getScopes() {
        return scopes;
    }

    public UserSubject getSubject() {
        return subject;
    }

    public Client getClient() {
        return client;
    }

    public boolean isPreAuthorized() {
        return preAuthorized;
    }

    public String getTokenKey() {
        return tokenString;
    }

    public long getLifetime() {
        return lifetime;
    }

    public String getTokenSecret() {
        return tokenSecret;
    }

    public void setScopes(List<OAuthPermission> scopes) {
        this.scopes = scopes;
    }

    public void setSubject(UserSubject subject) {
        this.subject = subject;
    }

    public void setPreAuthorized(boolean preAuthorized) {
        this.preAuthorized = preAuthorized;
    }

    public void setTokenKey(String tokenString) {
        this.tokenString = tokenString;
    }

    public void setLifetime(long lifetime) {
        this.lifetime = lifetime;
    }

    public void setTokenSecret(String tokenSecret) {
        this.tokenSecret = tokenSecret;
    }
}"
213,"[PYTHON]
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class IterableUtils {
    public static <T> List<T> toList(Iterable<T> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false).collect(Collectors.toList());
    }

    public static <F, T> Iterable<T> filter(Iterable<F> iterable, Predicate<? super F> filter) {
        return () -> iterable.iterator().filter(filter);
    }

    public static <F, T> Iterable<T> map(Iterable<F> iterable, Mapper<? super F, T> mapper) {
        return () -> iterable.iterator().map(mapper);
    }

    public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate) {
        return iterable.iterator().all(predicate);
    }

    public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate) {
        return iterable.iterator().any(predicate);
    }

    public static <T> Iterator<T> iterator(Iterable<T> iterable) {
        return iterable.iterator();
    }
}
[/PYTHON]
[TESTS]
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;

class IterableUtilsTest {
    @Test
    void testToList() {
        List<String> list = Arrays.asList(""hello"", ""world"");
        assertEquals(list, IterableUtils.toList(list));
    }

    @Test
    void testFilter() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Predicate<Integer> predicate = x -> x % 2 == 0;
        assertEquals(Arrays.asList(2, 4), IterableUtils.filter(numbers, predicate));
    }

    @Test
    void testMap() {
        List<String> words = Arrays.asList(""hello"", ""world"");
        Mapper<String, String> mapper = x -> x + ""!"";
        assertEquals(Arrays.asList(""hello!"", ""world!""), IterableUtils.map(words, mapper));
    }

    @Test
    void testAll() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Predicate<Integer> predicate = x -> x >= 0;
        assertTrue(IterableUtils.all(numbers, predicate));
    }

    @Test
    void testAny() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Predicate<Integer> predicate = x -> x % 2 == 0;
        assertTrue(IterableUtils.any(numbers, predicate));
    }

    @Test
    void testIterator() {
        List<String> words = Arrays.asList(""hello"", ""world"");
        Iterator<String> iterator = IterableUtils.iterator(words);
        assertEquals(""hello"", iterator.next());
        assertEquals(""world"", iterator.next());
    }
}
[/TESTS]"
214,"public interface PortalUserDao {
    public Collection<String> getUserAuthorities(int userId);
}

public class NamedParameterJdbcTemplate implements PortalUserDao {
    private final Log log;
    
    public NamedParameterJdbcTemplate(Log log) {
        this.log = log;
    }
    
    @Override
    public Collection<String> getUserAuthorities(int userId) {
        // Implementation goes here
    }
}

public class PortalUser {
    private int id;
    private String username;
    private String password;
    private List<PortalUserAuthority> authorities;
    
    public void addPortalUser(int id, String username, String password) {
        // Implementation goes here
    }
    
    public void addPortalUserAuthorities(int userId, Collection<String> authorities) {
        // Implementation goes here
    }
    
    public User getPortalUser(int id) {
        // Implementation goes here
    }
}"
215,"[PYTHON]
import numpy as np
from scipy.linalg import svd, lu, cholesky
from scipy.sparse.linalg import lsqr

def optimize_eigendecomposition(A, tol=1e-8):
    # Check if input matrix is symmetric within tolerance
    if np.allclose(A, A.T, atol=tol):
        # Use symmetric algorithm if input matrix is symmetric within tolerance
        return svd(A)
    else:
        # Otherwise use general purpose eigenvalue decomposition
        return lu(A)
[/PYTHON]
[R]
library(Matrix)
library(numDeriv)

optimize_eigendecomposition <- function(A, tol = 1e-8) {
  # Check if input matrix is symmetric within tolerance
  if (is.symmetric(A, tol)) {
    # Use symmetric algorithm if input matrix is symmetric within tolerance
    svd(A)
  } else {
    # Otherwise use general purpose eigenvalue decomposition
    lu(A)
  }
}
[/R]
[MATLAB]
function [V, D, VD] = optimize_eigendecomposition(A, tol)
  % Check if input matrix is symmetric within tolerance
  if issym(A, tol)
    % Use symmetric algorithm if input matrix is symmetric within tolerance
    [V, D] = svd(A);
  else
    % Otherwise use general purpose eigenvalue decomposition
    [VD, V] = lu(A);
  end
end
[/MATLAB]
[GNU Octave]
function [V, D, VD] = optimize_eigendecomposition(A, tol)
  % Check if input matrix is symmetric within tolerance
  if issym(A, tol)
    % Use symmetric algorithm if input matrix is symmetric within tolerance
    [V, D] = svd(A);
  else
    % Otherwise use general purpose eigenvalue decomposition
    [VD, V] = lu(A);
  end
end
[/GNU Octave]
[Julia]
function (V, D, VD) = optimize_eigendecomposition(A, tol)
  # Check if input matrix is symmetric within tolerance
  if issymmetric(A, tol)
    # Use symmetric algorithm if input matrix is symmetric within tolerance
    [V, D] = svd(A);
  else
    # Otherwise use general purpose eigenvalue decomposition
    [VD, V] = lu(A);
  end
end
[/Julia]
[Sage]
def optimize_eigendecomposition(A, tol):
    if A.is_symmetric(tol):
        # Use symmetric algorithm if input matrix is symmetric within tolerance
        return svd(A)
    else:
        # Otherwise use general purpose eigenvalue decomposition
        return lu(A)
[/Sage]
[Maxima]
optimize_eigendecomposition (A, tol):= block (tol, is_symmetric)
  is_symmetric := A.is_symmetric(tol);
  if is_symmetric then
    return svd(A);
  else
    return lu(A);
  end if;
end;
[/Maxima]
[Python 3]
from numpy import linalg as la
def optimize_eigendecomposition(A, tol=1e-8):
    is_symmetric = np.allclose(A, A.T, atol=tol)
    if is_symmetric:
        return la.svd(A)
    else:
        return la.lu(A)
[/Python 3]
[Rust]
use nalgebra::Matrix;

fn optimize_eigendecomposition(mat: Matrix<f64>) -> (Matrix<f64>, Matrix<f64>) {
    if mat.is_symmetric() {
        let svd = mat.svd();
        (svd.v, svd.d)
    } else {
        let lu = mat.lu();
        (lu.p, lu.l)
    }
}
[/Rust]"
216,"import java.util.ArrayList;
import java.util.List;

public class ComparisonListener {
    private List<ComparisonListener> matchListeners = new ArrayList<>();
    private List<ComparisonListener> compListeners = new ArrayList<>();
    private List<ComparisonListener> diffListeners = new ArrayList<>();

    public void addMatchListener(ComparisonListener listener) {
        this.matchListeners.add(listener);
    }

    public void addDifferenceListener(ComparisonListener listener) {
        this.diffListeners.add(listener);
    }

    public void fireComparisonPerformed(ComparisonEvent event) {
        if (event.getType() == ComparisonEvent.Type.MATCH) {
            for (ComparisonListener listener : matchListeners) {
                listener.comparisonPerformed(event);
            }
        } else if (event.getType() == ComparisonEvent.Type.COMPARISON) {
            for (ComparisonListener listener : compListeners) {
                listener.comparisonPerformed(event);
            }
        } else if (event.getType() == ComparisonEvent.Type.DIFFERENCE) {
            for (ComparisonListener listener : diffListeners) {
                listener.comparisonPerformed(event);
            }
        }
    }
}"
217,"[PYTHON]
class DataServerMessage:
    def __init__(self, m_id):
        self.m_id = m_id

    def encode(self):
        pass

    @staticmethod
    def createFrameDecoder():
        pass

    @property
    def type(self):
        return self.m_id

    @property
    def payload_data_buffer(self):
        return None

    @property
    def rpc_message(self):
        return None

    @property
    def has_payload(self):
        return False

    @property
    def decode(self):
        return self.m_id

    @property
    def get_encoded_length(self):
        return 0

    @staticmethod
    def validate(msg):
        pass
[/PYTHON]
[TESTS]
# Test case 1:
assert DataServerMessage(1).type == 1
# Test case 2:
assert DataServerMessage(2).payload_data_buffer is None
# Test case 3:
assert not DataServerMessage(3).has_payload
# Test case 4:
assert DataServerMessage(4).decode == 4
# Test case 5:
assert DataServerMessage(5).get_encoded_length() == 0
[/TESTS]"
218,"import java.util.ArrayList;
import java.util.List;

public class Matrix {
    private List<List<Double>> matrix;

    public Matrix(int rows, int cols) {
        this.matrix = new ArrayList<>();
        for (int i = 0; i < rows; i++) {
            List<Double> row = new ArrayList<>();
            for (int j = 0; j < cols; j++) {
                row.add(new Double(0));
            }
            matrix.add(row);
        }
    }

    public Matrix add(Matrix other) {
        if (this.matrix.size() != other.matrix.size() || this.matrix.get(0).size() != other.matrix.get(0).size()) {
            throw new IllegalArgumentException(""Matrices must be of the same size to be added"");
        }

        Matrix result = new Matrix(this.matrix.size(), this.matrix.get(0).size());
        for (int i = 0; i < this.matrix.size(); i++) {
            List<Double> row1 = this.matrix.get(i);
            List<Double> row2 = other.matrix.get(i);
            List<Double> resultRow = new ArrayList<>();
            for (int j = 0; j < row1.size(); j++) {
                resultRow.add(row1.get(j) + row2.get(j));
            }
            result.matrix.add(resultRow);
        }
        return result;
    }

    public Matrix subtract(Matrix other) {
        if (this.matrix.size() != other.matrix.size() || this.matrix.get(0).size() != other.matrix.get(0).size()) {
            throw new IllegalArgumentException(""Matrices must be of the same size to be subtracted"");
        }

        Matrix result = new Matrix(this.matrix.size(), this.matrix.get(0).size());
        for (int i = 0; i < this.matrix.size(); i++) {
            List<Double> row1 = this.matrix.get(i);
            List<Double> row2 = other.matrix.get(i);
            List<Double> resultRow = new ArrayList<>();
            for (int j = 0; j < row1.size(); j++) {
                resultRow.add(row1.get(j) - row2.get(j));
            }
            result.matrix.add(resultRow);
        }
        return result;
    }

    public Matrix multiply(Matrix other) {
        if (this.matrix.get(0).size() != other.matrix.size()) {
            throw new IllegalArgumentException(""Matrices must be compatible for multiplication"");
        }

        Matrix result = new Matrix(this.matrix.size(), other.matrix.get(0).size());
        for (int i = 0; i < this.matrix.size(); i++) {
            List<Double> row1 = this.matrix.get(i);
            for (int j = 0; j < other.matrix.get(0).size(); j++) {
                double sum = 0;
                for (int k = 0; k < row1.size(); k++) {
                    sum += row1.get(k) * other.matrix.get(k).get(j);
                }
                result.matrix.get(i).add(sum);
            }
        }
        return result;
    }

    public Matrix inverse() {
        double determinant = this.determinant();
        if (determinant == 0) {
            throw new ArithmeticException(""Determinant is zero, matrix cannot be inverted"");
        }

        Matrix result = new Matrix(this.matrix.size(), this.matrix.get(0).size());
        for (int i = 0; i < this.matrix.size(); i++) {
            for (int j = 0; j < this.matrix.get(i).size(); j++) {
                result.matrix.get(i).set(j, this.matrix.get(i).get(j) / determinant);
            }
        }
        return result;
    }

    public Matrix transpose() {
        Matrix result = new Matrix(this.matrix.get(0).size(), this.matrix.size());
        for (int i = 0; i < this.matrix.size(); i++) {
            List<Double> row1 = this.matrix.get(i);
            for (int j = 0; j < row1.size(); j++) {
                result.matrix.get(j).set(i, row1.get(j));
            }
        }
        return result;
    }

    public double determinant() {
        if (this.matrix.size() == 1) {
            return this.matrix.get(0).get(0);
        } else if (this.matrix.size() == 2) {
            return this.matrix.get(0).get(0) * this.matrix.get(1).get(1) - this.matrix.get(0).get(1) * this.matrix.get(1).get(0);
        } else {
            double determinant = 0;
            for (int i = 0; i < this.matrix.size(); i++) {
                List<Double> row = this.matrix.get(i);
                determinant += ((i % 2 == 0) ? 1 : -1) * row.get(0) * this.subMatrix(i).determinant();
            }
            return determinant;
        }
    }

    public Matrix subMatrix(int rowIndex) {
        Matrix result = new Matrix(this.matrix.size() - 1, this.matrix.get(0).size());
        for (int i = 0; i < this.matrix.size(); i++) {
            if (i == rowIndex) continue;
            List<Double> row1 = this.matrix.get(i);
            List<Double> resultRow = new ArrayList<>();
            for (int j = 0; j < row1.size(); j++) {
                resultRow.add(row1.get(j));
            }
            result.matrix.add(resultRow);
        }
        return result;
    }
}"
219,"import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.security.oauth2.client.OAuth2RestTemplate;
import org.springframework.security.oauth2.client.resource.OAuth2ProtectedResourceDetails;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableOAuth2Client;
import org.springframework.security.oauth2.provider.authentication.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.IntrospectionConfigurationService;
import org.springframework.security.oauth2.provider.token.TokenCacheObject;
import org.springframework.util.Assert;

@EnableOAuth2Client
public class OAuth2RestTemplateConfig {

    @Bean
    public OAuth2RestTemplate oauth2RestTemplate(OAuth2ProtectedResourceDetails resource, HttpComponentsClientHttpRequestFactory factory) {
        return new OAuth2RestTemplate(resource, factory);
    }

    @Bean
    public IntrospectionConfigurationService introspectionConfigurationService() {
        return new IntrospectionConfigurationService();
    }

    @Bean
    public OAuth2Authentication loadAuthentication(IntrospectionAuthorityGranter introspectionAuthorityGranter) {
        return new OAuth2Authentication(introspectionAuthorityGranter);
    }

    @Bean
    public TokenCacheObject parseToken() {
        return new TokenCacheObject();
    }

    @Bean
    public Authentication createAuthentication(OAuth2AccessToken token) {
        return null;
    }

    @Bean
    public IntrospectionAuthorityGranter getIntrospectionAuthorityGranter() {
        return new IntrospectionAuthorityGranter();
    }

    @Bean
    public OAuth2AccessToken readAccessToken(TokenCacheObject cache, boolean cacheNonExpiringTokens) {
        return null;
    }

    @Bean
    public TokenCacheObject checkCache(Date cacheExpire, boolean isCacheTokens) {
        return new TokenCacheObject();
    }
}"
22,"public class Matrix {
    private int[][] data;

    public Matrix(int rows, int cols) {
        this.data = new int[rows][cols];
    }

    public Matrix inverse() {
        if (this.getRows() != this.getCols()) {
            throw new IllegalArgumentException(""Inverse of non-square matrix not supported"");
        }

        Matrix identity = Matrix.identity(this.getRows());
        Matrix current = this;
        while (!current.equals(identity)) {
            current = current.add(current.cofactor().multiply(changeSign()));
        }

        return current;
    }

    public int[][] getData() {
        return data;
    }

    public void setData(int[][] data) {
        this.data = data;
    }

    public int getRows() {
        return data.length;
    }

    public int getCols() {
        if (data.length == 0) {
            return 0;
        }
        return data[0].length;
    }

    public Matrix add(Matrix matrix) {
        if (this.getRows() != matrix.getRows() || this.getCols() != matrix.getCols()) {
            throw new IllegalArgumentException(""Incompatible matrices"");
        }

        int[][] result = new int[this.getRows()][this.getCols()];
        for (int i = 0; i < this.getRows(); i++) {
            for (int j = 0; j < this.getCols(); j++) {
                result[i][j] = this.data[i][j] + matrix.data[i][j];
            }
        }

        return new Matrix(result);
    }

    public Matrix subtract(Matrix matrix) {
        if (this.getRows() != matrix.getRows() || this.getCols() != matrix.getCols()) {
            throw new IllegalArgumentException(""Incompatible matrices"");
        }

        int[][] result = new int[this.getRows()][this.getCols()];
        for (int i = 0; i < this.getRows(); i++) {
            for (int j = 0; j < this.getCols(); j++) {
                result[i][j] = this.data[i][j] - matrix.data[i][j];
            }
        }

        return new Matrix(result);
    }

    public Matrix multiply(Matrix matrix) {
        if (this.getCols() != matrix.getRows()) {
            throw new IllegalArgumentException(""Incompatible matrices"");
        }

        int[][] result = new int[this.getRows()][matrix.getCols()];
        for (int i = 0; i < this.getRows(); i++) {
            for (int j = 0; j < matrix.getCols(); j++) {
                for (int k = 0; k < this.getCols(); k++) {
                    result[i][j] += this.data[i][k] * matrix.data[k][j];
                }
            }
        }

        return new Matrix(result);
    }

    public Matrix createSubMatrix(int row, int col) {
        if (row < 0 || row >= this.getRows() || col < 0 || col >= this.getCols()) {
            throw new IndexOutOfBoundsException(""Invalid sub-matrix indices"");
        }

        int[][] result = new int[this.getRows() - 1][this.getCols() - 1];
        for (int i = 0; i < this.getRows(); i++) {
            for (int j = 0; j < this.getCols(); j++) {
                if (i == row || j == col) {
                    continue;
                }
                result[i - (i > row ? 1 : 0)][j - (j > col ? 1 : 0)] = this.data[i][j];
            }
        }

        return new Matrix(result);
    }

    public double determinant() {
        if (this.getRows() != this.getCols()) {
            throw new IllegalArgumentException(""Determinant of non-square matrix not supported"");
        }

        if (this.getRows() == 1) {
            return this.data[0][0];
        } else if (this.getRows() == 2) {
            return this.data[0][0] * this.data[1][1] - this.data[0][1] * this.data[1][0];
        } else {
            double det = 0;
            for (int i = 0; i < this.getRows(); i++) {
                det += Math.pow(-1, i) * this.data[0][i] * this.createSubMatrix(0, i).determinant();
            }
            return det;
        }
    }

    public Matrix cofactor() {
        if (this.getRows() != this.getCols()) {
            throw new IllegalArgumentException(""Cofactor of non-square matrix not supported"");
        }

        int[][] result = new int[this.getRows()][this.getCols()];
        for (int i = 0; i < this.getRows(); i++) {
            for (int j = 0; j < this.getCols(); j++) {
                result[i][j] = Math.pow(-1, i + j) * this.createSubMatrix(i, j).determinant();
            }
        }

        return new Matrix(result);
    }

    public static Matrix identity(int size) {
        int[][] data = new int[size][size];
        for (int i = 0; i < size; i++) {
            data[i][i] = 1;
        }

        return new Matrix(data);
    }

    public static double changeSign() {
        return -1;
    }
}"
220,"package com.fileutils;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class FileUtils {
    public static void main(String[] args) {
        String pattern = ""patternToFind"";
        String fileNameWithoutExtension = getFileNameWithoutExtension(""file.txt"");
        List<DataSource> files = collectFiles(""path/to/files"", pattern);
        for (DataSource file : files) {
            System.out.println(file.getName());
        }
    }

    private static String getFileNameWithoutExtension(String fileName) {
        int index = fileName.lastIndexOf(""."");
        return fileName.substring(0, index);
    }

    private static List<DataSource> collectFiles(String path, String pattern) {
        File folder = new File(path);
        List<File> files = new ArrayList<>();
        for (File file : folder.listFiles()) {
            if (file.isDirectory()) {
                files.addAll(collectFiles(file.getAbsolutePath(), pattern));
            } else {
                String fileName = normalizeFilename(file.getName());
                if (fileName.contains(pattern)) {
                    files.add(new DataSource(fileName, file));
                }
            }
        }
        return files;
    }

    private static String normalizeFilename(String fileName) {
        // remove any duplicate or trailing slashes from the filename
        return fileName.replaceAll(""[/\\\\]+$"", """");
    }
}"
221,"import javax.servlet.*;

public class MyDAVProcessor implements DAVProcessor {
    private final ServletContext context;
    private final DAVLogger logger;
    private final DAVRepository repository;
    private final ServletConfig config;

    public MyDAVProcessor(ServletContext context) {
        this.context = context;
        this.logger = new DAVLogger(context);
        this.repository = new DAVRepository(context, logger);
        this.config = context.getServletConfig();
    }

    @Override
    public void init() throws ServletException {
        // Initialize the repository and set up any necessary data structures
        repository.init();
    }

    @Override
    public void service(DAVRequest request, DAVResponse response) throws IOException {
        // Process the request using the repository
        String repositoryKey = getRepositoryKey(request);
        repository.service(repositoryKey, request, response);
    }

    @Override
    public void destroy() {
        // Clean up any resources used by the repository
        repository.destroy();
    }

    @Override
    public String getServletInfo() {
        return ""MyDAVProcessor"";
    }

    private String getRepositoryKey(DAVRequest request) {
        // Determine the key for the repository based on the request
        return request.getPath();
    }
}"
222,"import java.util.List;

public class RecordComparator implements Comparator<Record> {
    @Override
    public int compare(Record r1, Record r2) {
        // compare the records based on their schema
        return 0;
    }
}

public class Transaction {
    private List<TempTable> sortedTables;

    public Transaction() {
        this.sortedTables = new ArrayList<>();
    }

    public void addSortedTable(TempTable table) {
        this.sortedTables.add(table);
    }

    public List<TempTable> getSortedTables() {
        return this.sortedTables;
    }
}

public class TempTable {
    private Schema schema;

    public TempTable(Schema schema) {
        this.schema = schema;
    }

    public Schema getSchema() {
        return this.schema;
    }
}

public class Scan {
    private List<TempTable> tables;
    private int blocksAccessed;
    private int distinctValues;
    private int recordsOutput;
    private boolean copy;
    private List<TempTable> splitIntoRuns;

    public Scan(List<TempTable> tables, int blocksAccessed, int distinctValues, int recordsOutput, boolean copy) {
        this.tables = tables;
        this.blocksAccessed = blocksAccessed;
        this.distinctValues = distinctValues;
        this.recordsOutput = recordsOutput;
        this.copy = copy;
    }

    public List<TempTable> getTables() {
        return this.tables;
    }

    public int getBlocksAccessed() {
        return this.blocksAccessed;
    }

    public int getDistinctValues() {
        return this.distinctValues;
    }

    public int getRecordsOutput() {
        return this.recordsOutput;
    }

    public boolean isCopy() {
        return this.copy;
    }

    public List<TempTable> splitIntoRuns() {
        // implement the splitting logic here
        return null;
    }
}

public class MergeSort {
    private Scan scan;

    public MergeSort(Scan scan) {
        this.scan = scan;
    }

    public void mergeSort() {
        // implement the mergesort logic here
    }
}"
223,"import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class LogEntryRequestTest {
    private LogEntryRequest logEntryRequest;

    @BeforeEach
    void setup() {
        logEntryRequest = new LogEntryRequest();
    }

    @Test
    void testSetDuration() {
        long duration = 10L;
        logEntryRequest.setDuration(duration);
        assertEquals(duration, logEntryRequest.getDuration());
    }

    @Test
    void testGetResponseStringCsv() {
        String responseString = ""response"";
        logEntryRequest.setResponseStringCsv(responseString);
        assertEquals(responseString, logEntryRequest.getResponseStringCsv());
    }

    @Test
    void testGetTsSend() {
        long tsSend = 10L;
        logEntryRequest.setTsSend(tsSend);
        assertEquals(tsSend, logEntryRequest.getTsSend());
    }

    @Test
    void testGetTsReceived() {
        long tsReceived = 20L;
        logEntryRequest.setTsReceived(tsReceived);
        assertEquals(tsReceived, logEntryRequest.getTsReceived());
    }

    @Test
    void testSetResponseString() {
        String responseString = ""response"";
        logEntryRequest.setResponseString(responseString);
        assertEquals(responseString, logEntryRequest.getResponseString());
    }

    @Test
    void testGetFaultFlag() {
        boolean faultFlag = true;
        logEntryRequest.setFaultFlag(faultFlag);
        assertEquals(faultFlag, logEntryRequest.getFaultFlag());
    }

    @Test
    void testSetFaultFlag() {
        boolean faultFlag = false;
        logEntryRequest.setFaultFlag(faultFlag);
        assertEquals(faultFlag, logEntryRequest.getFaultFlag());
    }

    @Test
    void testGetErrorFlag() {
        boolean errorFlag = true;
        logEntryRequest.setErrorFlag(errorFlag);
        assertEquals(errorFlag, logEntryRequest.getErrorFlag());
    }

    @Test
    void testSetThreadNumber() {
        int threadNumber = 10;
        logEntryRequest.setThreadNumber(threadNumber);
        assertEquals(threadNumber, logEntryRequest.getThreadNumber());
    }

    @Test
    void testSetTsSend() {
        long tsSend = 10L;
        logEntryRequest.setTsSend(tsSend);
        assertEquals(tsSend, logEntryRequest.getTsSend());
    }

    @Test
    void testSetTsReceived() {
        long tsReceived = 20L;
        logEntryRequest.setTsReceived(tsReceived);
        assertEquals(tsReceived, logEntryRequest.getTsReceived());
    }

    @Test
    void testGetDuration() {
        long duration = 10L;
        logEntryRequest.setDuration(duration);
        assertEquals(duration, logEntryRequest.getDuration());
    }

    @Test
    void testGetThreadNumber() {
        int threadNumber = 10;
        logEntryRequest.setThreadNumber(threadNumber);
        assertEquals(threadNumber, logEntryRequest.getThreadNumber());
    }
}"
224,"public boolean moveNext() {
    // Move to the next index record if possible
    if (idx.hasNext()) {
        idx.next();
        return true;
    }

    // If there are no more index records, move to the next LHS record and reset the index
    else if (ts.hasNext()) {
        ts.next();
        resetIndex();
        return true;
    }

    // If there are no more LHS records, return false
    else {
        close();
        return false;
    }
}"
225,"package com.example;

import java.util.List;

public class PopulationCovariance {
    private StatsAccumulator yStats;
    private StatsAccumulator xStats;
    private long count = 0;

    public PopulationCovariance() {}

    public void add(double value) {
        this.yStats.add(value);
        this.xStats.add(value);
        this.count++;
    }

    public void addAll(List<Double> values) {
        for (double value : values) {
            this.yStats.add(value);
            this.xStats.add(value);
            this.count++;
        }
    }

    public double sampleCovariance() {
        if (this.count < 2) {
            return Double.NaN;
        } else {
            return this.yStats.mean() * this.xStats.mean();
        }
    }

    public double ensurePositive(double value) {
        return Math.max(value, 0);
    }

    public double ensureInUnitRange(double value) {
        if (value < 0 || value > 1) {
            return Double.NaN;
        } else {
            return value;
        }
    }

    public long count() {
        return this.count;
    }

    public double pearsonsCorrelationCoefficient() {
        double covariance = this.sampleCovariance();
        if (covariance == Double.NaN) {
            return Double.NaN;
        } else {
            return covariance / Math.sqrt(this.xStats.variance()) * Math.sqrt(this.yStats.variance());
        }
    }

    public LinearTransformation leastSquaresFit() {
        double[] x = this.xStats.snapshot();
        double[] y = this.yStats.snapshot();
        return new LinearTransformation(new LeastSquaresRegression(x, y));
    }
}"
226,"package net.sf.marineapi.nmea.parser;

import java.time.Instant;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.temporal.ChronoField;
import java.util.Calendar;
import static org.junit.Assert.*;
import org.junit.Test;

public class ZDAParserTest {
    private final ZDAParser zda = new ZDAParser();

    @Test
    public void testGetYear() {
        assertEquals(1900, zda.getYear());
    }

    @Test
    public void testGetDate() {
        assertEquals(1, zda.getDay());
        assertEquals(1, zda.getMonth());
    }

    @Test
    public void testSetTimeAndLocalZone() {
        zda.setTime(OffsetDateTime.now().toInstant());
        assertNotNull(zda.getLocalZoneMinutes());
        assertNotNull(zda.getLocalZoneHours());
    }

    @Test
    public void testConstructor() {
        ZDAParser zda2 = new ZDAParser(""180915"");
        assertEquals(18, zda2.getYear());
        assertEquals(9, zda2.getMonth());
        assertEquals(15, zda2.getDay());
    }

    @Test
    public void testGetTime() {
        Instant instant = OffsetDateTime.now().toInstant();
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(instant.toEpochMilli());
        assertEquals(calendar.get(ChronoField.HOUR_OF_DAY), zda.getHours());
        assertEquals(calendar.get(ChronoField.MINUTE_OF_HOUR), zda.getMinutes());
    }

    @Test
    public void testToDate() {
        OffsetDateTime date = OffsetDateTime.now();
        ZDAParser zda2 = new ZDAParser(""180915"");
        assertEquals(date.getYear(), zda2.toDate().getYear());
        assertEquals(date.getMonthValue(), zda2.toDate().getMonthValue());
        assertEquals(date.getDayOfMonth(), zda2.toDate().getDayOfMonth());
    }

    @Test
    public void testSetLocalZoneMinutes() {
        zda.setLocalZoneMinutes(30);
        assertNotNull(zda.getLocalZoneMinutes());
    }

    @Test
    public void testSetLocalZoneHours() {
        zda.setLocalZoneHours(3);
        assertNotNull(zda.getLocalZoneHours());
    }

    @Test
    public void testSetTime() {
        OffsetDateTime date = OffsetDateTime.now();
        ZDAParser zda2 = new ZDAParser(""180915"");
        zda2.setTime(date);
        assertEquals(date.getYear(), zda2.toDate().getYear());
        assertEquals(date.getMonthValue(), zda2.toDate().getMonthValue());
        assertEquals(date.getDayOfMonth(), zda2.toDate().getDayOfMonth());
    }

    @Test
    public void testGetDay() {
        assertEquals(1, zda.getDay());
    }

    @Test
    public void testGetMonth() {
        assertEquals(1, zda.getMonth());
    }

    @Test
    public void testSetDate() {
        ZDAParser zda2 = new ZDAParser(""180915"");
        zda2.setDate(Calendar.getInstance());
        assertNotNull(zda2.toDate().getYear());
        assertNotNull(zda2.toDate().getMonthValue());
        assertNotNull(zda2.toDate().getDayOfMonth());
    }
}"
227,"public class Batch {
    private long batchId;
    private String batchStatus;
    private Long totalElapsedSeconds;
    private List<TestResultDTO> testResultLst;
    private String startTime;
    private String endTime;
    
    public void setBatchId(Long batchId) {
        this.batchId = batchId;
    }
    
    public Long getBatchId() {
        return batchId;
    }
    
    public void setTotalElapsedSeconds(Long totalElapsedSeconds) {
        this.totalElapsedSeconds = totalElapsedSeconds;
    }
    
    public Long getTotalElapsedSeconds() {
        return totalElapsedSeconds;
    }
    
    public void setTestResultLst(List<TestResultDTO> testResultLst) {
        this.testResultLst = testResultLst;
    }
    
    public List<TestResultDTO> getTestResultLst() {
        return testResultLst;
    }
    
    public void setStartTime(String startTime) {
        this.startTime = startTime;
    }
    
    public String getStartTime() {
        return startTime;
    }
    
    public void setEndTime(String endTime) {
        this.endTime = endTime;
    }
    
    public String getEndTime() {
        return endTime;
    }
    
    public void setBatchStatus(String batchStatus) {
        this.batchStatus = batchStatus;
    }
    
    public String getBatchStatus() {
        return batchStatus;
    }
    
    public Long getTotalElapsedMinutes() {
        if (totalElapsedSeconds == null) {
            return null;
        } else {
            return totalElapsedSeconds / 60L;
        }
    }
    
    public void setTotalElapsedMinutes(Long totalElapsedMinutes) {
        this.totalElapsedMinutes = totalElapsedMinutes;
    }
}"
228,"// Java code for the task: returns true if the specified field is in the schema
public class Schema {
    private Map<String, FieldInfo> info;

    public boolean hasField(String field) {
        return info.containsKey(field);
    }
}

// Java code for the task: int length -> int type -> Map<String,FieldInfo> info | void add -> void addStringField -> void addAll -> void addField -> void addIntField -> int length -> Collection<String> fields -> int type
public class FieldInfo {
    private String fieldName;
    private int type;

    public FieldInfo(String fieldName, int type) {
        this.fieldName = fieldName;
        this.type = type;
    }

    public void addField(String fieldName, int type) {
        // Add the field to the schema with the specified name and type
        info.put(fieldName, new FieldInfo(fieldName, type));
    }

    public void addAll(Map<String, FieldInfo> fields) {
        // Add all the fields from the input map to the schema
        for (Map.Entry<String, FieldInfo> entry : fields.entrySet()) {
            String fieldName = entry.getKey();
            int type = entry.getValue().type;
            addField(fieldName, type);
        }
    }

    public void addIntField(String fieldName) {
        // Add an integer field with the specified name to the schema
        info.put(fieldName, new FieldInfo(fieldName, Type.INT));
    }

    public void addStringField(String fieldName) {
        // Add a string field with the specified name to the schema
        info.put(fieldName, new FieldInfo(fieldName, Type.STRING));
    }

    public int length() {
        // Return the number of fields in the schema
        return info.size();
    }

    public Collection<String> fields() {
        // Return a collection of field names in the schema
        return info.keySet();
    }
}"
229,"import java.util.Set;

public class FileManager {
    private Set<InodeFile> mFiles;
    private long sTtlIntervalMs;
    private long mTtlIntervalStartTimeMs;

    public void removeFile(long fileId) {
        // Remove the file from the set of files with the given ID.
        mFiles.removeIf(file -> file.getId() == fileId);
    }

    public long getTtlIntervalMs() {
        return sTtlIntervalMs;
    }

    @Override
    public int hashCode() {
        // Hash code for the set of files with the given TTL interval.
        return mFiles.stream().map(file -> file.getId()).collect(Collectors.toSet());
    }

    @Override
    public int compareTo(FileManager other) {
        // Compare this object to another object of the same class.
        if (other == null) {
            return 1;
        }
        Set<InodeFile> otherFiles = other.getFiles();
        Set<InodeFile> myFiles = mFiles;
        if (myFiles.size() != otherFiles.size()) {
            return myFiles.size() - otherFiles.size();
        }
        for (InodeFile file : myFiles) {
            InodeFile otherFile = otherFiles.stream().filter(file -> file.getId() == file.getId()).findFirst().orElse(null);
            if (!Objects.equals(otherFile, file)) {
                return -1;
            }
        }
        return 0;
    }

    public Set<InodeFile> getFiles() {
        // Get the set of files with the given TTL interval.
        return mFiles;
    }

    public long getTtlIntervalStartTimeMs() {
        // Get the start time of the TTL interval.
        return mTtlIntervalStartTimeMs;
    }

    public long getTtlIntervalEndTimeMs() {
        // Get the end time of the TTL interval.
        return sTtlIntervalMs + mTtlIntervalStartTimeMs;
    }

    public void addFile(InodeFile file) {
        // Add a file to the set of files with the given TTL interval.
        mFiles.add(file);
    }
}"
23,"package com.example;

public enum JobExitStatus {
    NOOP, FILES_AVAILABLE, CAPTURE_SOURCE_METADATA_ERRORS, SOURCE_DELETION_ERRORS, DOWNLOAD_ERRORS, CONFIG_VALIDATION_FAIL, MOVEFILES_WORKAREA_ERRORS, EXECUTING, DB_NOT_ACCESSABLE, ANOTHER_FETCHER_IS_RUNNING, RUNFAILED, MULTIPLE_PARTIAL_ERRORS, MOVEFILES_DESTINATION_ERRORS, NO_NEW_FILES_FOUND, WORK_AREA_NOT_ACCESSABLE, PROCESS_VALIDATION_FAIL, DESTINATION_NOT_ACCESSABLE, UNKNOWN, DELAYERING_ERRORS;
    
    public static List<JobExitStatus> partialFailureCodes = Arrays.asList(
        JobExitStatus.MULTIPLE_PARTIAL_ERRORS, JobExitStatus.MOVEFILES_DESTINATION_ERRORS, JobExitStatus.MOVEFILES_WORKAREA_ERRORS, JobExitStatus.SOURCE_NOT_ACCESSABLE, JobExitStatus.UNKNOWN, JobExitStatus.DELAYERING_ERRORS
    );
    
    public int hashCode() {
        return this.name().hashCode();
    }
    
    public boolean equals(Object other) {
        if (other instanceof JobExitStatus) {
            return this.name().equals(((JobExitStatus) other).name());
        } else {
            return false;
        }
    }
    
    public ExitStatus getExitStatus() {
        switch (this) {
            case NOOP: return ExitStatus.NOOP;
            case FILES_AVAILABLE: return ExitStatus.FILES_AVAILABLE;
            case CAPTURE_SOURCE_METADATA_ERRORS: return ExitStatus.CAPTURE_SOURCE_METADATA_ERRORS;
            case SOURCE_DELETION_ERRORS: return ExitStatus.SOURCE_DELETION_ERRORS;
            case DOWNLOAD_ERRORS: return ExitStatus.DOWNLOAD_ERRORS;
            case CONFIG_VALIDATION_FAIL: return ExitStatus.CONFIG_VALIDATION_FAIL;
            case MOVEFILES_WORKAREA_ERRORS: return ExitStatus.MOVEFILES_WORKAREA_ERRORS;
            case EXECUTING: return ExitStatus.EXECUTING;
            case DB_NOT_ACCESSABLE: return ExitStatus.DB_NOT_ACCESSABLE;
            case ANOTHER_FETCHER_IS_RUNNING: return ExitStatus.ANOTHER_FETCHER_IS_RUNNING;
            case RUNFAILED: return ExitStatus.RUNFAILED;
            case MULTIPLE_PARTIAL_ERRORS: return ExitStatus.MULTIPLE_PARTIAL_ERRORS;
            case MOVEFILES_DESTINATION_ERRORS: return ExitStatus.MOVEFILES_DESTINATION_ERRORS;
            case NO_NEW_FILES_FOUND: return ExitStatus.NO_NEW_FILES_FOUND;
            case WORK_AREA_NOT_ACCESSABLE: return ExitStatus.WORK_AREA_NOT_ACCESSABLE;
            case PROCESS_VALIDATION_FAIL: return ExitStatus.PROCESS_VALIDATION_FAIL;
            case DESTINATION_NOT_ACCESSABLE: return ExitStatus.DESTINATION_NOT_ACCESSABLE;
            case UNKNOWN: return ExitStatus.UNKNOWN;
            case DELAYERING_ERRORS: return ExitStatus.DELAYERING_ERRORS;
            default: throw new IllegalArgumentException(""Invalid JobExitStatus"");
        }
    }
    
    public String toString() {
        return this.name();
    }
    
    public boolean isPartialFailureCode(JobExitStatus status) {
        return partialFailureCodes.contains(status);
    }
    
    public boolean isPartialFailureCode(int code) {
        return (code & 0x10000) != 0;
    }
    
    public String getExitDescription() {
        switch (this) {
            case NOOP: return ""Job exit status: No operation."";
            case FILES_AVAILABLE: return ""Job exit status: Files available for processing."";
            case CAPTURE_SOURCE_METADATA_ERRORS: return ""Job exit status: Errors occurred while capturing source metadata."";
            case SOURCE_DELETION_ERRORS: return ""Job exit status: Errors occurred while deleting source files."";
            case DOWNLOAD_ERRORS: return ""Job exit status: Errors occurred while downloading files."";
            case CONFIG_VALIDATION_FAIL: return ""Job exit status: Configuration validation failed."";
            case MOVEFILES_WORKAREA_ERRORS: return ""Job exit status: Errors occurred while moving files to workarea."";
            case EXECUTING: return ""Job exit status: Job is currently executing."";
            case DB_NOT_ACCESSABLE: return ""Job exit status: Database not accessible."";
            case ANOTHER_FETCHER_IS_RUNNING: return ""Job exit status: Another fetcher is already running."";
            case RUNFAILED: return ""Job exit status: Job execution failed."";
            case MULTIPLE_PARTIAL_ERRORS: return ""Job exit status: Multiple partial errors occurred during processing."";
            case MOVEFILES_DESTINATION_ERRORS: return ""Job exit status: Errors occurred while moving files to destination."";
            case NO_NEW_FILES_FOUND: return ""Job exit status: No new files found for processing."";
            case WORK_AREA_NOT_ACCESSABLE: return ""Job exit status: Work area not accessible."";
            case PROCESS_VALIDATION_FAIL: return ""Job exit status: Process validation failed."";
            case DESTINATION_NOT_ACCESSABLE: return ""Job exit status: Destination not accessible."";
            case UNKNOWN: return ""Job exit status: Unknown error occurred."";
            case DELAYERING_ERRORS: return ""Job exit status: Delayering errors occurred during processing."";
            default: throw new IllegalArgumentException(""Invalid JobExitStatus"");
        }
    }
}"
230,"import org.ejml.data.DenseMatrix64F;
import org.ejml.factory.LinearSolverFactory;
import org.ejml.interfaces.linsol.LinearSolverDense;
import org.ejml.ops.EigenDecomposition;
import java.util.ArrayList;
import java.util.List;

public class EigenvalueFinder {
    public static int getNumberOfEigenvalues(DenseMatrix64F mat) {
        // Compute the eigendecomposition of the matrix
        EigenDecomposition<DenseMatrix64F> eig = new EigenDecomposition<>(mat);

        // Get the number of eigenvalues
        int numEigenvalues = eig.getEVD().numEigenvalues();

        return numEigenvalues;
    }
}"
231,"import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Marshaller;
import javax.xml.namespace.QName;

public class QNameExample {
    public static void main(String[] args) throws Exception {
        // Create the JAXB context and element factories
        JAXBContext jaxbContext = JAXBContext.newInstance(QName.class);
        Marshaller marshaller = jaxbContext.createMarshaller();
        javax.xml.bind.ElementFactory elementFactory = new javax.xml.bind.ElementFactory() {
            @Override
            public Object createElement(QName qname, Class[] classChain) {
                if (qname.equals(new QName(""urn:auth"", ""Auth""))) {
                    return new JAXBElement<>(qname, Auth.class);
                } else if (qname.equals(new QName(""urn:auth"", ""User""))) {
                    return new JAXBElement<>(qname, User.class);
                } else if (qname.equals(new QName(""urn:auth"", ""Access""))) {
                    return new JAXBElement<>(qname, Access.class);
                } else if (qname.equals(new QName(""urn:auth"", ""ProjectValidation""))) {
                    return new JAXBElement<>(qname, ProjectValidation.class);
                } else if (qname.equals(new QName(""urn:auth"", ""RegistrationRequest""))) {
                    return new JAXBElement<>(qname, RegistrationRequest.class);
                } else if (qname.equals(new QName(""urn:auth"", ""RegistrationResponse""))) {
                    return new JAXBElement<>(qname, RegistrationResponse.class);
                } else if (qname.equals(new QName(""urn:auth"", ""RoleList""))) {
                    return new JAXBElement<>(qname, RoleList.class);
                } else if (qname.equals(new QName(""urn:auth"", ""Role""))) {
                    return new JAXBElement<>(qname, Role.class);
                } else if (qname.equals(new QName(""urn:auth"", ""CertificateInfo""))) {
                    return new JAXBElement<>(qname, CertificateInfo.class);
                } else if (qname.equals(new QName(""urn:auth"", ""UserValidation""))) {
                    return new JAXBElement<>(qname, UserValidation.class);
                } else if (qname.equals(new QName(""urn:auth"", ""CertificateCredentials""))) {
                    return new JAXBElement<>(qname, CertificateCredentials.class);
                } else if (qname.equals(new QName(""urn:auth"", ""SignCertificateRequest""))) {
                    return new JAXBElement<>(qname, SignCertificateRequest.class);
                } else if (qname.equals(new QName(""urn:auth"", ""SignCertificateResponse""))) {
                    return new JAXBElement<>(qname, SignCertificateResponse.class);
                } else if (qname.equals(new QName(""urn:auth"", ""CheckServiceAccessRequest""))) {
                    return new JAXBElement<>(qname, CheckServiceAccessRequest.class);
                } else if (qname.equals(new QName(""urn:auth"", ""CheckServiceAccessResponse""))) {
                    return new JAXBElement<>(qname, CheckServiceAccessResponse.class);
                } else if (qname.equals(new QName(""urn:auth"", ""ValidateTokenRequest""))) {
                    return new JAXBElement<>(qname, ValidateTokenRequest.class);
                } else if (qname.equals(new QName(""urn:auth"", ""ValidateTokenResponse""))) {
                    return new JAXBElement<>(qname, ValidateTokenResponse.class);
                } else if (qname.equals(new QName(""urn:auth"", ""AuthenticateRequest""))) {
                    return new JAXBElement<>(qname, AuthenticateRequest.class);
                } else if (qname.equals(new QName(""urn:auth"", ""AuthenticateResponse""))) {
                    return new JAXBElement<>(qname, AuthenticateResponse.class);
                } else if (qname.equals(new QName(""urn:auth"", ""ValidateAccessRequest""))) {
                    return new JAXBElement<>(qname, ValidateAccessRequest.class);
                } else if (qname.equals(new QName(""urn:auth"", ""ValidateAccessResponse""))) {
                    return new JAXBElement<>(qname, ValidateAccessResponse.class);
                }
                // Handle other elements as needed...
            }
        };

        // Create the JAXB context and element factories
        jaxbContext = JAXBContext.newInstance(elementFactory);
        marshaller = jaxbContext.createMarshaller();
        marshaller.setProperty(""com.sun.xml.bind.namespacePrefixMapper"", new NamespacePrefixMapper() {
            @Override
            public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {
                if (namespaceUri.equals(""urn:auth"")) {
                    return ""auth"";
                } else {
                    return suggestion;
                }
            }
        });

        // Create the objects to be marshalled
        ValidateTokenResponse validateTokenResponse = createValidateTokenResponse();
        CheckServiceAccessResponse checkServiceAccessResponse = createCheckServiceAccessResponse();
        AuthenticateResponse authenticateResponse = createAuthenticateResponse();
        ValidateAccess validateAccess = createValidateAccess();
        AuthenticateRequest authenticateRequest = createAuthenticateRequest();
        Auth auth = createAuth();
        User user = createUser();
        RoleList roleList = createRoleList();
        RegistrationRequest registrationRequest = createRegistrationRequest();
        RegistrationResponse registrationResponse = createRegistrationResponse();
        CertificateInfo certificateInfo = createCertificateInfo();
        UserValidation userValidation = createUserValidation();
        CertificateCredentials certificateCredentials = createCertificateCredentials();
        SignCertificateRequest signCertificateRequest = createSignCertificateRequest();
        SignCertificateResponse signCertificateResponse = createSignCertificateResponse();

        // Marshal the objects
        marshaller.marshal(validateTokenResponse, System.out);
        marshaller.marshal(checkServiceAccessResponse, System.out);
        marshaller.marshal(authenticateResponse, System.out);
        marshaller.marshal(validateAccess, System.out);
        marshaller.marshal(authenticateRequest, System.out);
        marshaller.marshal(auth, System.out);
        marshaller.marshal(user, System.out);
        marshaller.marshal(roleList, System.out);
        marshaller.marshal(registrationRequest, System.out);
        marshaller.marshal(registrationResponse, System.out);
        marshaller.marshal(certificateInfo, System.out);
        marshaller.marshal(userValidation, System.out);
        marshaller.marshal(certificateCredentials, System.out);
        marshaller.marshal(signCertificateRequest, System.out);
        marshaller.marshal(signCertificateResponse, System.out);
    }

    private static ValidateTokenResponse createValidateTokenResponse() {
        // Create the ValidateTokenResponse object
        ValidateTokenResponse validateTokenResponse = new ValidateTokenResponse();
        validateTokenResponse.setValidated(true);
        validateTokenResponse.setTokenType(""JWT"");
        return validateTokenResponse;
    }

    private static CheckServiceAccessResponse createCheckServiceAccessResponse() {
        // Create the CheckServiceAccessResponse object
        CheckServiceAccessResponse checkServiceAccessResponse = new CheckServiceAccessResponse();
        checkServiceAccessResponse.setAllowed(true);
        return checkServiceAccessResponse;
    }

    private static AuthenticateResponse createAuthenticateResponse() {
        // Create the AuthenticateResponse object
        AuthenticateResponse authenticateResponse = new AuthenticateResponse();
        authenticateResponse.setUsername(""user"");
        authenticateResponse.setPassword(""password"");
        return authenticateResponse;
    }

    private static ValidateAccess createValidateAccess() {
        // Create the ValidateAccess object
        ValidateAccess validateAccess = new ValidateAccess();
        validateAccess.setRoleList(createRoleList());
        validateAccess.setToken(""token"");
        return validateAccess;
    }

    private static AuthenticateRequest createAuthenticateRequest() {
        // Create the AuthenticateRequest object
        AuthenticateRequest authenticateRequest = new AuthenticateRequest();
        authenticateRequest.setUsername(""user"");
        authenticateRequest.setPassword(""password"");
        return authenticateRequest;
    }

    private static Auth createAuth() {
        // Create the Auth object
        Auth auth = new Auth();
        auth.setUsername(""user"");
        auth.setPassword(""password"");
        return auth;
    }

    private static User createUser() {
        // Create the User object
        User user = new User();
        user.setUsername(""user"");
        user.setPassword(""password"");
        return user;
    }

    private static RoleList createRoleList() {
        // Create the RoleList object
        RoleList roleList = new RoleList();
        roleList.getRoles().add(createRole());
        return roleList;
    }

    private static Role createRole() {
        // Create the Role object
        Role role = new Role();
        role.setName(""role"");
        return role;
    }

    private static CertificateInfo createCertificateInfo() {
        // Create the CertificateInfo object
        CertificateInfo certificateInfo = new CertificateInfo();
        certificateInfo.setSubject(""subject"");
        certificateInfo.setIssuer(""issuer"");
        return certificateInfo;
    }

    private static UserValidation createUserValidation() {
        // Create the UserValidation object
        UserValidation userValidation = new UserValidation();
        userValidation.setUsername(""user"");
        userValidation.setPassword(""password"");
        return userValidation;
    }

    private static CertificateCredentials createCertificateCredentials() {
        // Create the CertificateCredentials object
        CertificateCredentials certificateCredentials = new CertificateCredentials();
        certificateCredentials.setCertificateInfo(createCertificateInfo());
        certificateCredentials.setPassword(""password"");
        return certificateCredentials;
    }

    private static SignCertificateRequest createSignCertificateRequest() {
        // Create the SignCertificateRequest object
        SignCertificateRequest signCertificateRequest = new SignCertificateRequest();
        signCertificateRequest.setUsername(""user"");
        signCertificateRequest.setPassword(""password"");
        return signCertificateRequest;
    }

    private static SignCertificateResponse createSignCertificateResponse() {
        // Create the SignCertificateResponse object
        SignCertificateResponse signCertificateResponse = new SignCertificateResponse();
        signCertificateResponse.setUsername(""user"");
        signCertificateResponse.setPassword(""password"");
        return signCertificateResponse;
    }

    private static RegistrationRequest createRegistrationRequest() {
        // Create the RegistrationRequest object
        RegistrationRequest registrationRequest = new RegistrationRequest();
        registrationRequest.setUsername(""user"");
        registrationRequest.setPassword(""password"");
        return registrationRequest;
    }

    private static RegistrationResponse createRegistrationResponse() {
        // Create the RegistrationResponse object
        RegistrationResponse registrationResponse = new RegistrationResponse();
        registrationResponse.setUsername(""user"");
        registrationResponse.setPassword(""password"");
        return registrationResponse;
    }
}"
232,"public class Task {
    private String feedId;
    private String destFileName;
    private String testId;

    public void setFeedId(String feedId) {
        this.feedId = feedId;
    }

    public void setDestFileName(String destFileName) {
        this.destFileName = destFileName;
    }

    public void setTestId(String testId) {
        this.testId = testId;
    }

    public String getFeedId() {
        return feedId;
    }

    public String getDestFileName() {
        return destFileName;
    }

    public String getTestId() {
        return testId;
    }

    @Override
    public String toString() {
        return ""Task{"" +
                ""feedId='"" + feedId + '\'' +
                "", destFileName='"" + destFileName + '\'' +
                "", testId='"" + testId + '\'' +
                '}';
    }
}"
233,"public class Service {
    private final Logger logger = Logger.getLogger(Service.class.getName());

    private final Executor executor;

    public Service(Executor executor) {
        this.executor = executor;
    }

    public void doStop() {
        // Default implementation does nothing
    }

    public void run() throws Throwable {
        // Implement logic to start the service here
    }

    public String getServiceName() {
        return ""My Service"";
    }

    public Service startAsync() {
        // Start the service asynchronously and return a reference to it
        executor.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    doStart();
                } catch (Throwable e) {
                    failureCause = e;
                }
            }
        });
        return this;
    }

    private Throwable failureCause;

    public boolean isRunning() {
        // Return true if the service is running, false otherwise
        return !failureCause.isPresent();
    }

    public void shutDown() {
        // Implement logic to stop the service here
    }

    public Service startUp() {
        // Start the service synchronously and return a reference to it
        executor.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    doStart();
                } catch (Throwable e) {
                    failureCause = e;
                }
            }
        });
        return this;
    }

    private void doStart() throws Throwable {
        // Implement logic to start the service here
    }

    public String toString() {
        return ""My Service"";
    }
}"
234,"[PYTHON]
class HouseholderDecomposition:
    def __init__(self, m, n):
        self.m = m
        self.n = n
        self.handleV = DenseMatrix64F(n, n)
        self.handleU = DenseMatrix64F(m, m)
        self.decompose = False
        self.inputModified = True
        self.gammasV = []
        self.gammasU = []

    def init(self):
        self.handleV.zero()
        self.handleU.zero()
        self.decompose = False
        self.inputModified = True

    def decompose(self, b):
        if len(b) != self.m:
            raise ValueError(""The length of the vector b must be equal to the number of rows of the matrix U"")

        if self.inputModified:
            self._decompose = True
            self.inputModified = False

        # Perform the householder operations on the vectors
        for i in range(self.m):
            gamma = 0
            for j in range(i+1, self.n):
                gamma += (b[j] - b[i])**2
            self.gammasV.append(math.sqrt(gamma))
            self.gammasU.append(math.sqrt(gamma))

        # Compute the U and V matrices
        for i in range(self.m):
            for j in range(i+1, self.n):
                ratio = (b[j] - b[i]) / self.gammasV[j-1]
                self.handleV.setElementAt(i, j-1, -ratio)
                self.handleV.setElementAt(j, i, ratio)

        for i in range(self.m):
            for j in range(i+1, self.n):
                ratio = (b[j] - b[i]) / self.gammasU[i-1]
                self.handleU.setElementAt(i, j-1, -ratio)
                self.handleU.setElementAt(j, i, ratio)

        # Compute the diagonal elements of U and V
        for i in range(self.m):
            self.handleU.setElementAt(i, i, 1 - self.gammasU[i-1])
            self.handleV.setElementAt(i, i, 1 - self.gammasV[i-1])

        # Compute the off-diagonal elements of U and V
        for i in range(self.m):
            for j in range(i+1, self.n):
                self.handleU.setElementAt(i, j-1, 0)
                self.handleV.setElementAt(i, j-1, 0)

        # Compute the UBV matrix
        for i in range(self.m):
            for j in range(self.n):
                self.UBV.setElementAt(i, j, b[j])
            for k in range(i+1, self.n):
                self.UBV.setElementAt(k, i-1, 0)

        # Compute the B matrix
        for i in range(self.m):
            for j in range(self.n):
                self.B.setElementAt(i, j, b[j])
            for k in range(i+1, self.m):
                self.B.setElementAt(k, i-1, 0)

        # Compute the gammas vector
        for i in range(self.m):
            self.gammasV.append(math.sqrt(gamma))
            self.gammasU.append(math.sqrt(gamma))

        self.decompose = True

    def getDiagonal(self, handle):
        if not self.decompose:
            raise ValueError(""The decomposition must be performed before calling this method"")

        for i in range(min(handle.numRows(), handle.numCols())):
            handle.setElementAt(i, i, self.gammasU[i-1])

    def getGammasV(self):
        if not self.decompose:
            raise ValueError(""The decomposition must be performed before calling this method"")

        return self.gammasV

    def getUBV(self):
        if not self.decompose:
            raise ValueError(""The decomposition must be performed before calling this method"")

        return self.UBV

    def getB(self):
        if not self.decompose:
            raise ValueError(""The decomposition must be performed before calling this method"")

        return self.B

    def getU(self):
        if not self.decompose:
            raise ValueError(""The decomposition must be performed before calling this method"")

        return self.handleU

    def getV(self):
        if not self.decompose:
            raise ValueError(""The decomposition must be performed before calling this method"")

        return self.handleV

[/PYTHON]
[TESTS]
# Test case 1:
hd = HouseholderDecomposition(3, 4)
assert hd.m == 3 and hd.n == 4

# Test case 2:
hd.init()
assert not hd.decompose

# Test case 3:
b = [1, 2, 3]
hd.decompose(b)
assert hd.decompose

# Test case 4:
hd.getDiagonal(DenseMatrix64F(3, 3))
assert False

# Test case 5:
assert hd.getGammasV() == [0, 1, 2]

# Test case 6:
assert hd.getUBV().isEqual(DenseMatrix64F([[1, 0, 0, 0], [2, 3, 0, 0], [3, 6, 9, 0]]), True)

# Test case 7:
assert hd.getB().isEqual(DenseMatrix64F([[1, 0, 0], [2, 3, 0], [3, 6, 9]]), True)

# Test case 8:
assert hd.getU().isEqual(DenseMatrix64F([[1, -0.5, 0, 0], [-0.5, 0.5, 0, 0], [0, 0, 1, 0]]), True)

# Test case 9:
assert hd.getV().isEqual(DenseMatrix64F([[1, -0.5, 0, 0], [-0.5, 0.5, 0, 0], [0, 0, 1, 0]]), True)

# Test case 10:
hd = HouseholderDecomposition(4, 3)
b = [1, 2, 3, 4]
hd.decompose(b)
assert hd.getDiagonal(DenseMatrix64F(3, 3)) == [1, 1, 1]
[/TESTS]"
235,"import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Node;

public class NodeUtils {
    public static Bounds getPhysicalTransformedBounds(Node node) {
        // Get the bounds of the node in the local coordinate system
        Bounds nodeBounds = node.getBoundsInLocal();

        // Transform the bounds to the scene coordinate system
        Bounds nodeBoundsInScene = node.localToScene(nodeBounds);

        // Check if the bounds are visible
        boolean areBoundsVisible = node.isVisible();

        // Limit the bounds to the visible area of the scene
        Bounds limitedBounds = node.getScene().limitToVisibleBounds(nodeBoundsInScene);

        // Get the physical transformed bounds, including any effects and clipping applied to the node
        Bounds physicalTransformedBounds = node.getTransform().transform(limitedBounds);

        return physicalTransformedBounds;
    }
}"
236,"public void setMapType(MapType mapType) {
    this.mapType = mapType;
}

public MapType getMapType() {
    return mapType;
}"
237,"public class ValidationUtil {
    public static boolean isValidActionName(String actionName) {
        return validateActionName(actionName);
    }

    private static String validateActionName(String actionName) {
        if (actionName == null || actionName.isEmpty()) {
            throw new IllegalArgumentException(""Action name cannot be null or empty"");
        }

        if (actionName.length() > MAX_NODE_NAME_LEN) {
            throw new IllegalArgumentException(String.format(""Action name cannot be greater than %d characters"", MAX_NODE_NAME_LEN));
        }

        return actionName;
    }

    public static int checkInteger(int value) {
        if (value < 0) {
            throw new IllegalArgumentException(""Value must be non-negative"");
        }

        return value;
    }

    public static Date checkUTC(Date date) {
        if (!date.getTimeZone().equals(TimeZone.getTimeZone(""UTC""))) {
            throw new IllegalArgumentException(""Date must be in UTC time zone"");
        }

        return date;
    }

    public static int checkGEZero(int value) {
        if (value < 0) {
            throw new IllegalArgumentException(""Value must be non-negative"");
        }

        return value;
    }

    public static boolean isMember(String identifier, List<String> identifiers) {
        return identifiers.contains(identifier);
    }

    public static String notEmpty(String str) {
        if (str == null || str.isEmpty()) {
            throw new IllegalArgumentException(""String cannot be null or empty"");
        }

        return str;
    }

    public static List<String> notEmptyElements(List<String> list) {
        if (list == null || list.isEmpty()) {
            throw new IllegalArgumentException(""List cannot be null or empty"");
        }

        for (String element : list) {
            if (element == null || element.isEmpty()) {
                throw new IllegalArgumentException(""Element in the list cannot be null or empty"");
            }
        }

        return list;
    }

    public static TimeZone checkTimeZone(TimeZone timeZone) {
        if (!timeZone.getID().equals(""UTC"")) {
            throw new IllegalArgumentException(""Time zone must be UTC"");
        }

        return timeZone;
    }

    public static List<T> notNullElements(List<T> list) {
        if (list == null || list.isEmpty()) {
            throw new IllegalArgumentException(""List cannot be null or empty"");
        }

        for (T element : list) {
            if (element == null) {
                throw new IllegalArgumentException(""Element in the list cannot be null"");
            }
        }

        return list;
    }

    public static boolean isValidIdentifier(String identifier) {
        // TODO: Implement this method to check if the given string is a valid identifier.
    }
}"
238,"import org.junit.Test;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.util.ReflectionTestUtils;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class CustomAuthenticationProviderTest {

    @Test(expected = RuntimeException.class)
    public void testCustomAuthenticationProvider() throws Exception {
        // Setup
        String className = ""com.example.MyCustomAuthenticationProvider"";
        Authentication auth = new TestingAuthenticationToken(""user"", ""password"");

        // When
        CustomAuthenticationProvider provider = new CustomAuthenticationProvider(className);
        try {
            provider.authenticate(auth);
        } catch (RuntimeException e) {
            // Then
            assertEquals(""com.example.MyCustomAuthenticationProvider"", ReflectionTestUtils.getField(e, ""className""));
            throw e;
        }
    }
}"
239,"package com.example;

import java.util.Map;

import backtype.storm.task.OutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class TestBolt {
    @Mock
    private Map<String, Object> stormConf;

    @Mock
    private TopologyContext topologyContextMock;

    @Mock
    private OutputCollector outputCollectorMock;

    @Mock
    private OutputFieldsDeclarer outputFieldsDeclarerMock;

    @Before
    public void setUp() {
        // Initialize the mocks
    }

    @Test
    public void testNullReturn() {
        // Test that the bolt returns null when no tuples are passed in
        assertNull(prototypeIntegrationRun());
    }

    private void prototypeIntegrationRun() {
        sideOperation();
    }

    private void sideOperation() {
        try {
            run();
        } catch (ExecutionException e) {
            // Handle the exception
        }
    }

    private void run() throws ExecutionException {
        topologyContextMock.setTaskId(0);
        outputFieldsDeclarerMock.declareStream(null, null);
        outputCollectorMock.ack(tupleMock);
    }

    @Test
    public void testMultiplexPassThroughWithScatter() {
        // Test that the bolt multiplexes messages to multiple streams when using scatterGather operation
        assertTrue(multiplexPassThroughWithScatter());
    }

    private boolean multiplexPassThroughWithScatter() {
        sideOperation();
        return true;
    }

    @Test
    public void testPassThroughOverlap() {
        // Test that the bolt passes messages through to other bolts in the topology when using overlap operation
        assertTrue(passThroughOverlap());
    }

    private boolean passThroughOverlap() {
        sideOperation();
        return true;
    }
}"
24,"public class StandardAttributResolver {
    private NamespaceHandler nsh;
    private UserInterface ui;
    private UserAgentCallback uac;
    
    public String getHoverAttributeValue() {
        return this.nsh.getClass().getDeclaredMethod(""isLink"").invoke(this.ui) ? ""hover"" : null;
    }
    
    public boolean isVisited() {
        return this.uac.getElementStyling().containsKey(""visited"");
    }
    
    public boolean isFocus() {
        return this.uac.getElementStyling().containsKey(""focus"");
    }
    
    public String getLang() {
        return this.nsh.getClass().getDeclaredMethod(""getAttributeValue"").invoke(this.ui) ? ""en-US"" : null;
    }
    
    public String getID() {
        return this.nsh.getClass().getDeclaredMethod(""getAttributeValue"").invoke(this.ui) ? ""my-id"" : null;
    }
    
    public String getNonCssStyling() {
        return this.uac.getElementStyling().containsKey(""active"") ? ""active"" : null;
    }
    
    public String getElementStyling() {
        return this.nsh.getClass().getDeclaredMethod(""isActive"").invoke(this.ui) ? ""active"" : null;
    }
}"
240,"[PYTHON]
import java.net.URLEncoder;

public class UrlEscaper {
    public static String escapeUrl(String url) {
        return URLEncoder.encode(url, ""UTF-8"");
    }
}
[/PYTHON]
[TESTS]
# Test case 1:
assert UrlEscaper.escapeUrl(""https://www.example.com/path/to/file?query=param"") == ""https%3A//www.example.com/path/to/file%3Fquery%3Dparam""
# Test case 2:
assert UrlEscaper.escapeUrl(""https://www.example.com/path/to/file?query=param#anchor"") == ""https%3A//www.example.com/path/to/file%3Fquery%3Dparam%23anchor""
# Test case 3:
assert UrlEscaper.escapeUrl(""https://www.example.com/path/to/file?query=param&other=param#anchor"") == ""https%3A//www.example.com/path/to/file%3Fquery%3Dparam%26other%3Dparam%23anchor""
[/TESTS]"
241,"package com.example;

import java.util.Objects;

public class DataComparisonResult {
    private Long expectedDataUnitId;
    private Long seqNo;
    private Long dataSetId;
    private Long dataUnitId;
    private String expectedValue;
    private String actualValue;
    private Long expectedDataSetId;
    private String errorCode;
    private Long testId;
    private String failedAttributeName;
    private String srcFileName;

    public DataComparisonResult() {}

    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }

    public String getExpectedValue() {
        return expectedValue;
    }

    public void setExpectedDataSetId(Long expectedDataSetId) {
        this.expectedDataSetId = expectedDataSetId;
    }

    public Long getExpectedDataSetId() {
        return expectedDataSetId;
    }

    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }

    public String getActualValue() {
        return actualValue;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public String getSrcFileName() {
        return srcFileName;
    }

    public Long getExpectedDataUnitId() {
        return expectedDataUnitId;
    }

    public void setExpectedDataUnitId(Long expectedDataUnitId) {
        this.expectedDataUnitId = expectedDataUnitId;
    }

    public String getFailedAttributeName() {
        return failedAttributeName;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public Long getTestId() {
        return testId;
    }

    public void setFailedAttributeName(String failedAttributeName) {
        this.failedAttributeName = failedAttributeName;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof DataComparisonResult)) return false;
        DataComparisonResult that = (DataComparisonResult) o;
        return Objects.equals(expectedDataUnitId, that.expectedDataUnitId) &&
                Objects.equals(seqNo, that.seqNo) &&
                Objects.equals(dataSetId, that.dataSetId) &&
                Objects.equals(dataUnitId, that.dataUnitId) &&
                Objects.equals(expectedValue, that.expectedValue) &&
                Objects.equals(actualValue, that.actualValue) &&
                Objects.equals(expectedDataSetId, that.expectedDataSetId) &&
                Objects.equals(errorCode, that.errorCode) &&
                Objects.equals(testId, that.testId) &&
                Objects.equals(failedAttributeName, that.failedAttributeName) &&
                Objects.equals(srcFileName, that.srcFileName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(expectedDataUnitId, seqNo, dataSetId, dataUnitId, expectedValue, actualValue, expectedDataSetId, errorCode, testId, failedAttributeName, srcFileName);
    }

    @Override
    public String toString() {
        return ""DataComparisonResult{"" +
                ""expectedDataUnitId="" + expectedDataUnitId +
                "", seqNo="" + seqNo +
                "", dataSetId="" + dataSetId +
                "", dataUnitId="" + dataUnitId +
                "", expectedValue='"" + expectedValue + '\'' +
                "", actualValue='"" + actualValue + '\'' +
                "", expectedDataSetId="" + expectedDataSetId +
                "", errorCode='"" + errorCode + '\'' +
                "", testId="" + testId +
                "", failedAttributeName='"" + failedAttributeName + '\'' +
                "", srcFileName='"" + srcFileName + '\'' +
                '}';
    }
}"
242,"import java.nio.ByteBuffer;

public class ByteBufferExample {
  public static void main(String[] args) {
    // create a new byte buffer with capacity of 1024 bytes
    ByteBuffer mWriter = ByteBuffer.allocate(1024);

    // put the value in big-endian order into the buffer
    mWriter.putLen8((byte) 24);
    mWriter.put16((short) 35);
    mWriter.put16((short) 45);
    mWriter.putLen16((short) 55);
    byte[] mBuffer = mWriter.toByteArray();

    // ensure the buffer has enough capacity to write the given value
    mWriter.ensureCapacity(8);

    // put the value in big-endian order into the buffer again
    mWriter.put64((long) 64);
    mWriter.put64((long) 74);
    mWriter.put64((long) 84);
    mWriter.put(32);
    mWriter.put(32);
    mWriter.put32((int) 95);
    mWriter.put32((int) 105);
    mWriter.put32((int) 115);

    // get the byte array of the buffer
    byte[] mBuffer = mWriter.toByteArray();
  }
}"
243,"import java.sql.*;
import java.util.Map;
import java.util.logging.Logger;

public class DatabaseConnector {
    private static final Logger LOG = Logger.getLogger(DatabaseConnector.class.getName());
    private Map<String, Integer> activeConnectionCount;
    private DataSource ds;

    public void setDataSource(DataSource ds) {
        this.ds = ds;
    }

    public DataSource getDataSource() {
        return ds;
    }

    public Connection getDbConnection() throws SQLException {
        Connection conn = ds.getConnection();
        activeConnectionCount.put(conn.toString(), 1);
        LOG.info(""New database connection established."");
        return conn;
    }

    public void closeConnection(Connection conn) throws SQLException {
        if (activeConnectionCount.containsKey(conn.toString())) {
            int count = activeConnectionCount.get(conn.toString());
            if (count == 1) {
                activeConnectionCount.remove(conn.toString());
                LOG.info(""Database connection closed."");
            } else {
                activeConnectionCount.put(conn.toString(), count - 1);
            }
        }
    }

    public void disableForeignKeyCheck() throws SQLException {
        Connection conn = getDbConnection();
        try (Statement stmt = conn.createStatement()) {
            stmt.execute(""SET FOREIGN_KEY_CHECKS = 0;"");
        } catch (SQLException e) {
            LOG.severe(e.getMessage());
        } finally {
            closeConnection(conn);
        }
    }

    public void enableForeignKeyCheck() throws SQLException {
        Connection conn = getDbConnection();
        try (Statement stmt = conn.createStatement()) {
            stmt.execute(""SET FOREIGN_KEY_CHECKS = 1;"");
        } catch (SQLException e) {
            LOG.severe(e.getMessage());
        } finally {
            closeConnection(conn);
        }
    }
}"
244,"public class ClassdiagramNode {
    private int edgeOffset;
    private FigNode figure;
    private float UPLINK_FACTOR = 1.0f;
    private List<ClassdiagramNode> uplinks;
    private int rank;
    private List<ClassdiagramNode> downlinks;
    private int NORANK = -1;
    private int column;
    private int placementHint;
    private float weight;
    private int NOCOLUMN = 0;
    private int NOWEIGHT = 0.0f;

    public ClassdiagramNode() {
        this.edgeOffset = edgeOffset;
        this.figure = figure;
        this.uplinks = new ArrayList<ClassdiagramNode>();
        this.downlinks = new ArrayList<ClassdiagramNode>();
        this.rank = NORANK;
        this.column = NOCOLUMN;
        this.placementHint = placementHint;
        this.weight = weight;
    }

    public Vector<ClassdiagramNode> getUplinks() {
        return uplinks;
    }

    public Point getLocation() {
        return figure.getLocation();
    }

    public boolean isComment() {
        return false;
    }

    public List<ClassdiagramNode> getUpNodes() {
        return new ArrayList<ClassdiagramNode>();
    }

    public float getWeight() {
        return weight;
    }

    public FigNode getFigure() {
        return figure;
    }

    public Vector<ClassdiagramNode> getDownlinks() {
        return downlinks;
    }

    @Override
    public int compareTo(ClassdiagramNode o) {
        return 0;
    }

    public void setColumn(int column) {
        this.column = column;
    }

    public void addDownlink(ClassdiagramNode downlink) {
        if (downlinks == null) {
            downlinks = new ArrayList<ClassdiagramNode>();
        }
        downlinks.add(downlink);
    }

    public void setLocation(Point location) {
        figure.setLocation(location);
    }

    public void setEdgeOffset(int edgeOffset) {
        this.edgeOffset = edgeOffset;
    }

    public boolean isStandalone() {
        return false;
    }

    public int getColumn() {
        return column;
    }

    public float getSubtreeWeight() {
        return weight;
    }

    public float calculateWeight() {
        return UPLINK_FACTOR * getDownlinks().size();
    }

    public void setRank(int rank) {
        this.rank = rank;
    }

    public void addRank(int rank) {
        if (this.rank == NORANK) {
            this.rank = rank;
        } else if (this.rank != NORANK && rank != NORANK) {
            this.rank += rank;
        }
    }

    public int getTypeOrderNumer() {
        return 0;
    }

    public int getEdgeOffset() {
        return edgeOffset;
    }

    public int getRank() {
        return rank;
    }

    public void setWeight(float weight) {
        this.weight = weight;
    }

    public boolean isPackage() {
        return false;
    }

    public int getLevel() {
        return 0;
    }

    public Dimension getSize() {
        return new Dimension(0, 0);
    }

    public void setPlacementHint(int placementHint) {
        this.placementHint = placementHint;
    }

    public int getPlacementHint() {
        return placementHint;
    }

    public void setFigure(FigNode figure) {
        this.figure = figure;
    }

    public List<ClassdiagramNode> getDownNodes() {
        return new ArrayList<ClassdiagramNode>();
    }
}"
245,"package com.example;

import java.util.HashMap;
import java.util.Map;
import org.junit.Before;
import org.junit.Test;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;
import static org.junit.Assert.*;
import com.amazonaws.services.s3.model.StorageTier;
import com.amazonaws.services.s3.model.StorageTierView;

public class StorageTierTest {
    private static final int TEST_TIER_LEVEL = 2;
    @Rule public TemporaryFolder mTestFolder = new TemporaryFolder();
    @Rule public ExpectedException mThrown = ExpectedException.none();
    private StorageTier mTestTier;
    private StorageTierView mTestTierView;

    @Before
    public void before() {
        mTestTier = new StorageTier(TEST_TIER_LEVEL);
        mTestTierView = new StorageTierView(mTestTier, 1024);
    }

    @Test
    public void getDirViews() {
        // Test that the correct number of directory views are returned for the test tier
        Map<String, Long> dirViews = mTestTierView.getDirViews();
        assertEquals(32, dirViews.size());

        // Test that the directory views are properly formed and contain the expected values
        for (Map.Entry<String, Long> entry : dirViews.entrySet()) {
            assertTrue(entry.getKey().matches(""\\d{8}-\\d{4}-\\d{4}-\\d{4}-\\d{12}""));
            assertTrue(entry.getValue() > 0);
        }
    }

    @Test
    public void getDirViewBadIndex() {
        // Test that an exception is thrown for a bad index value
        mThrown.expect(IllegalArgumentException.class);
        mTestTierView.getDirViews(-1);
    }

    @Test
    public void getTierViewAlias() {
        // Test that the alias for the test tier is properly returned
        assertEquals(""tier-2"", mTestTier.getAlias());
    }

    @Test
    public void getTierViewOrdinal() {
        // Test that the ordinal for the test tier is properly returned
        assertEquals(2, mTestTier.getOrdinal());
    }
}"
246,"public class Item {
    private Integer item;
    private int sumIutilP;
    private int sumIutilN;
    private List<Element>[] periodsElements;
    private int periodsSumIutilRutil[];

    public Item(Integer item, int sumIutilP, int sumIutilN, List<Element>[] periodsElements, int periodsSumIutilRutil[]) {
        this.item = item;
        this.sumIutilP = sumIutilP;
        this.sumIutilN = sumIutilN;
        this.periodsElements = periodsElements;
        this.periodsSumIutilRutil = periodsSumIutilRutil;
    }

    public Integer getItem() {
        return item;
    }

    public int getSumIutilP() {
        return sumIutilP;
    }

    public int getSumIutilN() {
        return sumIutilN;
    }

    public List<Element>[] getPeriodsElements() {
        return periodsElements;
    }

    public int[] getPeriodsSumIutilRutil() {
        return periodsSumIutilRutil;
    }

    public void addElement(Element element) {
        periodsElements[element.getPeriod()].add(element);
        periodsSumIutilRutil[element.getPeriod()] += element.getIutil();
    }

    public Element findElementWithTID(int tid) {
        for (List<Element> elements : periodsElements) {
            for (Element element : elements) {
                if (element.getTid() == tid) {
                    return element;
                }
            }
        }
        return null;
    }
}"
247,"import java.util.*;

public class FederationPullRegistration {
    private final boolean mirror;
    private final boolean mergeAccounts;
    private final boolean notifyOnError;
    private final long serialVersionUID = 1L;
    private final String url;
    private final String token;
    private final String frequency;
    private final Map<String, FederationPullStatus> results;
    private final String folder;
    private final String name;
    private final boolean sendStatus;
    private final Date lastPull;
    private final boolean bare;
    private final List<String> exclusions;
    private final Date nextPull;
    private final List<String> inclusions;
    private final FederationPullStatus status;

    public FederationPullRegistration(boolean mirror, boolean mergeAccounts, boolean notifyOnError, String url, String token, String frequency, Map<String, FederationPullStatus> results, String folder, String name, boolean sendStatus, Date lastPull, boolean bare, List<String> exclusions, Date nextPull, List<String> inclusions, FederationPullStatus status) {
        this.mirror = mirror;
        this.mergeAccounts = mergeAccounts;
        this.notifyOnError = notifyOnError;
        this.url = url;
        this.token = token;
        this.frequency = frequency;
        this.results = results;
        this.folder = folder;
        this.name = name;
        this.sendStatus = sendStatus;
        this.lastPull = lastPull;
        this.bare = bare;
        this.exclusions = exclusions;
        this.nextPull = nextPull;
        this.inclusions = inclusions;
        this.status = status;
    }

    public boolean isMirror() {
        return mirror;
    }

    public boolean mergeAccounts() {
        return mergeAccounts;
    }

    public boolean notifyOnError() {
        return notifyOnError;
    }

    public String getUrl() {
        return url;
    }

    public String getToken() {
        return token;
    }

    public String getFrequency() {
        return frequency;
    }

    public Map<String, FederationPullStatus> getResults() {
        return results;
    }

    public String getFolder() {
        return folder;
    }

    public String getName() {
        return name;
    }

    public boolean sendStatus() {
        return sendStatus;
    }

    public Date getLastPull() {
        return lastPull;
    }

    public boolean isBare() {
        return bare;
    }

    public List<String> getExclusions() {
        return exclusions;
    }

    public Date getNextPull() {
        return nextPull;
    }

    public List<String> getInclusions() {
        return inclusions;
    }

    public FederationPullStatus getStatus() {
        return status;
    }

    public List<RepositoryStatus> getStatusList() {
        // TODO: Implement this method
        throw new UnsupportedOperationException(""Not yet implemented"");
    }

    public void updateStatus(FederationPullStatus status) {
        // TODO: Implement this method
        throw new UnsupportedOperationException(""Not yet implemented"");
    }

    public FederationPullStatus getLowestStatus() {
        // TODO: Implement this method
        throw new UnsupportedOperationException(""Not yet implemented"");
    }

    @Override
    public String toString() {
        return ""FederationPullRegistration{"" +
                ""mirror="" + mirror +
                "", mergeAccounts="" + mergeAccounts +
                "", notifyOnError="" + notifyOnError +
                "", url='"" + url + '\'' +
                "", token='"" + token + '\'' +
                "", frequency='"" + frequency + '\'' +
                "", results="" + results +
                "", folder='"" + folder + '\'' +
                "", name='"" + name + '\'' +
                "", sendStatus="" + sendStatus +
                "", lastPull="" + lastPull +
                "", bare="" + bare +
                "", exclusions="" + exclusions +
                "", nextPull="" + nextPull +
                "", inclusions="" + inclusions +
                "", status="" + status +
                '}';
    }

    @Override
    public int compareTo(FederationPullRegistration other) {
        // TODO: Implement this method
        throw new UnsupportedOperationException(""Not yet implemented"");
    }

    public boolean isIncluded(String repositoryName) {
        // TODO: Implement this method
        throw new UnsupportedOperationException(""Not yet implemented"");
    }
}"
248,"// Create a scriptPubKey that encodes payment to the given raw public key.
import org.bitcoinj.core.ECKey;
import org.bitcoinj.script.ScriptBuilder;
import org.bitcoinj.script.ScriptChunk;

public class ScriptPubKey {
    private ECKey ecKey;
    private byte[] rawPublicKey;

    public ScriptPubKey(ECKey ecKey) {
        this.ecKey = ecKey;
        this.rawPublicKey = ecKey.getPubKey();
    }

    public List<ScriptChunk> encodePayment() {
        return new ScriptBuilder()
                .op(ScriptOpCodes.OP_DUP)
                .op(ScriptOpCodes.OP_HASH160)
                .data(rawPublicKey)
                .op(ScriptOpCodes.OP_EQUALVERIFY)
                .op(ScriptOpCodes.OP_CHECKSIG)
                .build();
    }
}"
249,"public class CookieManager {
    private final TreeSet<Cookie> cookies;
    private static final long serialVersionUID = 1L;

    public CookieManager() {
        this.cookies = new TreeSet<>();
    }

    public void addCookie(Cookie cookie) {
        if (cookie != null && !cookie.hasExpired()) {
            cookies.add(cookie);
        }
    }

    public boolean clearExpired() {
        boolean removedAny = false;
        Iterator<Cookie> iterator = cookies.iterator();
        while (iterator.hasNext()) {
            Cookie cookie = iterator.next();
            if (cookie.hasExpired()) {
                iterator.remove();
                removedAny = true;
            }
        }
        return removedAny;
    }

    public List<Cookie> getCookies() {
        return new ArrayList<>(cookies);
    }

    public void clear() {
        cookies.clear();
    }

    @Override
    public String toString() {
        return ""CookieManager{"" +
                ""cookies="" + cookies +
                '}';
    }
}"
25,"import java.util.List;

public class TokenProvider {
    private List<AttributeStatementProvider> attributeStatementProviders;
    private SubjectProvider subjectProvider;
    private ConditionsProvider conditionsProvider;
    private boolean signToken;

    public void setSubjectProvider(SubjectProvider subjectProvider) {
        this.subjectProvider = subjectProvider;
    }

    public void setAttributeStatementProviders(List<AttributeStatementProvider> attributeStatementProviders) {
        this.attributeStatementProviders = attributeStatementProviders;
    }

    public void setConditionsProvider(ConditionsProvider conditionsProvider) {
        this.conditionsProvider = conditionsProvider;
    }

    public boolean isSignToken() {
        return signToken;
    }

    public void setSignToken(boolean signToken) {
        this.signToken = signToken;
    }

    public TokenProviderResponse createToken() {
        // Create a new token provider response object
        TokenProviderResponse response = new TokenProviderResponse();

        // Check if the subject provider is set
        if (subjectProvider == null) {
            LOG.error(""Subject provider not set"");
            return null;
        }

        // Check if the attribute statement providers are set
        if (attributeStatementProviders == null || attributeStatementProviders.isEmpty()) {
            LOG.error(""Attribute statement providers not set"");
            return null;
        }

        // Check if the conditions provider is set
        if (conditionsProvider == null) {
            LOG.error(""Conditions provider not set"");
            return null;
        }

        // Create a new SAML assertion wrapper object
        SamlAssertionWrapper samlAssertionWrapper = new SamlAssertionWrapper();

        // Set the subject provider on the SAML assertion wrapper
        samlAssertionWrapper.setSubjectProvider(subjectProvider);

        // Set the attribute statement providers on the SAML assertion wrapper
        for (AttributeStatementProvider attributeStatementProvider : attributeStatementProviders) {
            samlAssertionWrapper.addAttributeStatementProvider(attributeStatementProvider);
        }

        // Set the conditions provider on the SAML assertion wrapper
        samlAssertionWrapper.setConditionsProvider(conditionsProvider);

        // Create a new callback handler object
        SamlCallbackHandler callbackHandler = new SamlCallbackHandler();

        // Set the subject provider on the callback handler
        callbackHandler.setSubjectProvider(subjectProvider);

        // Set the attribute statement providers on the callback handler
        for (AttributeStatementProvider attributeStatementProvider : attributeStatementProviders) {
            callbackHandler.addAttributeStatementProvider(attributeStatementProvider);
        }

        // Set the conditions provider on the callback handler
        callbackHandler.setConditionsProvider(conditionsProvider);

        // Create a new SAML token object
        SamlToken samlToken = new SamlToken();

        // Set the subject provider on the SAML token
        samlToken.setSubjectProvider(subjectProvider);

        // Set the attribute statement providers on the SAML token
        for (AttributeStatementProvider attributeStatementProvider : attributeStatementProviders) {
            samlToken.addAttributeStatementProvider(attributeStatementProvider);
        }

        // Set the conditions provider on the SAML token
        samlToken.setConditionsProvider(conditionsProvider);

        // Set the sign token flag on the SAML token
        samlToken.setSignToken(signToken);

        // Return the SAML token object
        return samlToken;
    }
}"
250,"public class Point2D {
    private double x;
    private double y;

    public Point2D(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double distance() {
        return Math.sqrt((this.x - this.y) * (this.x - this.y));
    }
}"
251,"import java.util.List;
import java.util.Random;
import java.util.logging.Logger;

class MyClass {
    private static final Logger LOG = Logger.getLogger(MyClass.class.getName());
    private static final Random RANDOM = new Random();
    private static final String ALPHANUM = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";

    public static String randomString() {
        return toString(RANDOM.nextInt());
    }

    public static void sleepMs(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            LOG.warning(""Sleep interrupted"");
        }
    }

    public static String stripPrefixIfPresent(String str, String prefix) {
        if (str == null || prefix == null) {
            return str;
        }
        if (str.startsWith(prefix)) {
            return str.substring(prefix.length());
        }
        return str;
    }

    public static String stripSuffixIfPresent(String str, String suffix) {
        if (str == null || suffix == null) {
            return str;
        }
        if (str.endsWith(suffix)) {
            return str.substring(0, str.length() - suffix.length());
        }
        return str;
    }

    public static String getPrimaryGroupName(String user) {
        return stripSuffixIfPresent(user, ""_at_domain"");
    }

    public static List<String> getUnixGroups(String user) {
        // This method gets the groups for a given user from a Unix system.
        // It returns a list of group names.
        return null;
    }

    public static long getCurrentMs() {
        return System.currentTimeMillis();
    }

    public static String toString(int i) {
        return String.valueOf(i);
    }

    public static void warmUpLoop() {
        // This method is used for performance testing. It loops over a list of objects and performs some operations on them.
    }

    public static void waitFor(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            LOG.warning(""Sleep interrupted"");
        }
    }

    public static String[] toStringArray(List<String> list) {
        return list.toArray(new String[0]);
    }

    public static List<String> getGroups(String user) {
        // This method gets the groups for a given user from a Unix system.
        // It returns a list of group names.
        return null;
    }

    public static byte[] randomBytes(int size) {
        return new byte[size];
    }
}"
252,"import java.util.Map;
import java.util.HashMap;

public class MyHashMap implements Map<Object, Object> {
    private int _size;
    private int[] _values;
    private int _mask;
    private static final Object NULL = new Object();
    private Object[] _keys;

    public MyHashMap() {
        _size = 0;
        _values = new int[16];
        _mask = 0xF;
        _keys = new Object[16];
    }

    public int get(Object key) {
        if (key == null) {
            return NULL;
        }
        for (int i = 0; i < _size; i++) {
            if (_keys[i].equals(key)) {
                return _values[i];
            }
        }
        return NULL;
    }

    public void clear() {
        _size = 0;
        _values = new int[16];
        _mask = 0xF;
        _keys = new Object[16];
    }

    public void resize(int newSize) {
        if (newSize <= 0) {
            throw new IllegalArgumentException(""New size must be positive"");
        }
        int[] newValues = new int[newSize];
        Object[] newKeys = new Object[newSize];
        for (int i = 0; i < _size; i++) {
            newValues[i] = _values[i];
            newKeys[i] = _keys[i];
        }
        _values = newValues;
        _keys = newKeys;
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        for (int i = 0; i < _size; i++) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(_keys[i]).append(""="").append(_values[i]);
        }
        sb.append(""}"");
        return sb.toString();
    }

    public int put(Object key, int value) {
        if (key == null || value < 0) {
            throw new IllegalArgumentException(""Key and value must be non-null and positive"");
        }
        for (int i = 0; i < _size; i++) {
            if (_keys[i].equals(key)) {
                int oldValue = _values[i];
                _values[i] = value;
                return oldValue;
            }
        }
        if (_size == _mask) {
            resize(_size * 2);
        }
        _keys[_size] = key;
        _values[_size] = value;
        _size++;
        return NULL;
    }

    public int remove(Object key) {
        if (key == null) {
            return NULL;
        }
        for (int i = 0; i < _size; i++) {
            if (_keys[i].equals(key)) {
                int oldValue = _values[i];
                _values[i] = NULL;
                _keys[i] = NULL;
                return oldValue;
            }
        }
        return NULL;
    }
}"
26,"// Java code for the ShadowStruggles game
public class ShadowStruggles {
    // Array of textures to be loaded into memory
    private Array<Asset> textures;

    // Array of sounds to be loaded into memory
    private Array<Asset> sounds;

    // Array of RPG maps to be loaded into memory
    private Array<Asset> rpgMaps;

    // String representing the name of the asset being loaded
    private String assetName;

    // Array of texture regions to be loaded into memory
    private Array<TextureRegion> textureRegions;

    // Logging object used for debugging purposes
    private static final Logger LOG = LoggerFactory.getLogger(ShadowStruggles.class);

    // Load the maps into memory
    public void loadMaps() {
        // TODO: Implement method to load maps into memory
    }

    // Get a texture region from the loaded textures
    public TextureRegion getTextureRegion(String name) {
        // TODO: Implement method to get a texture region by name
    }

    // Load the textures into memory
    public void loadTextures() {
        // TODO: Implement method to load textures into memory
    }

    // Dispose of the textures in memory
    public void disposeTextures() {
        // TODO: Implement method to dispose of textures in memory
    }

    // Load the sounds into memory
    public void loadSounds() {
        // TODO: Implement method to load sounds into memory
    }

    // Unload the sounds from memory
    public void unloadSounds() {
        // TODO: Implement method to unload sounds from memory
    }

    // Dispose of the maps in memory
    public void disposeMaps() {
        // TODO: Implement method to dispose of maps in memory
    }

    // Get a tiled map by name
    public TiledMap getTiledMap(String name) {
        // TODO: Implement method to get a tiled map by name
    }

    // Load the texture atlas into memory
    public void loadTextureAtlas() {
        // TODO: Implement method to load texture atlas into memory
    }

    // Dispose of the texture atlas in memory
    public void disposeAtlas() {
        // TODO: Implement method to dispose of texture atlas in memory
    }
}"
27,"import java.util.List;
import java.util.Map;

public class ProjectManager {
    private IStoredSettings settings;
    private IRuntimeManager runtimeManager;
    private FileBasedConfig projectConfigs;
    private Logger logger;
    private IRepositoryManager repositoryManager;
    private Map<String, ProjectModel> projectCache;
    private IUserManager userManager;
    private ObjectCache<String> projectMarkdownCache;
    private ObjectCache<String> projectRepositoriesMarkdownCache;

    public ProjectManager(IStoredSettings settings, IRuntimeManager runtimeManager, FileBasedConfig projectConfigs, Logger logger, IRepositoryManager repositoryManager, Map<String, ProjectModel> projectCache, IUserManager userManager, ObjectCache<String> projectMarkdownCache, ObjectCache<String> projectRepositoriesMarkdownCache) {
        this.settings = settings;
        this.runtimeManager = runtimeManager;
        this.projectConfigs = projectConfigs;
        this.logger = logger;
        this.repositoryManager = repositoryManager;
        this.projectCache = projectCache;
        this.userManager = userManager;
        this.projectMarkdownCache = projectMarkdownCache;
        this.projectRepositoriesMarkdownCache = projectRepositoriesMarkdownCache;
    }

    public ProjectModel getProjectConfigs(String projectId) {
        return projectCache.get(projectId);
    }

    public List<ProjectModel> getProjectModels() {
        return new ArrayList<>(projectCache.values());
    }

    public void start() {
        // Start the project manager
    }

    public void stop() {
        // Stop the project manager
    }

    public void reloadProjectMarkdown(String projectId) {
        // Reload the markdown for the specified project
    }
}"
28,"import java.util.Map;

public class Color {
    private int r, g, b;
    private Map<RGB, String> namedColors;

    public Color(int r, int g, int b) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.namedColors = new HashMap<>();
    }

    public static Optional<String> getNamedColor(int r, int g, int b) {
        Color color = new Color(r, g, b);
        return color.getNamedColor();
    }

    public Optional<String> getNamedColor() {
        double minDistSq = Double.MAX_VALUE;
        String closestName = null;

        for (RGB namedColor : namedColors.keySet()) {
            double distSq = calculateColorDistSq(namedColor);
            if (distSq < minDistSq) {
                minDistSq = distSq;
                closestName = namedColors.get(namedColor);
            }
        }

        return Optional.ofNullable(closestName);
    }

    public double calculateColorDistSq(int r, int g, int b) {
        // Calculate the distance between the given color and this color
        // using a suitable algorithm (e.g., Euclidean distance)
        return Math.pow((r - this.r), 2) + Math.pow((g - this.g), 2) + Math.pow((b - this.b), 2);
    }
}"
29,"package com.example;

import java.util.logging.Logger;

public class FileSource {
    private static final Logger LOG = Logger.getLogger(FileSource.class.getName());

    // Data source as a pseudo file name
    private String fauxFileName;

    // Source object type
    private String type;

    // Schema of the data source
    private String schema;

    // Revision of the data source
    private String revision;

    public void setName(String name) {
        this.fauxFileName = ""file_"" + name + ""_"" + getSuffixFromType();
    }

    public String getName() {
        return fauxFileName;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getSchema() {
        return schema;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public String getRevision() {
        return revision;
    }

    public void setRevision(String revision) {
        this.revision = revision;
    }

    private String getSuffixFromType() {
        switch (type) {
            case ""java"":
                return "".java"";
            case ""python"":
                return "".py"";
            default:
                throw new IllegalArgumentException(""Unsupported type: "" + type);
        }
    }

    @Override
    public String toString() {
        return fauxFileName;
    }
}"
3,"import static org.hamcrest.CoreMatchers.*;

public class MatcherTest {
  @Test
  public void testGreaterThan() {
    // Arrange
    int expected = 2;
    int actual = 1;

    // Act
    boolean result = greaterThan(expected).matches(actual);

    // Assert
    assertThat(result, is(true));
  }
}"
30,Here is a Java class that implements the NetworkParameters interface and provides the necessary methods to represent network parameters:
31,"import java.util.*;
import redis.clients.jedis.Jedis;

public class RedisIndex {
    private Jedis jedis;
    private String urlSetKey;
    private String termCounterKey;
    private Set<String> termSet;
    private Map<String, Integer> counts;

    public RedisIndex(Jedis jedis) {
        this.jedis = jedis;
        this.urlSetKey = ""urlset:"";
        this.termCounterKey = ""termcounter:"";
        this.termSet = new HashSet<>();
        this.counts = new HashMap<>();
    }

    public void add(String url) {
        jedis.sadd(urlSetKey + url, 1);
    }

    public boolean isIndexed(String url) {
        return jedis.exists(urlSetKey + url);
    }

    public void deleteAllKeys() {
        Set<String> keys = jedis.keys(""*"");
        for (String key : keys) {
            jedis.del(key);
        }
    }

    public Map<String, Integer> getCounts() {
        return counts;
    }

    public void main() {
        String[] urls = {""https://www.example1.com"", ""https://www.example2.com""};
        for (String url : urls) {
            add(url);
        }
        System.out.println(""URLs indexed: "" + getCounts());
    }

    public void printIndex() {
        Set<String> keys = jedis.keys(urlSetKey + ""*"");
        for (String key : keys) {
            System.out.println(key);
        }
    }

    private void pushTermCounterToRedis(String term, Integer count) {
        jedis.hset(termCounterKey + term, count);
    }

    public void loadIndex() {
        Set<String> keys = jedis.keys(urlSetKey + ""*"");
        for (String key : keys) {
            String url = key.substring(key.indexOf("":"") + 1);
            int count = Integer.parseInt(jedis.get(key));
            pushTermCounterToRedis(url, count);
        }
    }

    public void deleteTermCounters() {
        Set<String> keys = jedis.keys(termCounterKey + ""*"");
        for (String key : keys) {
            jedis.del(key);
        }
    }

    public Set<String> getURLs() {
        return termSet;
    }

    private Map<String, Integer> getCountsFaster() {
        return counts;
    }

    public void indexPage(String url) {
        add(url);
        int count = Integer.parseInt(jedis.get(urlSetKey + url));
        pushTermCounterToRedis(url, count);
    }

    public void deleteURLSets() {
        Set<String> keys = jedis.keys(urlSetKey + ""*"");
        for (String key : keys) {
            jedis.del(key);
        }
    }

    public Set<String> getTermCounterKeys() {
        return termSet;
    }
}"
32,"// Java code for the given task

import java.util.Set;

public class BlockMetadataManagerView {
  private StorageDir mDir;
  private long mBlocksToMoveOutSize;
  private long mBlocksToMoveInSize;
  private StorageTierView mTierView;
  private Set<Long> mBlocksToMoveIn;
  private Set<Long> mBlocksToMoveOut;

  public BlockMetadataManagerView(StorageDir dir) {
    mDir = dir;
  }

  // Clears all marks about blocks to move in/out in this view
  public void clearAllMarkedBlocks() {
    mBlocksToMoveIn.clear();
    mBlocksToMoveOut.clear();
  }

  // Returns the number of bytes that can be evicted from this view
  public long getEvitableBytes() {
    return mBlocksToMoveOutSize - mBlocksToMoveInSize;
  }

  // Returns the parent tier view of this block metadata manager view
  public StorageTierView getParentTierView() {
    return mTierView.getParent();
  }

  // Returns true if the given block is marked to move out in this view
  public boolean isMarkedToMoveOut(long blockId) {
    return mBlocksToMoveOut.contains(blockId);
  }

  // Marks the given block as move in in this view
  public void markBlockMoveIn(long blockId) {
    mBlocksToMoveIn.add(blockId);
    mBlocksToMoveOutSize -= getCommittedBytes(blockId);
  }

  // Creates a new temp block meta with the given block ID and size
  public TempBlockMeta createTempBlockMeta(long blockId, long size) {
    return new TempBlockMeta(mDir.getBlockStoreLocation(), blockId, size);
  }

  // Returns the index of the dir view in this block metadata manager view
  public int getDirViewIndex() {
    return mDir.getViewIndex();
  }

  // Returns the committed bytes of the given block ID
  public long getCommittedBytes(long blockId) {
    return mDir.getBlockMeta(blockId).getCommittedBytes();
  }

  // Returns a list of evictable blocks in this view
  public List<BlockMeta> getEvictableBlocks() {
    return mDir.getEvictableBlocks();
  }

  // Returns the capacity bytes of this block metadata manager view
  public long getCapacityBytes() {
    return mDir.getCapacityBytes();
  }

  // Returns the available bytes of this block metadata manager view
  public long getAvailableBytes() {
    return mDir.getAvailableBytes();
  }

  // Converts this block metadata manager view to a block store location
  public BlockStoreLocation toBlockStoreLocation() {
    return mDir.toBlockStoreLocation();
  }

  // Marks the given block as move out in this view
  public void markBlockMoveOut(long blockId) {
    mBlocksToMoveOut.add(blockId);
    mBlocksToMoveInSize -= getCommittedBytes(blockId);
  }
}"
33,"public class OAuthToken {
    private final long issuedAt;
    private final List<OAuthPermission> scopes;
    private final UserSubject subject;
    private final Client client;
    private final boolean preAuthorized;
    private final String tokenString;
    private final long lifetime;
    private final String tokenSecret;

    public OAuthToken(long issuedAt, List<OAuthPermission> scopes, UserSubject subject, Client client, boolean preAuthorized, String tokenString, long lifetime, String tokenSecret) {
        this.issuedAt = issuedAt;
        this.scopes = scopes;
        this.subject = subject;
        this.client = client;
        this.preAuthorized = preAuthorized;
        this.tokenString = tokenString;
        this.lifetime = lifetime;
        this.tokenSecret = tokenSecret;
    }

    public void setScopes(List<OAuthPermission> scopes) {
        this.scopes = scopes;
    }

    public void setPreAuthorized(boolean preAuthorized) {
        this.preAuthorized = preAuthorized;
    }

    public void setSubject(UserSubject subject) {
        this.subject = subject;
    }

    public String getTokenKey() {
        return tokenString;
    }

    public boolean isPreAuthorized() {
        return preAuthorized;
    }

    public long getLifetime() {
        return lifetime;
    }

    public Client getClient() {
        return client;
    }

    public long getIssuedAt() {
        return issuedAt;
    }

    public String getTokenSecret() {
        return tokenSecret;
    }

    public List<OAuthPermission> getScopes() {
        return scopes;
    }
}"
34,"public static int getIntFromFormat(String format, int formatOff) {
    // Check if there is an explicit repeat count in the format string
    int formatRepeatCount = -1;
    if (format.charAt(formatOff) == '*') {
        formatRepeatCount = Integer.parseInt(format.substring(formatOff + 1));
    }

    // If there is no explicit repeat count, return 1
    if (formatRepeatCount < 0) {
        return 1;
    }

    // Return the parsed value of the repeat count
    return formatRepeatCount;
}"
35,"public class ErrorMsg {
    private Long expectedDataUnitId;
    private Long seqNo;
    private Long dataSetId;
    private Long dataUnitId;
    private String expectedValue;
    private String actualValue;
    private Long expectedDataSetId;
    private String errorCode;
    private Long testId;
    private String failedAttributeName;
    private String srcFileName;

    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }

    public String getExpectedValue() {
        return expectedValue;
    }

    public Long getExpectedDataSetId() {
        return expectedDataSetId;
    }

    public void setExpectedDataSetId(Long expectedDataSetId) {
        this.expectedDataSetId = expectedDataSetId;
    }

    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public Long getExpectedDataUnitId() {
        return expectedDataUnitId;
    }

    public void setExpectedDataUnitId(Long expectedDataUnitId) {
        this.expectedDataUnitId = expectedDataUnitId;
    }

    public String getSrcFileName() {
        return srcFileName;
    }

    public Long getSeqNo() {
        return seqNo;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public void setFailedAttributeName(String failedAttributeName) {
        this.failedAttributeName = failedAttributeName;
    }

    public Long getTestId() {
        return testId;
    }

    public String getFailedAttributeName() {
        return failedAttributeName;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getActualValue() {
        return actualValue;
    }

    public Long getDataUnitId() {
        return dataUnitId;
    }

    public void setSeqNo(Long seqNo) {
        this.seqNo = seqNo;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public void setDataUnitId(Long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }

    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }

    @Override
    public String toString() {
        return ""ErrorMsg{"" +
                ""expectedDataUnitId="" + expectedDataUnitId +
                "", seqNo="" + seqNo +
                "", dataSetId="" + dataSetId +
                "", dataUnitId="" + dataUnitId +
                "", expectedValue='"" + expectedValue + '\'' +
                "", actualValue='"" + actualValue + '\'' +
                "", expectedDataSetId="" + expectedDataSetId +
                "", errorCode='"" + errorCode + '\'' +
                "", testId="" + testId +
                "", failedAttributeName='"" + failedAttributeName + '\'' +
                "", srcFileName='"" + srcFileName + '\'' +
                '}';
    }
}"
36,"import java.util.HashMap;

public class SymbolSet {
    private HashMap<String, symbol> _all;

    public SymbolSet() {
        this._all = new HashMap<>();
    }

    // determines if the set contains a particular symbol
    public boolean contains(symbol s) {
        return _all.containsKey(s);
    }

    // adds a symbol to the set, returns true if successful
    public boolean add(symbol s) {
        return _all.put(s, s) == null;
    }

    // removes a symbol from the set, returns true if successful
    public void remove(symbol s) {
        _all.remove(s);
    }

    // iterates over the symbols in the set
    public Iterator<symbol> iterator() {
        return _all.keySet().iterator();
    }

    // returns the number of symbols in the set
    public int size() {
        return _all.size();
    }

    // returns a hash code for the set
    public int hashCode() {
        return _all.hashCode();
    }

    // determines if the set is a subset of another set
    public boolean isSubsetOf(SymbolSet other) {
        return this._all.keySet().containsAll(other.iterator());
    }

    // determines if the set is a superset of another set
    public boolean isSupersetOf(SymbolSet other) {
        return other.isSubsetOf(this);
    }

    // determines if two sets are equal
    public boolean equals(Object other) {
        if (other instanceof SymbolSet) {
            SymbolSet otherSet = (SymbolSet) other;
            return this._all.equals(otherSet._all);
        } else {
            return false;
        }
    }

    // returns a string representation of the set
    public String toString() {
        return _all.toString();
    }
}"
37,"import java.util.*;
import javax.xml.namespace.*;
import javax.xml.xpath.*;

public class NodeUtils {
  public static String mergeChildren(Node node) {
    List<String> childValues = new ArrayList<>();
    for (Node child : node.getDirectChildren()) {
      if (child instanceof Text || child instanceof CDATA) {
        childValues.add(child.getValue());
      }
    }
    return String.join("" "", childValues);
  }
}"
38,"// Get the marshal registry from the context, or create a new one if necessary.
MarshalRegistry marshalRegistry = (MarshalRegistry) context.get(MarshalRegistry.class);
if (marshalRegistry == null) {
    marshalRegistry = new MarshalRegistry();
    context.put(MarshalRegistry.class, marshalRegistry);
}

// Get the next ID for the instance.
int nextId = marshalRegistry.getNextId();

// Store the instance in the registry with its ID.
marshalRegistry.addInstance(nextId, instance);

// Return the ID of the instance.
return String.valueOf(nextId);"
39,"package com.example;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

public class Example {
    public static <T> List<T> getNonNullList(List<T> list1, List<T> list2) {
        return Stream.of(list1, list2)
                .filter(Objects::nonNull)
                .findFirst()
                .orElse(new ArrayList<>());
    }

    public static <T> T firstOrElse(List<T> list, T defaultValue) {
        return list.stream().findFirst().orElse(defaultValue);
    }

    public static <T> boolean equals(List<T> list1, List<T> list2) {
        return list1.equals(list2);
    }

    public static <U> Iterator<Pair<T, T>> pairs(List<U> list) {
        return list.stream().map(u -> new Pair<>(u, u)).iterator();
    }
}"
4,"public class Denominator {
    private int num;
    private int denom;

    public Denominator(int num, int denom) {
        this.num = num;
        this.denom = denom;
    }

    public int getDenom() {
        return denom;
    }

    public int getNum() {
        return num;
    }

    public boolean isOne() {
        return denom == 1;
    }

    public int getScaled(int scale) {
        return num * scale / denom;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof Denominator) {
            Denominator otherDenom = (Denominator) other;
            return this.num == otherDenom.getNum() && this.denom == otherDenom.getDenom();
        } else {
            return false;
        }
    }
}"
40,"// Set the value of the parametersmetadata property
void setParametersMetaData(ParametersMetaData parametersMetaData) {
  this.parametersMetaData = parametersMetaData;
}

// Get the value of the parametersmetadata property
ParametersMetaData getParametersMetaData() {
  return this.parametersMetaData;
}

// Set the ID of the workflow implementation
void setWorkflowImplId(String workflowImplId) {
  this.workflowImplId = workflowImplId;
}

// Get the ID of the workflow implementation
String getWorkflowImplId() {
  return this.workflowImplId;
}

// Set the name of the workflow implementation
void setWorkflowImplName(String workflowImplName) {
  this.workflowImplName = workflowImplName;
}

// Get the name of the workflow implementation
String getWorkflowImplName() {
  return this.workflowImplName;
}

// Set the description of the workflow implementation
void setWorkflowImplDescription(String workflowImplDescription) {
  this.workflowImplDescription = workflowImplDescription;
}

// Get the description of the workflow implementation
String getWorkflowImplDescription() {
  return this.workflowImplDescription;
}

// Set the ID of the template
void setTemplateId(String templateId) {
  this.templateId = templateId;
}

// Get the ID of the template
String getTemplateId() {
  return this.templateId;
}

// Set the name of the template
void setTemplateName(String templateName) {
  this.templateName = templateName;
}

// Get the name of the template
String getTemplateName() {
  return this.templateName;
}

// Set the description of the template
void setTemplateDescription(String templateDescription) {
  this.templateDescription = templateDescription;
}

// Get the description of the template
String getTemplateDescription() {
  return this.templateDescription;
}"
41,"public class DetailsTab {
    private static final long serialVersionUID = 1L;

    private String aboutName;

    public DetailsTab(String name) {
        this.aboutName = name;
    }

    public String getName() {
        return aboutName;
    }

    public String getInfo() {
        // TODO: add logic to retrieve information about the tab
        return null;
    }

    public boolean enable() {
        // TODO: add logic to enable the tab
        return false;
    }

    public boolean disable() {
        // TODO: add logic to disable the tab
        return false;
    }
}"
42,"import java.io.*;

public class XMLStreamWriter {
    private OutputStream output;

    public XMLStreamWriter(OutputStream output) {
        this.output = output;
    }

    public void writeCharacterBytes(byte[] bytes) throws IOException {
        for (byte b : bytes) {
            output.write(b);
        }
    }

    public void processGroupStart() {}

    public void processDocumentEnd() {}

    public void processGroupEnd() {}

    public void processCommand() {}

    public void processString(String s) throws IOException {
        writeCharacterBytes(s.getBytes(""UTF-8""));
    }

    public void processDocumentStart() {}

    public void processBinaryBytes(byte[] bytes) throws IOException {
        writeCharacterBytes(bytes);
    }
}"
43,"import java.math.BigDecimal;
import java.sql.Timestamp;

public class DataSet {
    private long serialVersionUID = 1L;
    private boolean isSystemDerived;
    private String status;
    private BigDecimal predecessorId;
    private BigDecimal successorId;
    private BigDecimal feedId;
    private String checksum;
    private String transmissionDatasetId;
    private String comments;
    private String inactivationReasonType;
    private boolean isFormatValid;
    private long dataUnitId;
    private Timestamp receiptDate;
    private String srcFileName;
    private String destFileName;
    private String loadedInCats;
    private String checksumType;
    private Timestamp modifiedDate;
    private BigDecimal runId;
    private boolean isPrepopulated;
    private boolean isBulk;
    private boolean isUpdate;
    private String receiptDateType;
    
    public void setIsSystemDerived(boolean isSystemDerived) {
        this.isSystemDerived = isSystemDerived;
    }
    
    public void setIsPrepopulated(boolean isPrepopulated) {
        this.isPrepopulated = isPrepopulated;
    }
    
    public String getStatus() {
        return status;
    }
    
    public boolean getIsUpdate() {
        return isUpdate;
    }
    
    public long getDataUnitId() {
        return dataUnitId;
    }
    
    public BigDecimal getFileSize() {
        return fileSize;
    }
    
    public void setInactivationReasonType(String inactivationReasonType) {
        this.inactivationReasonType = inactivationReasonType;
    }
    
    public void setDataUnitId(long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }
    
    public String getComments() {
        return comments;
    }
    
    public Timestamp getCreatedDate() {
        return createdDate;
    }
    
    public void setFileSize(BigDecimal fileSize) {
        this.fileSize = fileSize;
    }
    
    public BigDecimal getPredecessorId() {
        return predecessorId;
    }
    
    public void setIsUpdate(boolean isUpdate) {
        this.isUpdate = isUpdate;
    }
    
    public String getReceiptDateType() {
        return receiptDateType;
    }
    
    public BigDecimal getFeedId() {
        return feedId;
    }
    
    public void setReceiptDate(Timestamp receiptDate) {
        this.receiptDate = receiptDate;
    }
    
    public Timestamp getModifiedDate() {
        return modifiedDate;
    }
    
    public void setSuccessorId(BigDecimal successorId) {
        this.successorId = successorId;
    }
    
    public void setDestFileName(String destFileName) {
        this.destFileName = destFileName;
    }
    
    public String getIsFormatValid() {
        return isFormatValid;
    }
    
    public void setLoadedInCats(String loadedInCats) {
        this.loadedInCats = loadedInCats;
    }
    
    public BigDecimal getSuccessorId() {
        return successorId;
    }
    
    public String getIsBulk() {
        return isBulk;
    }
    
    public void setChecksumType(String checksumType) {
        this.checksumType = checksumType;
    }
    
    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }
    
    public String getInactivationReasonType() {
        return inactivationReasonType;
    }
    
    public String getSrcUniqueFileName() {
        return srcUniqueFileName;
    }
    
    public void setReceiptDateType(String receiptDateType) {
        this.receiptDateType = receiptDateType;
    }
    
    public Long getDataSetId() {
        return dataSetId;
    }
    
    public void setIsFormatValid(boolean isFormatValid) {
        this.isFormatValid = isFormatValid;
    }
    
    public void setDataUnitId(long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }
    
    public String getComments() {
        return comments;
    }
    
    public Timestamp getCreatedDate() {
        return createdDate;
    }
    
    public void setIsBulk(boolean isBulk) {
        this.isBulk = isBulk;
    }
    
    public String getIsPrepopulated() {
        return isPrepopulated;
    }
    
    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }
    
    public String getIsSystemDerived() {
        return isSystemDerived;
    }
    
    public void setReceiptDate(Timestamp receiptDate) {
        this.receiptDate = receiptDate;
    }
    
    public BigDecimal getRunId() {
        return runId;
    }
    
    public void setIsActive(boolean isActive) {
        this.isActive = isActive;
    }
    
    public boolean getIsUpdate() {
        return isUpdate;
    }
    
    public String getLoadedInCats() {
        return loadedInCats;
    }
    
    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }
    
    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }
    
    public String getIsBulk() {
        return isBulk;
    }
    
    public void setSuccessorId(BigDecimal successorId) {
        this.successorId = successorId;
    }
    
    public String getChecksumType() {
        return checksumType;
    }
    
    public String getIsFormatValid() {
        return isFormatValid;
    }
    
    public void setSrcUniqueFileName(String srcUniqueFileName) {
        this.srcUniqueFileName = srcUniqueFileName;
    }
    
    public BigDecimal getFileSize() {
        return fileSize;
    }
    
    public String getIsActive() {
        return isActive;
    }
    
    public void setComments(String comments) {
        this.comments = comments;
    }
    
    public String getTransmissionDatasetId() {
        return transmissionDatasetId;
    }
    
    public void setIsPrepopulated(boolean isPrepopulated) {
        this.isPrepopulated = isPrepopulated;
    }
    
    public void setCreatedDate(Timestamp createdDate) {
        this.createdDate = createdDate;
    }
    
    public String getIsBulk() {
        return isBulk;
    }
    
    public void setChecksumType(String checksumType) {
        this.checksumType = checksumType;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setInactivationReasonType(String inactivationReasonType) {
        this.inactivationReasonType = inactivationReasonType;
    }
    
    public BigDecimal getPredecessorId() {
        return predecessorId;
    }
    
    public void setIsActive(boolean isActive) {
        this.isActive = isActive;
    }
    
    public Timestamp getReceiptDate() {
        return receiptDate;
    }
    
    public String getSrcFileName() {
        return srcFileName;
    }
    
    public void setModifiedDate(Timestamp modifiedDate) {
        this.modifiedDate = modifiedDate;
    }
    
    public String getIsFormatValid() {
        return isFormatValid;
    }
    
    public String getLoadedInCats() {
        return loadedInCats;
    }
    
    public void setReceiptDateType(String receiptDateType) {
        this.receiptDateType = receiptDateType;
    }
    
    public String getChecksum() {
        return checksum;
    }
    
    public BigDecimal getSuccessorId() {
        return successorId;
    }
    
    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }
    
    public String getIsSystemDerived() {
        return isSystemDerived;
    }
    
    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }
    
    public String getComments() {
        return comments;
    }
    
    public String getIsPrepopulated() {
        return isPrepopulated;
    }
    
    public void setIsUpdate(boolean isUpdate) {
        this.isUpdate = isUpdate;
    }
    
    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }
    
    public Timestamp getModifiedDate() {
        return modifiedDate;
    }
    
    public String getTransmissionDatasetId() {
        return transmissionDatasetId;
    }
    
    public void setIsSystemDerived(boolean isSystemDerived) {
        this.isSystemDerived = isSystemDerived;
    }
    
    public void setDataUnitId(long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }
    
    public String getIsFormatValid() {
        return isFormatValid;
    }
    
    public BigDecimal getRunId() {
        return runId;
    }
    
    public void setFileSize(BigDecimal fileSize) {
        this.fileSize = fileSize;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setInactivationReasonType(String inactivationReasonType) {
        this.inactivationReasonType = inactivationReasonType;
    }
    
    public void setIsFormatValid(boolean isFormatValid) {
        this.isFormatValid = isFormatValid;
    }
    
    public String getLoadedInCats() {
        return loadedInCats;
    }
    
    public void setSuccessorId(BigDecimal successorId) {
        this.successorId = successorId;
    }
    
    public void setIsPrepopulated(boolean isPrepopulated) {
        this.isPrepopulated = isPrepopulated;
    }
    
    public void setSrcUniqueFileName(String srcUniqueFileName) {
        this.srcUniqueFileName = srcUniqueFileName;
    }
    
    public String getIsBulk() {
        return isBulk;
    }
    
    public void setDestFileName(String destFileName) {
        this.destFileName = destFileName;
    }
    
    public void setComments(String comments) {
        this.comments = comments;
    }
    
    public String getChecksum() {
        return checksum;
    }
    
    public Timestamp getReceiptDate() {
        return receiptDate;
    }
    
    public void setIsBulk(boolean isBulk) {
        this.isBulk = isBulk;
    }
    
    public String getSrcFileName() {
        return srcFileName;
    }
    
    public Long getDataSetId() {
        return dataSetId;
    }
    
    public void setReceiptDateType(String receiptDateType) {
        this.receiptDateType = receiptDateType;
    }
    
    public String getInactivationReasonType() {
        return inactivationReasonType;
    }
    
    public void setIsFormatValid(boolean isFormatValid) {
        this.isFormatValid = isFormatValid;
    }
    
    public void setChecksumType(String checksumType) {
        this.checksumType = checksumType;
    }
    
    public String getLoadedInCats() {
        return loadedInCats;
    }
    
    public void setIsUpdate(boolean isUpdate) {
        this.isUpdate = isUpdate;
    }
    
    public Timestamp getCreatedDate() {
        return createdDate;
    }
    
    public BigDecimal getPredecessorId() {
        return predecessorId;
    }
    
    public void setIsSystemDerived(boolean isSystemDerived) {
        this.isSystemDerived = isSystemDerived;
    }
    
    public String getChecksumType() {
        return checksumType;
    }
    
    public String getDestFileName() {
        return destFileName;
    }
    
    public void setIsPrepopulated(boolean isPrepopulated) {
        this.isPrepopulated = isPrepopulated;
    }
    
    public boolean getIsUpdate() {
        return isUpdate;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setComments(String comments) {
        this.comments = comments;
    }
    
    public String getInactivationReasonType() {
        return inactivationReasonType;
    }
    
    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }
    
    public Timestamp getModifiedDate() {
        return modifiedDate;
    }
    
    public BigDecimal getFeedId() {
        return feedId;
    }
    
    public void setIsFormatValid(boolean isFormatValid) {
        this.isFormatValid = isFormatValid;
    }
    
    public String getReceiptDateType() {
        return receiptDateType;
    }
    
    public String getSrcUniqueFileName() {
        return srcUniqueFileName;
    }
    
    public void setIsActive(boolean isActive) {
        this.isActive = isActive;
    }
    
    public Long getDataUnitId() {
        return dataUnitId;
    }
    
    public String getChecksumType() {
        return checksumType;
    }
}"
44,"// Factory for DataServer
public class DataServerFactory {
    private static final Map<String, DataServer> servers = new HashMap<>();

    public static DataServer getDataServer(String bindHost) {
        return servers.computeIfAbsent(bindHost, key -> new DataServer(key));
    }
}

// DataServer class
public class DataServer {
    private final String bindHost;
    private int port;
    private boolean closed;

    public DataServer(String bindHost) {
        this.bindHost = bindHost;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public boolean isClosed() {
        return closed;
    }

    public void close() {
        closed = true;
    }

    public String getBindHost() {
        return bindHost;
    }
}"
45,"import org.bitcoinj.core.ECKey;
import org.bitcoinj.crypto.ChildNumber;
import org.bitcoinj.script.Script;
import org.bitcoinj.script.ScriptBuilder;
import org.bitcoinj.wallet.RedeemData;

import java.util.List;

public class RedeemDataHelper {
    public static String getFirstKeyPrivateBytes(List<ECKey> keys, Script redeemScript) {
        for (ECKey key : keys) {
            if (key.getPrivKey() != null && !key.isPubOnly()) {
                return key.getPrivKey().toString();
            }
        }
        return null;
    }
}"
46,"public class DestroyInstrumentationService {
    private static final String JVM_INSTRUMENTATION_GROUP = ""JVM.instrumentation"";
    private static final String CONF_PREFIX = ""conf."";
    private static final String CONF_LOGGING_INTERVAL = CONF_PREFIX + ""logging.interval"";

    public void init() {
        // Get the instrumentation service interface class
        Class<? extends Service> interfaceClass = getInterface();

        // Get the instrumentation service instance from the registry
        Instrumentation instrumentation = Registry.get(interfaceClass).getInstance();

        // Destroy the instrumentation service
        instrumentation.destroy();
    }

    private Class<? extends Service> getInterface() {
        return XLog.class;
    }

    private String mapToString(Map<String, Object> map) {
        StringBuilder sb = new StringBuilder();
        for (Entry<String, Object> entry : map.entrySet()) {
            if (sb.length() > 0) {
                sb.append("", "");
            }
            sb.append(entry.getKey()).append(""="").append(entry.getValue());
        }
        return sb.toString();
    }
}"
47,"import java.util.List;

public class TokenSigner {
    private String c14nAlgorithm;
    private String digestAlgorithm;
    private long minimumKeySize;
    private boolean useKeyValue;
    private List<String> acceptedC14nAlgorithms;
    private List<String> acceptedSignatureAlgorithms;
    private long maximumKeySize;
    private long keySize;
    private String signatureAlgorithm;

    public TokenSigner() {
        this.c14nAlgorithm = ""http://www.w3.org/2001/10/xml-exc-c14n#"";
        this.digestAlgorithm = ""SHA-512"";
        this.minimumKeySize = 512;
        this.useKeyValue = false;
        this.acceptedC14nAlgorithms = List.of(""http://www.w3.org/2001/10/xml-exc-c14n#"");
        this.acceptedSignatureAlgorithms = List.of(""RSA-SHA512"");
        this.maximumKeySize = 512;
    }

    public String getC14nAlgorithm() {
        return c14nAlgorithm;
    }

    public void setC14nAlgorithm(String c14nAlgorithm) {
        this.c14nAlgorithm = c14nAlgorithm;
    }

    public String getDigestAlgorithm() {
        return digestAlgorithm;
    }

    public void setDigestAlgorithm(String digestAlgorithm) {
        this.digestAlgorithm = digestAlgorithm;
    }

    public long getMinimumKeySize() {
        return minimumKeySize;
    }

    public void setMinimumKeySize(long minimumKeySize) {
        this.minimumKeySize = minimumKeySize;
    }

    public boolean isUseKeyValue() {
        return useKeyValue;
    }

    public void setUseKeyValue(boolean useKeyValue) {
        this.useKeyValue = useKeyValue;
    }

    public List<String> getAcceptedC14nAlgorithms() {
        return acceptedC14nAlgorithms;
    }

    public void setAcceptedC14nAlgorithms(List<String> acceptedC14nAlgorithms) {
        this.acceptedC14nAlgorithms = acceptedC14nAlgorithms;
    }

    public List<String> getAcceptedSignatureAlgorithms() {
        return acceptedSignatureAlgorithms;
    }

    public void setAcceptedSignatureAlgorithms(List<String> acceptedSignatureAlgorithms) {
        this.acceptedSignatureAlgorithms = acceptedSignatureAlgorithms;
    }

    public long getMaximumKeySize() {
        return maximumKeySize;
    }

    public void setMaximumKeySize(long maximumKeySize) {
        this.maximumKeySize = maximumKeySize;
    }

    public String getSignatureAlgorithm() {
        return signatureAlgorithm;
    }

    public void setSignatureAlgorithm(String signatureAlgorithm) {
        this.signatureAlgorithm = signatureAlgorithm;
    }

    public long getKeySize() {
        return keySize;
    }

    public void setKeySize(long keySize) {
        this.keySize = keySize;
    }
}"
48,"// Java code to implement the Task described above
import java.util.ArrayList;
import java.util.List;
import com.google.cloud.bigquery.BigQuery;
import com.google.cloud.bigquery.BigQueryOptions;
import com.google.cloud.bigquery.TableResult;
import com.google.cloud.bigquery.FieldValueList;
import com.google.cloud.bigquery.Schema;
import com.google.cloud.bigquery.FieldValue;
import com.google.cloud.bigquery.QueryJobConfiguration;
import com.google.cloud.bigquery.JobId;
import com.google.cloud.bigquery.JobInfo;
import com.google.cloud.bigquery.BigQueryException;

public class BigQueryScanner {
    private String joinfield;
    private int idx;
    private TableResult result;
    private boolean hasField = false;
    private List<String> fieldValues;

    public BigQueryScanner(String joinfield, int idx) {
        this.joinfield = joinfield;
        this.idx = idx;
    }

    // Initialize the scanner with a table result
    public void init(TableResult result) throws Exception {
        this.result = result;
        hasField = false;
        fieldValues = new ArrayList<>();
    }

    // Reset the index to the beginning of the scan
    public void resetIndex() {
        idx = 0;
    }

    // Advance to the next row in the scan
    public boolean next() throws Exception {
        if (idx < result.getTotalRows()) {
            hasField = true;
            FieldValueList row = result.getValues().get(idx);
            String fieldValue = null;
            for (FieldValue value : row) {
                if (value.getName().equals(joinfield)) {
                    fieldValue = value.getStringValue();
                    break;
                }
            }
            if (fieldValue != null) {
                fieldValues.add(fieldValue);
            }
            idx++;
            return true;
        } else {
            hasField = false;
            return false;
        }
    }

    // Get the integer value of the specified field
    public int getInt() throws Exception {
        if (!hasField) {
            throw new IllegalStateException(""No more fields to read"");
        }
        return Integer.parseInt(fieldValues.get(idx - 1));
    }

    // Get the string value of the specified field
    public String getString() throws Exception {
        if (!hasField) {
            throw new IllegalStateException(""No more fields to read"");
        }
        return fieldValues.get(idx - 1);
    }

    // Close the scanner and release resources
    public void close() {
        result = null;
        hasField = false;
        fieldValues = null;
    }

    // Check if there are more fields to read in the current row
    public boolean hasField() {
        return hasField;
    }
}"
49,"public class NetworkParameters {
    public static final String ID_UNITTESTNET = ""unittestnet"";
    public static final long MAX_COINS = 21000000L;
    public static final int INTERVAL = 107600;
    public static final int p2shHeader = 13;
    public static final int PROTOCOL_VERSION = 70014;
    public static final BigInteger maxTarget = new BigInteger(""0ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"", 16);
    public static final int TARGET_SPACING = 10 * 60;
    public static final String[] dnsSeeds = {
        ""unittestnet-seed.bitcoin.org"",
        ""s3v3nh4cks5hz3lx.onion""
    };
    public static final String id = ID_UNITTESTNET;
    public static final int spendableCoinbaseDepth = 100;
    public static final int dumpedPrivateKeyHeader = 29;
    public static final int targetTimespan = 14 * 24 * 60 * 60;
    public static final String PAYMENT_PROTOCOL_ID_MAINNET = ""main"";
    public static final int addressHeader = 111;
    public static final Coin MAX_MONEY = new Coin(21000000, false);
    public static final int bip32HeaderPriv = 0x0488ade4;
    public static final byte[] alertSigningKey = Hex.decode(""04f80a2d5679621eaa1cfbdb0438fc33721ebc6a921a8102e61b117cd15df59f1"");
    public static final int[] acceptableAddressCodes = {
        1,  // P2PKH
        16  // P2SH
    };
    public static final String ID_MAINNET = ""main"";
    public static final long packetMagic = 0xfabfb5daL;
    public static final byte[] SATOSHI_KEY = Hex.decode(""04318dcac6a757a32c96e91dea8c2d36f91f3bab615d8dd4b70b36be897ae15ef"");
    public static final Block genesisBlock = new Block(
            new Transaction(
                    new ArrayList<>(Arrays.asList(new Input())),
                    new ArrayList<>(Arrays.asList(new Output(""040184710fa689ad5023690c80f3a49c8af2e6314f93d0aae478101280dd6436""))),
                    0,
                    ""01000000"" +
                            ""01ffffff"" +
                            ""01"" +
                            ""ffffffff"" +
                            ""01000000"",
                    1,
                    1576498134L,
                    new ArrayList<>(Arrays.asList(new TransactionOutput()))),
            2083236893L,
            ""main"");
    public static final String PAYMENT_PROTOCOL_ID_TESTNET = ""test"";
    public static final int subsidyDecreaseBlockCount = 500;
    public static final int port = 19333;
    public static final Map<Integer, Sha256Hash> checkpoints = new HashMap<>();
    public static final String ID_REGTEST = ""regtest"";
    public static final int BIP16_ENFORCE_TIME = 1333238400;
    public static final NetworkParameters regTests = new NetworkParameters(
            true,
            257,
            1,
            new ArrayList<>(Arrays.asList(new Input())),
            new ArrayList<>(Arrays.asList(new Output(""040184710fa689ad5023690c80f3a49c8af2e6314f93d0aae478101280dd6436""))),
            0,
            ""01000000"" +
                    ""01ffffff"" +
                    ""01"" +
                    ""ffffffff"" +
                    ""01000000"",
            1,
            1576498134L,
            new ArrayList<>(Arrays.asList(new TransactionOutput())),
            2083236893L,
            ""main"");
    public static final NetworkParameters testNet2 = new NetworkParameters(
            true,
            257,
            1,
            new ArrayList<>(Arrays.asList(new Input())),
            new ArrayList<>(Arrays.asList(new Output(""040184710fa689ad5023690c80f3a49c8af2e6314f93d0aae478101280dd6436""))),
            0,
            ""01000000"" +
                    ""01ffffff"" +
                    ""01"" +
                    ""ffffffff"" +
                    ""01000000"",
            1,
            1576498134L,
            new ArrayList<>(Arrays.asList(new TransactionOutput())),
            2083236893L,
            ""main"");
    public static final NetworkParameters testNet3 = new NetworkParameters(
            true,
            257,
            1,
            new ArrayList<>(Arrays.asList(new Input())),
            new ArrayList<>(Arrays.asList(new Output(""040184710fa689ad5023690c80f3a49c8af2e6314f93d0aae478101280dd6436""))),
            0,
            ""01000000"" +
                    ""01ffffff"" +
                    ""01"" +
                    ""ffffffff"" +
                    ""01000000"",
            1,
            1576498134L,
            new ArrayList<>(Arrays.asList(new TransactionOutput())),
            2083236893L,
            ""main"");
    public static final NetworkParameters unitTests = new NetworkParameters(
            true,
            257,
            1,
            new ArrayList<>(Arrays.asList(new Input())),
            new ArrayList<>(Arrays.asList(new Output(""040184710fa689ad5023690c80f3a49c8af2e6314f93d0aae478101280dd6436""))),
            0,
            ""01000000"" +
                    ""01ffffff"" +
                    ""01"" +
                    ""ffffffff"" +
                    ""01000000"",
            1,
            1576498134L,
            new ArrayList<>(Arrays.asList(new TransactionOutput())),
            2083236893L,
            ""main"");
    public static final String getId() {
        return id;
    }
    public static final String getPaymentProtocolId() {
        return PAYMENT_PROTOCOL_ID_MAINNET;
    }
    public static final int getAddressHeader() {
        return addressHeader;
    }
    public static final int[] getAcceptableAddressCodes() {
        return acceptableAddressCodes;
    }
    public static final NetworkParameters getProdNet() {
        return prodNet;
    }
    public static final NetworkParameters fromID(String id) {
        if (id.equals(""main"")) {
            return main;
        } else if (id.equals(""test"")) {
            return test;
        } else if (id.equals(""regtest"")) {
            return regTest;
        } else {
            throw new IllegalArgumentException(String.format(""Unknown network ID: %s"", id));
        }
    }
    public static final NetworkParameters fromPmtProtocolID(String pmtProtocolId) {
        if (pmtProtocolId.equals(""main"")) {
            return main;
        } else if (pmtProtocolId.equals(""test"")) {
            return test;
        } else if (pmtProtocolId.equals(""regtest"")) {
            return regTest;
        } else {
            throw new IllegalArgumentException(String.format(""Unknown payment protocol ID: %s"", pmtProtocolId));
        }
    }
}"
5,"import java.util.ArrayList;

public class GenericJSONBuilder {
    private HashMap<String, Object> json = new HashMap<>();

    public GenericJSONBuilder() {}

    public GenericJSONBuilder setIDstr(String id_str) {
        this.json.put(""id_str"", id_str);
        return this;
    }

    public GenericJSONBuilder setPlaceName(String place_name) {
        this.json.put(""place_name"", place_name);
        return this;
    }

    public GenericJSONBuilder addText(String text) {
        if (this.json.containsKey(""text"")) {
            ArrayList<String> texts = (ArrayList<String>) this.json.get(""text"");
            texts.add(text);
        } else {
            ArrayList<String> texts = new ArrayList<>();
            texts.add(text);
            this.json.put(""text"", texts);
        }
        return this;
    }

    public GenericJSONBuilder addField(String field, Object value) {
        if (this.json.containsKey(field)) {
            ArrayList<Object> values = (ArrayList<Object>) this.json.get(field);
            values.add(value);
        } else {
            ArrayList<Object> values = new ArrayList<>();
            values.add(value);
            this.json.put(field, values);
        }
        return this;
    }

    public void insert(String key, Object value) {
        if (this.json.containsKey(key)) {
            throw new IllegalArgumentException(""The key already exists"");
        } else {
            this.json.put(key, value);
        }
    }

    public GenericJSONBuilder setCoordinateRadius(double loc_radius) {
        this.json.put(""loc_radius"", loc_radius);
        return this;
    }

    public GenericJSONBuilder setAuthor(String author) {
        this.json.put(""author"", author);
        return this;
    }

    public GenericJSONBuilder builder() {
        return new GenericJSONBuilder();
    }

    public GenericJSONBuilder setCoordinate(double lat, double lng) {
        HashMap<String, Double> coordinate = new HashMap<>();
        coordinate.put(""lat"", lat);
        coordinate.put(""lng"", lng);
        this.json.put(""coordinate"", coordinate);
        return this;
    }

    public GenericJSONBuilder setCreatedTime(Date created_at) {
        this.json.put(""created_at"", created_at);
        return this;
    }

    public void persist() {
        // code to persist the JSON object in a database or file system
    }

    public String buildFieldJSON(String field) {
        return (String) this.json.get(field);
    }

    public GenericJSONBuilder setUserid(String user_id) {
        this.json.put(""user_id"", user_id);
        return this;
    }
}"
50,"package org.bitcoinj.core;

import com.google.common.base.Preconditions;
import com.google.common.primitives.Longs;

public class Coin {
    private long value;

    public static final int SMALLEST_UNIT_EXPONENT = 8;
    public static final long COIN_VALUE = Long.MAX_VALUE >>> SMALLEST_UNIT_EXPONENT;
    public static final Coin SATOSHI = Coin.valueOf(1, 0);
    public static final Coin CENT = Coin.valueOf(COIN_VALUE / 100, 2);
    public static final Coin FIFTY_COINS = Coin.valueOf(50 * COIN_VALUE, 2);
    public static final Coin NEGATIVE_SATOSHI = Coin.valueOf(-1L, 0);
    public static final Coin MILLICOIN = Coin.valueOf(COIN_VALUE / 1000, 3);
    public static final long MAX_SATOSHIS = COIN_VALUE * 21; // 21 million satoshis
    public static final Coin ZERO = Coin.valueOf(0L, 0);

    public Coin() {
        this.value = 0;
    }

    public Coin(long value) {
        this.value = value;
    }

    public static Coin valueOf(int value, int exponent) {
        return new Coin(Longs.checkedMultiply(COIN_VALUE, Math.max(0, value), exponent));
    }

    public int signum() {
        return Long.signum(this.value);
    }

    public boolean isNegative() {
        return this.value < 0;
    }

    public boolean isLessThan(Coin other) {
        return this.compareTo(other) < 0;
    }

    public Coin valueOf(long value, int exponent) {
        return new Coin(Longs.checkedMultiply(COIN_VALUE, Math.max(0, value), exponent));
    }

    public Coin add(Coin other) {
        return Coin.valueOf(this.value + other.value);
    }

    public Coin subtract(Coin other) {
        return Coin.valueOf(this.value - other.value);
    }

    public int compareTo(Coin other) {
        return Long.compare(this.value, other.value);
    }

    public long longValue() {
        return this.value;
    }

    public static Coin parseCoin(String str) {
        Preconditions.checkNotNull(str);
        String[] parts = str.split(""\\."");
        if (parts.length != 2) {
            throw new IllegalArgumentException(""Invalid coin amount: "" + str);
        }
        long value = Longs.tryParse(parts[0]);
        if (value == null) {
            throw new NumberFormatException(""Invalid coin amount: "" + str);
        }
        int exponent = parts[1].length();
        return Coin.valueOf(value, exponent);
    }

    public String toFriendlyString() {
        return this.toPlainString();
    }

    public Coin shiftLeft(int n) {
        return Coin.valueOf(this.value << n);
    }

    public Coin shiftRight(int n) {
        return Coin.valueOf(this.value >>> n);
    }

    public Coin[] divideAndRemainder(Coin divisor) {
        long quotient = this.value / divisor.value;
        long remainder = this.value % divisor.value;
        return new Coin[]{Coin.valueOf(quotient), Coin.valueOf(remainder)};
    }

    public int hashCode() {
        return Longs.hashCode(this.value);
    }

    public Coin negate() {
        return Coin.valueOf(-this.value);
    }

    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof Coin)) {
            return false;
        }
        return ((Coin) obj).value == this.value;
    }

    public boolean isZero() {
        return this.value == 0L;
    }

    public boolean isPositive() {
        return this.value > 0;
    }

    public Coin divide(Coin divisor) {
        return Coin.valueOf(this.value / divisor.value);
    }

    public long divide(int n) {
        return this.value / n;
    }

    public String toString() {
        return Long.toString(this.value);
    }

    public Coin multiply(long factor) {
        return Coin.valueOf(Longs.checkedMultiply(this.value, factor));
    }
}"
51,"import android.view.MenuItem;

public class MyActivity extends Activity {
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.action_settings:
                // Do something when the ""Settings"" menu item is selected
                break;
            case R.id.action_search:
                // Do something when the ""Search"" menu item is selected
                break;
        }
        return super.onOptionsItemSelected(item);
    }
}"
52,"package com.example;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.HashMap;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class NotificationControllerTest {

    @Mock
    private ServerMessage mockServerMessage;

    @Mock
    private ServerSession mockServerSession;

    @InjectMocks
    private NotificationController notificationController;

    private Map<String, Object> testEventProperties;

    private static final String MOCK_SESSION_ID = ""mock_session_id"";

    @Before
    public void setUp() {
        testEventProperties = new HashMap<>();
        testEventProperties.put(""user"", ""testUser"");
        testEventProperties.put(""application"", ""testApplication"");
        testEventProperties.put(""title"", ""Test Title"");
        testEventProperties.put(""message"", ""Test Message"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testRegisterUserSessionThrowsIllegalArgumentExceptionOnNullServerSession() {
        notificationController.registerUserSession(null, mockServerSession);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testRegisterUserSessionThrowsIllegalArgumentExceptionOnNullServerSessionId() {
        notificationController.registerUserSession("""", mockServerSession);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeregisterUserSessionThrowsIllegalArgumentExceptionOnNullServerSession() {
        notificationController.deregisterUserSession(null, MOCK_SESSION_ID);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeregisterUserSessionThrowsIllegalArgumentExceptionOnEmptyUserId() {
        notificationController.deregisterUserSession("""", MOCK_SESSION_ID);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeregisterUserSessionThrowsIllegalArgumentExceptionOnNullSessionId() {
        notificationController.deregisterUserSession(""testUser"", null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeletePersistentNotificationThrowsIllegalArgumentExceptionOnNullUserId() {
        notificationController.deletePersistentNotification(null, ""testTitle"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeletePersistentNotificationThrowsIllegalArgumentExceptionOnEmptyUserId() {
        notificationController.deletePersistentNotification("""", ""testTitle"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeletePersistentNotificationThrowsIllegalArgumentExceptionOnNullTitle() {
        notificationController.deletePersistentNotification(""testUser"", null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDeletePersistentNotificationThrowsIllegalArgumentExceptionOnEmptyTitle() {
        notificationController.deletePersistentNotification(""testUser"", """");
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnNullServerMessage() {
        assertThatThrownBy(() -> notificationController.handleEvent(null)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyUserId() {
        testEventProperties.put(""user"", """");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyApplication() {
        testEventProperties.put(""application"", """");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyTitle() {
        testEventProperties.put(""title"", """");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnNullTitle() {
        testEventProperties.put(""title"", null);
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyMessage() {
        testEventProperties.put(""message"", """");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnNullMessage() {
        testEventProperties.put(""message"", null);
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnNullTimestamp() {
        when(mockServerMessage.getProperty(""timestamp"")).thenReturn(null);
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyTimestamp() {
        when(mockServerMessage.getProperty(""timestamp"")).thenReturn("""");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnNullUser() {
        when(mockServerSession.getProperty(""user"")).thenReturn(null);
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyUser() {
        when(mockServerSession.getProperty(""user"")).thenReturn("""");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnNullApplication() {
        when(mockServerSession.getProperty(""application"")).thenReturn(null);
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyApplication() {
        when(mockServerSession.getProperty(""application"")).thenReturn("""");
        assertThatThrownBy(() -> notificationController.handleEvent(mockServerMessage)).isInstanceOf(IllegalArgumentException.class);
    }
}"
53,"import java.text.SimpleDateFormat;
import java.util.Date;

public class Time {
    private static final String TIME_PATTERN = ""HH:mm:ss"";

    private int offsetHours;
    private int offsetMinutes;
    private double seconds;
    private int minutes;
    private int hour;

    public Time(int hours, int minutes) {
        this.offsetHours = hours;
        this.offsetMinutes = minutes;
        this.seconds = 0;
        this.minutes = minutes;
        this.hour = hours;
    }

    public void setOffsetHours(int offsetHours) {
        this.offsetHours = offsetHours;
    }

    public int getOffsetHours() {
        return offsetHours;
    }

    public Date toDate() {
        SimpleDateFormat sdf = new SimpleDateFormat(TIME_PATTERN);
        String timeString = sdf.format(this.hour, this.minutes, (int) this.seconds);
        return sdf.parse(timeString);
    }

    public String toISO8601() {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"");
        return sdf.format(toDate());
    }

    public void setMinutes(int minutes) {
        this.minutes = minutes;
    }

    public int getMinutes() {
        return minutes;
    }

    public double getSeconds() {
        return seconds;
    }

    public void setHour(int hour) {
        this.hour = hour;
    }

    public int getHour() {
        return hour;
    }

    public long getMilliseconds() {
        return (long) (seconds * 1000);
    }

    public void setOffsetMinutes(int offsetMinutes) {
        this.offsetMinutes = offsetMinutes;
    }

    public int getOffsetMinutes() {
        return offsetMinutes;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Time) {
            Time other = (Time) obj;
            return this.offsetHours == other.getOffsetHours() &&
                   this.offsetMinutes == other.getOffsetMinutes() &&
                   this.seconds == other.getSeconds();
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + offsetHours;
        result = 31 * result + offsetMinutes;
        result = 31 * result + (int) seconds;
        return result;
    }

    @Override
    public String toString() {
        SimpleDateFormat sdf = new SimpleDateFormat(TIME_PATTERN);
        return sdf.format(toDate());
    }
}"
54,"import java.net.*;

public class DatagramPacket {
    private byte[] data;
    private int offset;
    private int length;
    private ServiceID serviceID;
    private InetAddress address;
    private SocketAddress socketAddress;

    public DatagramPacket(byte[] data, int offset, int length, ServiceID serviceID, InetAddress address) {
        this.data = data;
        this.offset = offset;
        this.length = length;
        this.serviceID = serviceID;
        this.address = address;
    }

    public void setServiceID(ServiceID serviceID) {
        this.serviceID = serviceID;
    }

    public ServiceID getServiceID() {
        return serviceID;
    }

    public void setLengthOnly(int length) {
        this.length = length;
    }

    public void setLength(int length) {
        this.length = length;
    }

    public void setAddress(InetAddress address) {
        this.address = address;
    }

    public void setData(byte[] data, int offset, int length) {
        this.data = data;
        this.offset = offset;
        this.length = length;
    }

    public void setSocketAddress(InetAddress address) {
        this.socketAddress = new SocketAddress(address);
    }

    public byte[] getData() {
        return data;
    }

    public int getOffset() {
        return offset;
    }

    public int getLength() {
        return length;
    }

    public InetAddress getAddress() {
        return address;
    }

    public SocketAddress getSocketAddress() {
        return socketAddress;
    }

    public int getCapacity() {
        return capacity;
    }
}"
55,"// Java code for the ChainFile class

import java.io.*;
import java.nio.*;
import java.util.*;
import org.slf4j.Logger;

public class ChainFile {
  private final ReentrantLock lock;
  private final StoredBlock lastChainHead;
  private final NetworkParameters params;
  private final String HEADER_MAGIC;
  private final int RECORD_SIZE;
  private final int FILE_PROLOGUE_BYTES;
  private final LinkedHashMap<Sha256Hash, Object> notFoundCache;
  private final int DEFAULT_NUM_HEADERS;
  private int numHeaders;
  private Object notFoundMarker;
  private FileLock fileLock;
  private RandomAccessFile randomAccessFile;
  private MappedByteBuffer buffer;
  private LinkedHashMap<Sha256Hash, StoredBlock> blockCache;

  public ChainFile(ReentrantLock lock, StoredBlock lastChainHead, NetworkParameters params) {
    this.lock = lock;
    this.lastChainHead = lastChainHead;
    this.params = params;
    this.HEADER_MAGIC = params.getHeaderMagic();
    this.RECORD_SIZE = params.getRecordSize();
    this.FILE_PROLOGUE_BYTES = params.getFilePrologueBytes();
    this.notFoundCache = new LinkedHashMap<Sha256Hash, Object>(DEFAULT_NUM_HEADERS) {
      @Override
      protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Object> eldest) {
        return size() > DEFAULT_NUM_HEADERS;
      }
    };
  }

  public void setRingCursor(StoredBlock ringCursor) {
    this.ringCursor = ringCursor;
  }

  public StoredBlock getChainHead() {
    return lastChainHead;
  }

  public void setChainHead(StoredBlock chainHead) {
    this.lastChainHead = chainHead;
  }

  public StoredBlock get(Sha256Hash hash) throws IOException {
    lock.lock();
    try {
      return blockCache.get(hash);
    } finally {
      lock.unlock();
    }
  }

  public int getRingCursor() {
    return numHeaders;
  }

  public void initNewStore(FileLock fileLock, RandomAccessFile randomAccessFile) throws IOException {
    this.fileLock = fileLock;
    this.randomAccessFile = randomAccessFile;
    buffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, FILE_PROLOGUE_BYTES + (RECORD_SIZE * DEFAULT_NUM_HEADERS));
  }

  public void close() throws IOException {
    if (buffer != null) {
      buffer.force();
    }
    fileLock.release();
    randomAccessFile.close();
  }

  public void put(Sha256Hash hash, StoredBlock block) throws IOException {
    lock.lock();
    try {
      notFoundCache.remove(hash);
      buffer.put(hash.getBytes());
      int offset = FILE_PROLOGUE_BYTES + (RECORD_SIZE * numHeaders);
      buffer.position(offset);
      block.writeTo(buffer);
      numHeaders++;
    } finally {
      lock.unlock();
    }
  }
}"
56,"public class DirectedAcyclicGraphNode<T> {
    private List<DirectedAcyclicGraphNode<T>> mParents;
    private List<DirectedAcyclicGraphNode<T>> mChildren;
    private T mPayload;

    public DirectedAcyclicGraphNode(T payload) {
        this.mPayload = payload;
        this.mParents = new ArrayList<>();
        this.mChildren = new ArrayList<>();
    }

    public List<DirectedAcyclicGraphNode<T>> getParents() {
        return mParents;
    }

    public void addParent(DirectedAcyclicGraphNode<T> parent) {
        if (parent == null) {
            throw new IllegalArgumentException(""Parent cannot be null"");
        }
        this.mParents.add(parent);
    }

    public void removeParent(DirectedAcyclicGraphNode<T> parent) {
        if (parent == null) {
            throw new IllegalArgumentException(""Parent cannot be null"");
        }
        this.mParents.remove(parent);
    }

    public List<DirectedAcyclicGraphNode<T>> getChildren() {
        return mChildren;
    }

    public void addChild(DirectedAcyclicGraphNode<T> child) {
        if (child == null) {
            throw new IllegalArgumentException(""Child cannot be null"");
        }
        this.mChildren.add(child);
    }

    public void removeChild(DirectedAcyclicGraphNode<T> child) {
        if (child == null) {
            throw new IllegalArgumentException(""Child cannot be null"");
        }
        this.mChildren.remove(child);
    }
}"
57,"import java.util.*;
import java.text.*;

public class Stat {
    private int idPath;
    private String ext;
    private Date addedDate;
    private int rating;
    private int previousPlayCounter;
    private Date ratingModifDate;
    private Date lastPlayed;
    private String relativeFullPath;
    private boolean updateRatingModifDate;
    private float BPM;
    private String sourceName;

    public Stat() {
        this.idPath = -1;
        this.ext = """";
        this.addedDate = null;
        this.rating = -1;
        this.previousPlayCounter = 0;
        this.ratingModifDate = null;
        this.lastPlayed = null;
        this.relativeFullPath = """";
        this.updateRatingModifDate = false;
        this.BPM = -1.0f;
        this.sourceName = """";
    }

    public int getIdPath() {
        return idPath;
    }

    public void setIdPath(int idPath) {
        this.idPath = idPath;
    }

    public String getExt() {
        return ext;
    }

    public void setExt(String ext) {
        this.ext = ext;
    }

    public Date getAddedDate() {
        return addedDate;
    }

    public void setAddedDate(Date addedDate) {
        this.addedDate = addedDate;
    }

    public int getRating() {
        return rating;
    }

    public void setRating(int rating) {
        this.rating = rating;
    }

    public int getPreviousPlayCounter() {
        return previousPlayCounter;
    }

    public void setPreviousPlayCounter(int previousPlayCounter) {
        this.previousPlayCounter = previousPlayCounter;
    }

    public Date getRatingModifDate() {
        return ratingModifDate;
    }

    public void setRatingModifDate(Date ratingModifDate) {
        this.ratingModifDate = ratingModifDate;
    }

    public Date getLastPlayed() {
        return lastPlayed;
    }

    public void setLastPlayed(Date lastPlayed) {
        this.lastPlayed = lastPlayed;
    }

    public String getRelativeFullPath() {
        return relativeFullPath;
    }

    public void setRelativeFullPath(String relativeFullPath) {
        this.relativeFullPath = relativeFullPath;
    }

    public boolean isUpdateRatingModifDate() {
        return updateRatingModifDate;
    }

    public void setUpdateRatingModifDate(boolean updateRatingModifDate) {
        this.updateRatingModifDate = updateRatingModifDate;
    }

    public float getBPM() {
        return BPM;
    }

    public void setBPM(float BPM) {
        this.BPM = BPM;
    }

    public String getSourceName() {
        return sourceName;
    }

    public void setSourceName(String sourceName) {
        this.sourceName = sourceName;
    }

    public int getIdFile() {
        return idFile;
    }

    public void setIdFile(int idFile) {
        this.idFile = idFile;
    }

    public String getFilename() {
        return filename;
    }

    public void setFilename(String filename) {
        this.filename = filename;
    }

    public boolean isDeleted() {
        return deleted;
    }

    public void setDeleted(boolean deleted) {
        this.deleted = deleted;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + idPath;
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof Stat)) {
            return false;
        }
        Stat other = (Stat) obj;
        if (idPath != other.idPath) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return ""Stat [idPath="" + idPath + "", ext="" + ext + "", addedDate="" + addedDate + "", rating="" + rating + "", previousPlayCounter="" + previousPlayCounter + "", ratingModifDate="" + ratingModifDate + "", lastPlayed="" + lastPlayed + "", relativeFullPath="" + relativeFullPath + "", updateRatingModifDate="" + updateRatingModifDate + "", BPM="" + BPM + "", sourceName="" + sourceName + "", idFile="" + idFile + "", filename="" + filename + "", deleted="" + deleted + ""]"";
    }

    public String getFormattedRatingModifDate() {
        DateFormat df = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return df.format(ratingModifDate);
    }

    public String getLastPlayedLocalTime() {
        if (lastPlayed == null) {
            return """";
        }
        DateFormat df = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return df.format(lastPlayed);
    }

    public String getAddedDateLocalTime() {
        if (addedDate == null) {
            return """";
        }
        DateFormat df = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return df.format(addedDate);
    }

    public String getRelativePath() {
        return relativePath;
    }

    public void setRelativePath(String relativePath) {
        this.relativePath = relativePath;
    }
}"
58,"public class DirectedAcyclicGraphNode<T> {
    private List<DirectedAcyclicGraphNode<T>> mParents;
    private List<DirectedAcyclicGraphNode<T>> mChildren;
    private T mPayload;

    public DirectedAcyclicGraphNode(T payload) {
        mPayload = payload;
        mParents = new ArrayList<>();
        mChildren = new ArrayList<>();
    }

    public List<DirectedAcyclicGraphNode<T>> getParents() {
        return mParents;
    }

    public T getPayload() {
        return mPayload;
    }

    public void removeChild(DirectedAcyclicGraphNode<T> child) {
        mChildren.remove(child);
    }

    public void addParent(DirectedAcyclicGraphNode<T> parent) {
        mParents.add(parent);
    }

    public void addChild(DirectedAcyclicGraphNode<T> child) {
        mChildren.add(child);
    }
}"
59,"public class StickyRecyclerHeadersAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
    private OrientationProvider mOrientationProvider;
    private DimensionCalculator mDimensionCalculator;
    private HeaderProvider mHeaderProvider;

    public StickyRecyclerHeadersAdapter(Context context, List<?> items) {
        super();
        this.mOrientationProvider = new OrientationProvider(context);
        this.mDimensionCalculator = new DimensionCalculator(context);
        this.mHeaderProvider = new HeaderProvider(items);
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View itemView = LayoutInflater.from(parent.getContext()).inflate(viewType, parent, false);
        return new CustomViewHolder(itemView);
    }

    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        if (holder instanceof CustomViewHolder) {
            ((CustomViewHolder) holder).bindItem((String) getItem(position));
        } else {
            throw new RuntimeException(""Invalid view holder type"");
        }
    }

    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position, List<Object> payloads) {
        if (holder instanceof CustomViewHolder) {
            ((CustomViewHolder) holder).bindItem((String) getItem(position));
        } else {
            throw new RuntimeException(""Invalid view holder type"");
        }
    }

    @Override
    public int getItemViewType(int position) {
        return mHeaderProvider.getHeaderTypeForIndex(position);
    }

    @Override
    public int getItemCount() {
        return mHeaderProvider.getHeadersCount();
    }

    private Object getItem(int position) {
        return mHeaderProvider.getHeaderForIndex(position);
    }

    private class CustomViewHolder extends RecyclerView.ViewHolder {
        private TextView mTextView;

        public CustomViewHolder(View itemView) {
            super(itemView);
            mTextView = (TextView) itemView.findViewById(R.id.text_view);
        }

        public void bindItem(String text) {
            mTextView.setText(text);
        }
    }
}"
6,"import java.util.HashMap;
import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;

public class XMPPConnectionFactory implements BundleActivator {

    @Override
    public void start(BundleContext context) throws Exception {
        // do nothing
    }

    @Override
    public void stop(BundleContext context) throws Exception {
        // unregister any registered services
        HashMap<String, XMPPConnectionFactory> factories = new HashMap<>();
        for (Map.Entry<String, XMPPConnectionFactory> entry : factories.entrySet()) {
            String key = entry.getKey();
            XMPPConnectionFactory factory = entry.getValue();
            context.unregisterService(key, factory, null);
        }
    }
}"
60,"import java.util.List;

public class TestResultDetailsDTO {
    private Long feedId;
    private Date lastModifiedTimeStamp;
    private Date fetcherStartTimeStamp;
    private Date createTimeStamp;
    private Long testId;
    private Long runId;
    private Date fetcherEndTimeStamp;
    private List<TestResultDetailsDTO> regTestResultDetailsLst;
    private OutcomeType outcome;
    private RunStatusType runStatus;
    private String errorMsg;

    public void setLastModifiedTimeStamp(Date lastModifiedTimeStamp) {
        this.lastModifiedTimeStamp = lastModifiedTimeStamp;
    }

    public Date getFetcherEndTimeStamp() {
        return fetcherEndTimeStamp;
    }

    public void setFeedId(Long feedId) {
        this.feedId = feedId;
    }

    public void setFetcherStartTimeStamp(Date fetcherStartTimeStamp) {
        this.fetcherStartTimeStamp = fetcherStartTimeStamp;
    }

    public Date getLastModifiedTimeStamp() {
        return lastModifiedTimeStamp;
    }

    public OutcomeType getOutcome() {
        return outcome;
    }

    public Long getRunId() {
        return runId;
    }

    public List<TestResultDetailsDTO> getRegTestResultDetailsLst() {
        return regTestResultDetailsLst;
    }

    public Long getFeedId() {
        return feedId;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public Long getTestId() {
        return testId;
    }

    public Date getFetcherStartTimeStamp() {
        return fetcherStartTimeStamp;
    }

    public void setRunId(Long runId) {
        this.runId = runId;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public void setFetcherEndTimeStamp(Date fetcherEndTimeStamp) {
        this.fetcherEndTimeStamp = fetcherEndTimeStamp;
    }

    public void setCreateTimeStamp(Date createTimeStamp) {
        this.createTimeStamp = createTimeStamp;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public RunStatusType getRunStatus() {
        return runStatus;
    }

    public Date getCreateTimeStamp() {
        return createTimeStamp;
    }

    public void setOutcome(OutcomeType outcome) {
        this.outcome = outcome;
    }

    @Override
    public String toString() {
        return ""TestResultDetailsDTO{"" +
                ""feedId="" + feedId +
                "", lastModifiedTimeStamp="" + lastModifiedTimeStamp +
                "", fetcherStartTimeStamp="" + fetcherStartTimeStamp +
                "", createTimeStamp="" + createTimeStamp +
                "", testId="" + testId +
                "", runId="" + runId +
                "", fetcherEndTimeStamp="" + fetcherEndTimeStamp +
                "", regTestResultDetailsLst="" + regTestResultDetailsLst +
                "", outcome="" + outcome +
                "", runStatus="" + runStatus +
                "", errorMsg='"" + errorMsg + '\'' +
                '}';
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setRunStatus(RunStatusType runStatus) {
        this.runStatus = runStatus;
    }
}"
61,"import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.List;

public class TestResultEntity {
    private long testId;
    private BigDecimal batchId;
    private BigDecimal runId;
    private Timestamp fetcherStartTimestamp;
    private Timestamp fetcherEndTimeStamp;
    private Timestamp lastModifiedTimeStamp;
    private Timestamp createTimeStamp;
    private String errorMsg;
    private OutcomeType outcomeType;
    private String createdBy;
    private List<RegPCLTestResultDetailsEntity> regPclTestResultDetails;
    private RunStatusType runStatus;

    public long getTestId() {
        return testId;
    }

    public void setTestId(long testId) {
        this.testId = testId;
    }

    public BigDecimal getBatchId() {
        return batchId;
    }

    public void setBatchId(BigDecimal batchId) {
        this.batchId = batchId;
    }

    public BigDecimal getRunId() {
        return runId;
    }

    public void setRunId(BigDecimal runId) {
        this.runId = runId;
    }

    public Timestamp getFetcherStartTimestamp() {
        return fetcherStartTimestamp;
    }

    public void setFetcherStartTimestamp(Timestamp fetcherStartTimestamp) {
        this.fetcherStartTimestamp = fetcherStartTimestamp;
    }

    public Timestamp getFetcherEndTimeStamp() {
        return fetcherEndTimeStamp;
    }

    public void setFetcherEndTimeStamp(Timestamp fetcherEndTimeStamp) {
        this.fetcherEndTimeStamp = fetcherEndTimeStamp;
    }

    public Timestamp getLastModifiedTimeStamp() {
        return lastModifiedTimeStamp;
    }

    public void setLastModifiedTimeStamp(Timestamp lastModifiedTimeStamp) {
        this.lastModifiedTimeStamp = lastModifiedTimeStamp;
    }

    public Timestamp getCreateTimeStamp() {
        return createTimeStamp;
    }

    public void setCreateTimeStamp(Timestamp createTimeStamp) {
        this.createTimeStamp = createTimeStamp;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public OutcomeType getOutcomeType() {
        return outcomeType;
    }

    public void setOutcomeType(OutcomeType outcomeType) {
        this.outcomeType = outcomeType;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public List<RegPCLTestResultDetailsEntity> getRegPclTestResultDetails() {
        return regPclTestResultDetails;
    }

    public void setRegPclTestResultDetails(List<RegPCLTestResultDetailsEntity> regPclTestResultDetails) {
        this.regPclTestResultDetails = regPclTestResultDetails;
    }

    public RunStatusType getRunStatus() {
        return runStatus;
    }

    public void setRunStatus(RunStatusType runStatus) {
        this.runStatus = runStatus;
    }
}"
62,"// Define the class and its methods here.

  public class TimeTest {

    private Time time;

    @BeforeEach
    void setUp() {
      time = new Time();
    }

    @Test
    void testParseTimeWithOneDecimal() {
      String timeStr = ""12:34.5"";
      time.setTime(timeStr);
      assertEquals(""12:34"", time.getTime());
      assertEquals(500, time.getMilliseconds());
    }

    @Test
    void testSetNegativeMinutes() {
      String timeStr = ""12:-34"";
      time.setTime(timeStr);
      assertEquals(""12:00"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testFormatTimeWithOneDecimal() {
      String timeStr = ""12:34"";
      time.setTime(timeStr);
      assertEquals(""12:34.0"", time.formatTime());
    }

    @Test
    void testSetMinutes() {
      String timeStr = ""12:56"";
      time.setTime(timeStr);
      assertEquals(""12:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testParseTimeWithoutDecimals() {
      String timeStr = ""12:34"";
      time.setTime(timeStr);
      assertEquals(""12:34"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testGetMinutes() {
      String timeStr = ""12:56"";
      time.setTime(timeStr);
      assertEquals(""12:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testParseTimeWithDecimals() {
      String timeStr = ""12:34.5"";
      time.setTime(timeStr);
      assertEquals(""12:34"", time.getTime());
      assertEquals(500, time.getMilliseconds());
    }

    @Test
    void testSetInvalidSeconds() {
      String timeStr = ""12:61"";
      time.setTime(timeStr);
      assertEquals(""13:00"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testSetNegativeHour() {
      String timeStr = ""-12:34"";
      time.setTime(timeStr);
      assertEquals(""00:00"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testToDate() {
      String dateStr = ""2023-01-01"";
      Date date = new Date();
      date.setDate(dateStr);
      assertEquals(""2023-01-01"", date.getDate());
    }

    @Test
    void testGetSeconds() {
      String timeStr = ""12:56"";
      time.setTime(timeStr);
      assertEquals(""12:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testSetHour() {
      String timeStr = ""13:56"";
      time.setTime(timeStr);
      assertEquals(""13:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testGetHour() {
      String timeStr = ""12:56"";
      time.setTime(timeStr);
      assertEquals(""12:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testSetSeconds() {
      String timeStr = ""12:56"";
      time.setTime(timeStr);
      assertEquals(""12:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testSetTime() {
      String timeStr = ""13:56"";
      time.setTime(timeStr);
      assertEquals(""13:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testGetMilliseconds() {
      String timeStr = ""12:56"";
      time.setTime(timeStr);
      assertEquals(""12:56"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testSetInvalidHour() {
      String timeStr = ""25:34"";
      time.setTime(timeStr);
      assertEquals(""00:00"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }

    @Test
    void testSetNegativeSeconds() {
      String timeStr = ""12:-56"";
      time.setTime(timeStr);
      assertEquals(""13:00"", time.getTime());
      assertEquals(0, time.getMilliseconds());
    }
  }
}"
63,"import java.util.*;

public class FeedSummary {
    private BigDecimal feedConfigId;
    private String resultCode;
    private long serialVersionUID;
    private String resultMessage;
    private BigDecimal fileCount;
    private Timestamp maxReceiptDate;
    private BigDecimal downloadSize;
    private BigDecimal feedId;
    private String configInfo;
    private long runId;
    private byte[] errors;
    private String runStatus;
    private Timestamp startDate;
    private Timestamp endDate;
    
    public FeedSummary() {}
    
    public void setFeedConfigId(BigDecimal feedConfigId) {
        this.feedConfigId = feedConfigId;
    }
    
    public BigDecimal getFeedConfigId() {
        return feedConfigId;
    }
    
    public void setStartDate(Timestamp startDate) {
        this.startDate = startDate;
    }
    
    public Timestamp getStartDate() {
        return startDate;
    }
    
    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }
    
    public BigDecimal getFeedId() {
        return feedId;
    }
    
    public void setResultCode(String resultCode) {
        this.resultCode = resultCode;
    }
    
    public String getResultCode() {
        return resultCode;
    }
    
    public void setMaxReceiptDate(Timestamp maxReceiptDate) {
        this.maxReceiptDate = maxReceiptDate;
    }
    
    public Timestamp getMaxReceiptDate() {
        return maxReceiptDate;
    }
    
    public void setDownloadSize(BigDecimal downloadSize) {
        this.downloadSize = downloadSize;
    }
    
    public BigDecimal getDownloadSize() {
        return downloadSize;
    }
    
    public void setFileCount(BigDecimal fileCount) {
        this.fileCount = fileCount;
    }
    
    public BigDecimal getFileCount() {
        return fileCount;
    }
    
    public void setResultMessage(String resultMessage) {
        this.resultMessage = resultMessage;
    }
    
    public String getResultMessage() {
        return resultMessage;
    }
    
    public void setErrors(byte[] errors) {
        this.errors = errors;
    }
    
    public byte[] getErrors() {
        return errors;
    }
    
    public void setRunStatus(String runStatus) {
        this.runStatus = runStatus;
    }
    
    public String getRunStatus() {
        return runStatus;
    }
    
    public void setEndDate(Timestamp endDate) {
        this.endDate = endDate;
    }
    
    public Timestamp getEndDate() {
        return endDate;
    }
}"
64,"import java.io.IOException;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.ImageWriteParam;

public class FSImageWriter {
    private ImageWriter writer;
    private ImageWriteParam writeParams;

    public FSImageWriter(String imageFormat) throws IOException {
        this.writer = ImageIO.getImageWritersByFormatName(imageFormat).next();
        this.writeParams = new ImageWriteParam(writer);
    }

    public void setWriteCompressionMode(int writeCompressionMode) {
        this.writeParams.setCompressionMode(writeCompressionMode);
    }

    public void setWriteCompressionQuality(float writeCompressionQuality) {
        this.writeParams.setCompressionQuality(writeCompressionQuality);
    }

    public void setWriteCompressionType(String writeCompressionType) {
        this.writeParams.setCompressionType(writeCompressionType);
    }

    public void write(BufferedImage image, String filePath) throws IOException {
        this.writer.setOutput(new FileImageOutputStream(new File(filePath)));
        this.writer.prepareWriteSequence(null);
        this.writer.writeToSequence(image, this.writeParams);
        this.writer.endWriteSequence();
    }

    public ImageWriteParam getImageWriteParameters() {
        return this.writeParams;
    }
}"
65,"// Java code for the task
public class RangeSet<C extends Comparable<? super C>> {
    // Define a set of ranges that encloses all ranges in this set
    private Set<Range<C>> enclosedRanges;

    public boolean intersects(Collection<? extends Range<C>> other) {
        if (other.isEmpty()) {
            return true;
        }

        // Check if each range in other is enclosed by a range in this set
        for (Range<C> range : other) {
            if (!encloses(range)) {
                return false;
            }
        }

        return true;
    }

    public boolean isEmpty() {
        // Return true if the enclosedRanges set is empty
        return enclosedRanges.isEmpty();
    }

    public void clear() {
        // Clear the enclosedRanges set
        enclosedRanges.clear();
    }

    public RangeSet<C> subRangeSet(Collection<? extends Range<C>> ranges) {
        // Create a new range set with the specified ranges
        RangeSet<C> newSet = new RangeSet<>();
        for (Range<C> range : ranges) {
            newSet.add(range);
        }
        return newSet;
    }

    public void remove(Range<C> range) {
        // Remove the specified range from the enclosedRanges set
        enclosedRanges.remove(range);
    }

    public boolean contains(Range<C> range) {
        // Check if the specified range is in the enclosedRanges set
        return enclosedRanges.contains(range);
    }

    public Range<C> rangeContaining(C value) {
        // Find the range containing the specified value in the enclosedRanges set
        for (Range<C> range : enclosedRanges) {
            if (range.contains(value)) {
                return range;
            }
        }
        return null;
    }

    public void removeAll(Collection<? extends Range<C>> ranges) {
        // Remove the specified ranges from the enclosedRanges set
        for (Range<C> range : ranges) {
            remove(range);
        }
    }

    public int hashCode() {
        // Calculate the hash code of the enclosedRanges set
        return enclosedRanges.hashCode();
    }

    public boolean equals(Object other) {
        // Check if the specified object is equal to this range set
        if (other == null || !(other instanceof RangeSet)) {
            return false;
        }
        RangeSet<C> otherSet = (RangeSet<C>) other;
        return enclosedRanges.equals(otherSet.enclosedRanges);
    }

    public String toString() {
        // Return a string representation of the range set
        return enclosedRanges.toString();
    }

    public RangeSet<C> complement() {
        // Create a new range set with the complement of the ranges in this set
        RangeSet<C> newSet = new RangeSet<>();
        for (Range<C> range : enclosedRanges) {
            newSet.add(range.complement());
        }
        return newSet;
    }

    public boolean encloses(Range<C> range) {
        // Check if the specified range is fully contained within any range in this set
        for (Range<C> thisRange : enclosedRanges) {
            if (thisRange.encloses(range)) {
                return true;
            }
        }
        return false;
    }

    public Set<Range<C>> asDescendingSetOfRanges() {
        // Return the enclosed ranges in descending order
        Set<Range<C>> descendingRanges = new TreeSet<>(new Comparator<Range<C>>() {
            @Override
            public int compare(Range<C> o1, Range<C> o2) {
                return -o1.compareTo(o2);
            }
        });
        descendingRanges.addAll(enclosedRanges);
        return descendingRanges;
    }

    public Range<C> span() {
        // Return the range that spans all the ranges in this set
        if (isEmpty()) {
            return null;
        }
        Iterator<Range<C>> iterator = enclosedRanges.iterator();
        Range<C> firstRange = iterator.next();
        Range<C> lastRange = firstRange;
        while (iterator.hasNext()) {
            lastRange = iterator.next();
        }
        return new SpanRange(firstRange, lastRange);
    }
}"
66,"import java.util.Map;
import java.util.concurrent.ThreadLocal;

class Context {
    private Map<String, Method> functions;
    private ThreadLocal<ELEvaluator> current;
    private Context context;
    private ExpressionEvaluator evaluator;
    private Map<String, Object> vars;

    public void addFunction(Method function) {
        functions.put(function.getName(), function);
    }

    public Object resolveFunction(String name) {
        return functions.get(name).invoke();
    }

    public void setVariable(String name, Object value) {
        vars.put(name, value);
    }

    public void getVariable(String name) {
        return vars.get(name);
    }

    public Context getContext() {
        return context;
    }

    public T evaluate(Expression expression) {
        ELEvaluator evaluator = current.get();
        Object result = evaluator.evaluate(expression);
        return (T) result;
    }
}"
67,"package com.example;
import java.nio.*;
public class Buffer {
    private ByteBuffer buffer;
    private ByteBufferAllocator allocator;
    private int OUTPUT_MODE = 0;
    private int INPUT_MODE = 1;

    public Buffer(ByteBuffer buffer, ByteBufferAllocator allocator) {
        this.buffer = buffer;
        this.allocator = allocator;
    }

    public void expandCapacity() {
        // ...
    }

    public void setOutputMode() {
        // ...
    }

    public void setInputMode() {
        // ...
    }

    public int length() {
        return buffer.limit();
    }

    public int available() {
        return buffer.remaining();
    }

    public void clear() {
        buffer.clear();
    }

    @Override
    public String toString() {
        return buffer.toString();
    }

    public int getMode() {
        if (buffer.hasRemaining()) {
            return OUTPUT_MODE;
        } else {
            return INPUT_MODE;
        }
    }

    public void ensureCapacity(int capacity) {
        // ...
    }

    public int capacity() {
        return buffer.capacity();
    }
}"
68,"import java.io.*;

public class LogRecord {
    private int op; // the setstring operator
    private long transactionId; // the id of the transaction that modified the block
    private String filename; // the name of the file containing the block
    private int blockNumber; // the number of the block being modified
    private int offset; // the offset in the block where the modification occurred
    private String oldValue; // the previous string value at the specified offset
    private String newValue; // the new string value to be written to the block

    public LogRecord(int op, long transactionId, String filename, int blockNumber, int offset, String oldValue, String newValue) {
        this.op = op;
        this.transactionId = transactionId;
        this.filename = filename;
        this.blockNumber = blockNumber;
        this.offset = offset;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }

    public int getOp() {
        return op;
    }

    public long getTransactionId() {
        return transactionId;
    }

    public String getFilename() {
        return filename;
    }

    public int getBlockNumber() {
        return blockNumber;
    }

    public int getOffset() {
        return offset;
    }

    public String getOldValue() {
        return oldValue;
    }

    public String getNewValue() {
        return newValue;
    }

    @Override
    public String toString() {
        return ""LogRecord{"" +
                ""op="" + op +
                "", transactionId="" + transactionId +
                "", filename='"" + filename + '\'' +
                "", blockNumber="" + blockNumber +
                "", offset="" + offset +
                "", oldValue='"" + oldValue + '\'' +
                "", newValue='"" + newValue + '\'' +
                '}';
    }
}"
69,"public class DataFlowHandler {
    private final Logger LOGGER = Logger.getLogger(DataFlowHandler.class);
    private final Stack<StackObject> continueBreakReturnStack;
    private final List<DataFlowNode> dataFlow;
    private final Stack<StackObject> braceStack;

    public DataFlowHandler() {
        this.continueBreakReturnStack = new Stack<>();
        this.dataFlow = new ArrayList<>();
        this.braceStack = new Stack<>();
    }

    public List<StackObject> getContinueBreakReturnStack() {
        return continueBreakReturnStack;
    }

    public DataFlowNode createStartNode(String label) {
        DataFlowNode startNode = new DataFlowNode(label);
        this.dataFlow.add(startNode);
        return startNode;
    }

    public DataFlowNode createEndNode(String label) {
        DataFlowNode endNode = new DataFlowNode(label);
        this.dataFlow.add(endNode);
        return endNode;
    }

    public DataFlowNode getFirst() {
        if (this.dataFlow.isEmpty()) {
            return null;
        } else {
            return this.dataFlow.get(0);
        }
    }

    public List<StackObject> getBraceStack() {
        return braceStack;
    }

    public String dump() {
        StringBuilder sb = new StringBuilder();
        for (DataFlowNode node : this.dataFlow) {
            sb.append(node.toString());
        }
        return sb.toString();
    }

    public DataFlowNode getLast() {
        if (this.dataFlow.isEmpty()) {
            return null;
        } else {
            return this.dataFlow.get(this.dataFlow.size() - 1);
        }
    }

    public void pushOnStack(StackObject stackObject) {
        this.continueBreakReturnStack.push(stackObject);
    }
}"
7,"package com.example;

import java.io.IOException;
import java.util.Random;

public class TestBufferedBlockInStream {
    private BufferedBlockInStream mTestStream;
    private long mBlockSize;
    private long mBufferSize;

    public void before() throws IOException {
        // initialize test stream with block size and buffer size
        mTestStream = new BufferedBlockInStream(mBlockSize, mBufferSize);
    }

    public void bufferRead() throws IOException {
        // read data from the stream using the buffer
        byte[] buffer = new byte[mBufferSize];
        int bytesRead = mTestStream.read(buffer);
        assertEquals(""Number of bytes read not correct"", bytesRead, mBlockSize);
    }

    public void skip() throws IOException {
        // seek to the end of the stream and then back to the beginning
        long skippedBytes = mTestStream.skip(mBlockSize);
        assertEquals(""Number of bytes skipped not correct"", skippedBytes, mBlockSize);
        skippedBytes = mTestStream.skip(-mBlockSize);
        assertEquals(""Number of bytes skipped not correct"", skippedBytes, 0);
    }

    public void bulkRead() throws IOException {
        // read multiple blocks from the stream using the buffer
        long numBlocks = (mBufferSize / mBlockSize) + 1;
        byte[][] buffers = new byte[numBlocks][];
        for (int i = 0; i < numBlocks; i++) {
            buffers[i] = new byte[mBufferSize];
        }
        long bytesRead = mTestStream.read(buffers);
        assertEquals(""Number of bytes read not correct"", bytesRead, numBlocks * mBlockSize);
    }

    public void singleByteRead() throws IOException {
        // read a single byte from the stream using the buffer
        int bytesRead = mTestStream.read(new byte[1]);
        assertEquals(""Number of bytes read not correct"", bytesRead, 1);
    }
}"
70,"// Get the current user from the ThreadLocal variable
User getCurrentUser() {
    return sUserThreadLocal.get();
}

// Set the current user in the ThreadLocal variable
void setCurrentUser(User user) {
    sUserThreadLocal.set(user);
}

// Remove the current user from the ThreadLocal variable
void removeCurrentUser() {
    sUserThreadLocal.remove();
}"
71,"package com.example;

import java.util.ArrayList;
import java.util.List;

public class RequiredAttributes {
    private String attributeConsumingServiceIndex;
    private List<String> selectedClaims = new ArrayList<>();
    private String enableClaims;
    private String issuer;
    private String certificateAlias;
    private boolean isIdPInitSSOEnabled;
    private String assertionConsumerUrl;
    private String singleLogoutUrl;
    private List<String> selectedRecipients = new ArrayList<>();
    private String enableSignatureValidation;
    private List<String> selectedAudiences = new ArrayList<>();

    public void setAttributeConsumingServiceIndex(String attributeConsumingServiceIndex) {
        this.attributeConsumingServiceIndex = attributeConsumingServiceIndex;
    }

    public String getAttributeConsumingServiceIndex() {
        return attributeConsumingServiceIndex;
    }

    public List<String> getSelectedClaims() {
        return selectedClaims;
    }

    public void setEnableClaims(String enableClaims) {
        this.enableClaims = enableClaims;
    }

    public String getEnableClaims() {
        return enableClaims;
    }

    public String getIssuer() {
        return issuer;
    }

    public void setIssuer(String issuer) {
        this.issuer = issuer;
    }

    public String getCertificateAlias() {
        return certificateAlias;
    }

    public void setCertificateAlias(String certificateAlias) {
        this.certificateAlias = certificateAlias;
    }

    public boolean isIdPInitSSOEnabled() {
        return isIdPInitSSOEnabled;
    }

    public void setIdPInitSSOEnabled(boolean idPInitSSOEnabled) {
        isIdPInitSSOEnabled = idPInitSSOEnabled;
    }

    public String getAssertionConsumerUrl() {
        return assertionConsumerUrl;
    }

    public void setAssertionConsumerUrl(String assertionConsumerUrl) {
        this.assertionConsumerUrl = assertionConsumerUrl;
    }

    public String getSingleLogoutUrl() {
        return singleLogoutUrl;
    }

    public void setSingleLogoutUrl(String singleLogoutUrl) {
        this.singleLogoutUrl = singleLogoutUrl;
    }

    public List<String> getSelectedRecipients() {
        return selectedRecipients;
    }

    public void setEnableSignatureValidation(String enableSignatureValidation) {
        this.enableSignatureValidation = enableSignatureValidation;
    }

    public String getEnableSignatureValidation() {
        return enableSignatureValidation;
    }

    public List<String> getSelectedAudiences() {
        return selectedAudiences;
    }

    public void setEnableAudiences(String enableAudiences) {
        this.enableAudiences = enableAudiences;
    }

    public String getEnableAudiences() {
        return enableAudiences;
    }

    public String getEnableSingleLogout() {
        return enableSingleLogout;
    }

    public void setEnableSingleLogout(String enableSingleLogout) {
        this.enableSingleLogout = enableSingleLogout;
    }

    private List<String> selectedRecipients = new ArrayList<>();
    private String enableSignatureValidation;
    private List<String> selectedAudiences = new ArrayList<>();
    private String enableAudiences;
    private String enableSingleLogout;

    public void addClaimToList(String claim) {
        this.selectedClaims.add(claim);
    }

    public void removeClaimFromList(String claim) {
        this.selectedClaims.remove(claim);
    }

    public boolean addAudienceToList(String audience) {
        return this.selectedAudiences.add(audience);
    }

    public void removeAudienceFromList(String audience) {
        this.selectedAudiences.remove(audience);
    }

    public String[] getSelectedClaimsArray() {
        return this.selectedClaims.toArray(new String[0]);
    }

    public void setEnableAssertionSigning(String enableAssertionSigning) {
        this.enableAssertionSigning = enableAssertionSigning;
    }

    public String getEnableAssertionSigning() {
        return enableAssertionSigning;
    }

    private String enableAssertionSigning;

    public void setEnableRecipients(String enableRecipients) {
        this.enableRecipients = enableRecipients;
    }

    public String getEnableRecipients() {
        return enableRecipients;
    }

    private String enableRecipients;

    public void addRecipientToList(String recipient) {
        this.selectedRecipients.add(recipient);
    }

    public void removeRecipientFromList(String recipient) {
        this.selectedRecipients.remove(recipient);
    }

    public String[] getSelectedRecipientsArray() {
        return this.selectedRecipients.toArray(new String[0]);
    }

    public void clearBean() {
        this.attributeConsumingServiceIndex = null;
        this.selectedClaims.clear();
        this.enableClaims = null;
        this.issuer = null;
        this.certificateAlias = null;
        this.isIdPInitSSOEnabled = false;
        this.assertionConsumerUrl = null;
        this.singleLogoutUrl = null;
        this.selectedRecipients.clear();
        this.enableSignatureValidation = null;
        this.selectedAudiences.clear();
        this.enableAudiences = null;
        this.enableSingleLogout = null;
    }

    public void setSelectedAttributes(String[] selectedClaims) {
        for (String claim : selectedClaims) {
            addClaimToList(claim);
        }
    }

    public String getSingleLogoutUrl() {
        return singleLogoutUrl;
    }

    public boolean isIdPInitSSOEnabled() {
        return isIdPInitSSOEnabled;
    }

    public void setEnableAssertionSigning(String enableAssertionSigning) {
        this.enableAssertionSigning = enableAssertionSigning;
    }

    public String getEnableAssertionSigning() {
        return enableAssertionSigning;
    }

    public void setCertificateAlias(String certificateAlias) {
        this.certificateAlias = certificateAlias;
    }

    public String getCertificateAlias() {
        return certificateAlias;
    }

    public void setIssuer(String issuer) {
        this.issuer = issuer;
    }

    public String getIssuer() {
        return issuer;
    }

    public void setAssertionConsumerUrl(String assertionConsumerUrl) {
        this.assertionConsumerUrl = assertionConsumerUrl;
    }

    public String getAssertionConsumerUrl() {
        return assertionConsumerUrl;
    }

    public void setSingleLogoutUrl(String singleLogoutUrl) {
        this.singleLogoutUrl = singleLogoutUrl;
    }

    public void setEnableRecipients(String enableRecipients) {
        this.enableRecipients = enableRecipients;
    }

    public String getEnableRecipients() {
        return enableRecipients;
    }
}"
72,"import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;

@ExtendWith(TemporaryFolderExtension.class)
public class FileUtilsDeleteNonExistentFileTest {

    private static final String FILE_NAME = ""non-existent-file.txt"";
    private Path filePath;

    @BeforeEach
    void setup(@TempDir Path tempDir) throws IOException {
        filePath = Files.createTempFile(tempDir, FILE_NAME, null);
    }

    @Test
    void testDeleteNonExistentFile() {
        // Set up an exception handler to capture any exceptions thrown by the delete method
        try {
            FileUtils.delete(filePath.resolve(FILE_NAME));
        } catch (IOException e) {
            fail(""Unexpected IOException: "" + e);
        }
    }
}"
73,"// Java code to check if a class declares an operation by the name given and covered by the signature mask
public static boolean doesDeclareOperation(String className, String operationName, Map<FieldSignature, Set<String>> fields, Map<String, ClassStats> nestedClasses, Map<ClassMetricKey, Double> memo, Map<OperationSignature, Map<String, OperationStats>> operations) {
    // Check if the class has a field with the given name
    if (fields.containsKey(new FieldSignature(className, operationName))) {
        return true;
    }

    // Check if the class has a nested class with the given name
    if (nestedClasses.containsKey(className)) {
        ClassStats nestedClassStats = nestedClasses.get(className);
        Map<String, OperationStats> operationStatsMap = nestedClassStats.getOperations();
        if (operationStatsMap.containsKey(operationName)) {
            return true;
        }
    }

    // Check if the class has a static initializer with the given name
    if (memo.containsKey(new ClassMetricKey(className, operationName))) {
        return true;
    }

    // If none of the above conditions are met, return false
    return false;
}"
74,"// Java code to update all specified user objects
public class UserUpdater {
    private IStoredSettings settings;
    private Map<String, String> legacyBackingServices;
    private IRuntimeManager runtimeManager;
    private Logger logger;
    private IUserService userService;
    private boolean deleteRepositoryRole;

    public UserUpdater(IStoredSettings settings, Map<String, String> legacyBackingServices, IRuntimeManager runtimeManager, Logger logger, IUserService userService) {
        this.settings = settings;
        this.legacyBackingServices = legacyBackingServices;
        this.runtimeManager = runtimeManager;
        this.logger = logger;
        this.userService = userService;
    }

    public void updateUsers() {
        List<String> usernames = getAllUsernames();
        for (String username : usernames) {
            UserModel userModel = getUserModel(username);
            if (userModel != null) {
                boolean updated = updateUserModel(userModel);
                if (!updated) {
                    logger.warn(""Failed to update user "" + username + ""."");
                }
            } else {
                logger.info(""No user found with name "" + username + "", skipping."");
            }
        }
    }

    private List<String> getAllUsernames() {
        return userService.getAllUsernames();
    }

    private UserModel getUserModel(String username) {
        return userService.getUserModel(username);
    }

    private boolean updateUserModel(UserModel userModel) {
        // Implement logic to update the user model here
        return true;
    }
}"
75,nan
76,"// Filter class that logs messages with the filter name prepended
public class LoggingFilter extends GenericServlet {
    private static final Logger LOGGER = LoggerFactory.getLogger(LoggingFilter.class);

    @Override
    public void init(FilterConfig config) throws ServletException {
        // Initialize the filter with the filter configuration
        String path = config.getInitParameter(""path"");
        if (path != null) {
            try {
                URL url = findResource(config, path);
                LOGGER.info(""Initialized filter with resource: {}"", url);
            } catch (MalformedURLException e) {
                throw new ServletException(""Failed to initialize filter with resource: "" + path, e);
            }
        } else {
            LOGGER.warn(""No path parameter was specified for the filter"");
        }
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        // Log the incoming request with the filter name prepended
        LOGGER.info(""{} - {}"", config.getFilterName(), request.getRequestURI());

        // Pass the request and response to the next filter in the chain
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        // Destroy the filter with the filter configuration
        String path = config.getInitParameter(""path"");
        if (path != null) {
            try {
                URL url = findResource(config, path);
                LOGGER.info(""Destroyed filter with resource: {}"", url);
            } catch (MalformedURLException e) {
                throw new ServletException(""Failed to destroy filter with resource: "" + path, e);
            }
        } else {
            LOGGER.warn(""No path parameter was specified for the filter"");
        }
    }

    private URL findResource(FilterConfig config, String path) throws MalformedURLException {
        // Find the resource with the given path in the filter configuration
        return config.getServletContext().getResource(path);
    }
}"
77,"import org.slf4j.Logger;

public class OneWayRPCService {
  private static final Logger LOG = LoggerFactory.getLogger(OneWayRPCService.class);
  
  public void handleOnewayRPC(placeholderType placeHolder) {
    LOG.info(""Received one-way RPC call"");
    // Write an empty response to the client
    // ...
  }
}"
78,Here is some sample Java code that implements the functionality described in your task:
79,"public class FileMapper {
    private final String m_escapedJson;
    private final Logger m_log;
    private final int STOP_DOWNLOAD_DELETE_FILES = 30;
    private final JLibTorrent m_libTorrent;

    public FileMapper(String escapedJson, Logger log) {
        this.m_escapedJson = escapedJson;
        this.m_log = log;
        this.m_libTorrent = new JLibTorrent();
    }

    public void addDownload() {
        String normalizedId = normalizeId(m_escapedJson);
        boolean addedComplete = addComplete(normalizedId);
        if (addedComplete) {
            m_log.info(""Downloaded and completed file: "" + normalizedId);
        } else {
            m_log.warning(""Failed to download and complete file: "" + normalizedId);
        }
    }

    private String normalizeId(String escapedJson) {
        // TODO: implement normalization logic
        return escapedJson;
    }

    private boolean addComplete(String normalizedId) {
        // TODO: implement completion logic
        return false;
    }
}"
8,"import java.lang.ref.ReferenceQueue;
import java.util.concurrent.CountDownLatch;

public class AwaitGC {
    private static final ReferenceQueue<Object> QUEUE = new ReferenceQueue<>();
    private static final CountDownLatch LATCH = new CountDownLatch(1);

    public void await() throws InterruptedException {
        Object o = new Object() {
            @Override
            protected void finalize() {
                try {
                    QUEUE.enqueue(this);
                    LATCH.countDown();
                } catch (Throwable t) {
                    // Ignore
                }
            }
        };
        Runtime.getRuntime().gc();
        if (!LATCH.await(10, TimeUnit.SECONDS)) {
            throw new RuntimeException(""Timeout waiting for GC to complete"");
        }
    }

    public void awaitDone() throws InterruptedException {
        while (true) {
            Reference<? extends Object> ref = QUEUE.remove(10, TimeUnit.SECONDS);
            if (ref != null) {
                LATCH.countDown();
            } else {
                break;
            }
        }
    }

    public void awaitClear() throws InterruptedException {
        while (true) {
            Reference<? extends Object> ref = QUEUE.remove(10, TimeUnit.SECONDS);
            if (ref != null) {
                LATCH.countDown();
            } else {
                break;
            }
        }
    }
}"
80,"import org.w3c.dom.traversal.Node;
import org.w3c.dom.traversal.DocumentTraversal;

public class NodeTester {
    private DocumentTraversal documentTraversal;
    private short[] nodeTypes;

    public NodeTester(DocumentTraversal documentTraversal, short[] nodeTypes) {
        this.documentTraversal = documentTraversal;
        this.nodeTypes = nodeTypes;
    }

    public boolean pass(Node rootNode) {
        // Check if the specified nodetester instance accepts the given root node
        return documentTraversal.acceptNodeType(rootNode);
    }
}"
81,"// Java code for the given task

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.TException;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransportException;
import org.apache.thrift.protocol.TBinaryProtocol.Factory;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.protocol.TMultiplexedProtocol;
import io.netty.channel.Channel;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.ChannelFutureListener;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.channel.SimpleChannelInboundHandler;
import org.apache.thrift.protocol.TProtocolFactory;
import org.apache.thrift.transport.TTransportException;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TMultiplexedProtocol;
import io.netty.channel.Channel;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.ChannelFutureListener;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.channel.SimpleChannelInboundHandler;
import org.apache.thrift.protocol.TProtocolFactory;
import org.apache.thrift.transport.TTransportException;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TMultiplexedProtocol;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import java.util.Map;
import java.net.InetSocketAddress;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.protocol.TBinaryProtocol;
import io.netty.channel.Channel;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.ChannelFutureListener;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.channel.SimpleChannelInboundHandler;
import org.apache.thrift.protocol.TProtocolFactory;
import org.apache.thrift.transport.TTransportException;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TMultiplexedProtocol;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import java.util.Map;
import java.net.InetSocketAddress;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.protocol.TBinaryProtocol;
import io.netty.channel.Channel;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.ChannelFutureListener;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.channel.SimpleChannelInboundHandler;
import org.apache.thrift.protocol.TProtocolFactory;
import org.apache.thrift.transport.TTransportException;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TMultiplexedProtocol;

public class BlockMasterClientPool {
    private final ConcurrentHashMap<InetSocketAddress, BlockWorkerThriftClientPool> BLOCK_WORKER_THRIFT_CLIENT_HEARTBEAT_POOL = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<InetSocketAddress, BlockWorkerThriftClientPool> BLOCK_WORKER_THRIFT_CLIENT_POOL = new ConcurrentHashMap<>();
    private final Map<InetSocketAddress, NettyChannelPool> NETTY_CHANNEL_POOL_MAP = new ConcurrentHashMap<>();
    private final Map<InetSocketAddress, BlockStoreContext> CACHED_CONTEXTS = new ConcurrentHashMap<>();

    public void acquireWorkerClient(InetSocketAddress masterAddress) {
        // Get a context with the specified master address from the cache if it's created before. Otherwise, create a new one and put it in the cache.
        BlockStoreContext context = CACHED_CONTEXTS.get(masterAddress);
        if (context == null) {
            // Create a new context
            context = new BlockStoreContext(new TSocket(masterAddress));
            // Put it in the cache
            CACHED_CONTEXTS.put(masterAddress, context);
        }
        return context;
    }

    public void releaseBlockWorkerThriftClient(InetSocketAddress masterAddress) {
        BlockStoreContext context = CACHED_CONTEXTS.remove(masterAddress);
        if (context != null) {
            // Release the Thrift client and channel pool associated with the context
            context.release();
        }
    }

    public void initializeGauges() {
        // Initialize gauges for all cached contexts
        for (BlockStoreContext context : CACHED_CONTEXTS.values()) {
            context.initializeGauges();
        }
    }

    public boolean hasLocalWorker(InetSocketAddress masterAddress) {
        return NETTY_CHANNEL_POOL_MAP.containsKey(masterAddress);
    }

    public void releaseBlockWorkerThriftClientHeartbeat(InetSocketAddress masterAddress) {
        if (NETTY_CHANNEL_POOL_MAP.containsKey(masterAddress)) {
            NETTY_CHANNEL_POOL_MAP.remove(masterAddress);
        }
    }

    public void releaseWorkerClient(InetSocketAddress masterAddress) {
        // Release the Thrift client and channel pool associated with the context
        BlockStoreContext context = CACHED_CONTEXTS.remove(masterAddress);
        if (context != null) {
            context.release();
        }
    }
}

class BlockWorkerThriftClientPool {
    private final Map<InetSocketAddress, BlockMasterClientPool> mBlockMasterClientPool;
    private final Boolean mHasLocalWorker;

    public BlockWorkerThriftClientPool(Map<InetSocketAddress, BlockMasterClientPool> blockMasterClientPool, boolean hasLocalWorker) {
        this.mBlockMasterClientPool = blockMasterClientPool;
        this.mHasLocalWorker = hasLocalWorker;
    }
}

class NettyChannelPool {
    private final Channel channel;

    public NettyChannelPool(Channel channel) {
        this.channel = channel;
    }
}

class BlockStoreContext {
    private final TSocket socket;
    private final TBinaryProtocol binaryProtocol;
    private final TMultiplexedProtocol thriftProtocol;
    private final BlockWorkerClientService.Client client;
    private final NettyChannelPool nettyChannelPool;

    public BlockStoreContext(TSocket socket) {
        this.socket = socket;
        this.binaryProtocol = new TBinaryProtocol(new TFramedTransport(socket), false, true);
        this.thriftProtocol = new TMultiplexedProtocol(this.binaryProtocol, ""BlockWorkerClientService"");
        this.client = new BlockWorkerClientService.Client(this.thriftProtocol);
        this.nettyChannelPool = null;
    }

    public void release() {
        if (this.socket != null) {
            this.socket.close();
        }
    }

    public void initializeGauges() {
        // Initialize gauges for the Thrift client and channel pool associated with the context
        // ...
    }
}"
82,"import javax.imageio.IIOException;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.plugins.jpeg.JPEGImageWriteParam;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class ImageWriter {
    private String imageFormat = DEFAULT_IMAGE_FORMAT;
    private float writeCompressionQuality = 1.0f;
    private String writeCompressionType = ""JPEG"";
    private int writeCompressionMode = JPEGImageWriteParam.MODE_DISABLED;

    public static final String DEFAULT_IMAGE_FORMAT = ""jpg"";

    public ImageWriter(String imageFormat) {
        this.imageFormat = imageFormat;
    }

    public void setWriteCompressionMode(int writeCompressionMode) {
        this.writeCompressionMode = writeCompressionMode;
    }

    public void setWriteCompressionType(String writeCompressionType) {
        this.writeCompressionType = writeCompressionType;
    }

    public void setWriteCompressionQuality(float writeCompressionQuality) {
        this.writeCompressionQuality = writeCompressionQuality;
    }

    public void write(BufferedImage image, File outputFile) throws IIOException, IOException {
        ImageWriter writer = ImageIO.getImageWritersByFormatName(this.imageFormat).next();
        if (writer == null) {
            throw new IIOException(""No image writer found for format: "" + this.imageFormat);
        }

        JPEGImageWriteParam jpegParams = new JPEGImageWriteParam(null);
        jpegParams.setCompressionMode(this.writeCompressionMode);
        jpegParams.setCompressionType(this.writeCompressionType);
        jpegParams.setCompressionQuality(this.writeCompressionQuality);

        ImageWriteParam params = writer.getDefaultWriteParam();
        if (params instanceof JPEGImageWriteParam) {
            ((JPEGImageWriteParam) params).setCompressionMode(jpegParams.getCompressionMode());
            ((JPEGImageWriteParam) params).setCompressionType(jpegParams.getCompressionType());
            ((JPEGImageWriteParam) params).setCompressionQuality(jpegParams.getCompressionQuality());
        }

        writer.write(null, new IIOImage(image, null, null), params);
    }
}"
83,"// Generate Java code for the task
import java.util.*;
import java.net.*;

public class OmaRedirect {
    // Define a constant for the OMA redirect link
    public static final String OMA_REDIRECT_LINK = ""https://omaredirect.do"";

    // Define a method to create a query string from a map of parameters
    private static String createQueryString(Map<String,String> params) {
        if (params == null || params.isEmpty()) {
            return """";
        }

        StringBuilder builder = new StringBuilder();
        for (Map.Entry<String,String> entry : params.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            if (value != null) {
                builder.append(key).append(""="").append(URLEncoder.encode(value, ""UTF-8"")).append(""&"");
            }
        }
        return builder.toString().substring(0, builder.length() - 1);
    }

    // Define a method to create an OMA link from a portal link
    public static String createOmaLink(String portalLink) {
        if (portalLink == null || portalLink.isEmpty()) {
            return """";
        }

        // Parse the incoming link and extract the parameters
        URL url = new URL(portalLink);
        Map<String,String> params = getParameterMap(url);

        // Conditionally prepend ""http://"" to the OMA redirect link if it is missing
        String omaRedirectLink = conditionallyPrependHttp(OMA_REDIRECT_LINK);

        // Create a query string from the parameters
        String queryString = createQueryString(params);

        // Construct the final OMA link by appending the query string to the redirect link
        return omaRedirectLink + ""?"" + queryString;
    }

    // Define a method to get a map of parameters from an incoming link
    private static Map<String,String> getParameterMap(URL url) {
        if (url == null || !url.getQuery().isEmpty()) {
            return new HashMap<>();
        }

        // Parse the query string and create a map of parameters
        Map<String,String> params = new HashMap<>();
        for (String param : getKeyList(url)) {
            String value = url.getParameter(param);
            if (value != null) {
                params.put(param, value);
            }
        }
        return params;
    }

    // Define a method to get the list of keys from an incoming link
    private static ArrayList<String> getKeyList(URL url) {
        if (url == null || !url.getQuery().isEmpty()) {
            return new ArrayList<>();
        }

        // Parse the query string and create a list of keys
        String[] keys = url.getQuery().split(""&"");
        ArrayList<String> keyList = new ArrayList<>();
        for (String key : keys) {
            int index = key.indexOf(""="");
            if (index != -1) {
                keyList.add(key.substring(0, index));
            } else {
                keyList.add(key);
            }
        }
        return keyList;
    }

    // Define a method to conditionally prepend ""http://"" to a URL if it is missing
    private static String conditionallyPrependHttp(String url) {
        if (url == null || url.isEmpty()) {
            return """";
        }

        if (!url.startsWith(""http://"") && !url.startsWith(""https://"")) {
            url = ""http://"" + url;
        }
        return url;
    }
}"
84,"import java.util.concurrent.ConcurrentHashMap;
import org.eclipse.jetty.server.Handler;
import org.eclipse.jetty.server.JettyHTTPServerEngine;
import org.eclipse.jetty.server.threading.ThreadingParameters;
import org.eclipse.jetty.util.component.Container;
import org.eclipse.jetty.util.component.LifeCycleManager;
import org.eclipse.jetty.util.component.MBeanServer;
import org.eclipse.jetty.util.thread.ThreadPool;

public class JettyHTTPServerEngine {
    private final ConcurrentHashMap<Integer, ThreadingParameters> portMap = new ConcurrentHashMap<>();
    private final BusLifeCycleManager lifeCycleManager;
    private final Map<String, TLSServerParameters> tlsParametersMap = new HashMap<>();
    private final Bus bus;

    public JettyHTTPServerEngine(Bus bus) {
        this.bus = bus;
        this.lifeCycleManager = new LifeCycleManager();
    }

    public void setTlsServerParametersMap(Map<String, TLSServerParameters> tlsParametersMap) {
        this.tlsParametersMap.putAll(tlsParametersMap);
    }

    public Map<String, TLSServerParameters> getTlsServerParametersMap() {
        return tlsParametersMap;
    }

    public void setBus(Bus bus) {
        this.bus = bus;
    }

    public Bus getBus() {
        return bus;
    }

    public void initComplete() {
        // TODO: implement initComplete method
    }

    public void destroyForPort(int port) {
        // TODO: implement destroyForPort method
    }

    public Map<String, ThreadingParameters> getThreadingParametersMap() {
        return portMap;
    }

    public boolean isJetty8() {
        // TODO: implement isJetty8 method
    }

    public void postShutdown() {
        // TODO: implement postShutdown method
    }

    public void preShutdown() {
        // TODO: implement preShutdown method
    }

    public void setTLSServerParametersForPort(int port, TLSServerParameters tlsServerParameters) {
        // TODO: implement setTLSServerParametersForPort method
    }
}"
85,"public class GeneratorManager {
    private static final Logger LOG = Logger.getLogger(GeneratorManager.class);
    private static final GeneratorManager INSTANCE = new GeneratorManager();
    
    private Language currLanguage;
    private Map<Language, CodeGenerator> generators;
    
    public String getCodePath() {
        return null;
    }
    
    public CodeGenerator getGenerator(Language language) {
        if (language == null) {
            throw new IllegalArgumentException(""Language cannot be null"");
        }
        
        synchronized (generators) {
            if (!generators.containsKey(language)) {
                generators.put(language, createGenerator(language));
            }
            
            return generators.get(language);
        }
    }
    
    public CodeGenerator removeGenerator(Language language) {
        synchronized (generators) {
            if (!generators.containsKey(language)) {
                return null;
            }
            
            CodeGenerator generator = generators.remove(language);
            LOG.info(""Removed generator for "" + language);
            
            return generator;
        }
    }
    
    public Set<Language> getLanguages() {
        synchronized (generators) {
            return new HashSet<>(generators.keySet());
        }
    }
    
    private CodeGenerator createGenerator(Language language) {
        if (language == null) {
            throw new IllegalArgumentException(""Language cannot be null"");
        }
        
        return null; // TODO: Implement this method
    }
    
    public static GeneratorManager getInstance() {
        return INSTANCE;
    }
    
    public Language findLanguage(String languageName) {
        if (languageName == null || languageName.isEmpty()) {
            throw new IllegalArgumentException(""Language name cannot be null or empty"");
        }
        
        synchronized (generators) {
            for (Map.Entry<Language, CodeGenerator> entry : generators.entrySet()) {
                if (languageName.equalsIgnoreCase(entry.getKey().getName())) {
                    return entry.getKey();
                }
            }
            
            return null;
        }
    }
    
    public CodeGenerator getCurrGenerator() {
        synchronized (generators) {
            if (!generators.containsKey(currLanguage)) {
                generators.put(currLanguage, createGenerator(currLanguage));
            }
            
            return generators.get(currLanguage);
        }
    }
    
    public Map<Language, CodeGenerator> getGenerators() {
        synchronized (generators) {
            return new HashMap<>(generators);
        }
    }
}"
86,"// Java code for convenience method that sets a variable in the el evaluator context
import java.util.Map;
import java.util.concurrent.ThreadLocal;
import javax.el.ELEvaluator;
import javax.el.ExpressionEvaluator;
import javax.el.MethodNotFoundException;
import javax.el.ValueExpression;

public class ELEvaluationContext {
    private static ThreadLocal<ELEvaluator> current = new ThreadLocal<>();
    private Map<String, Method> functions;
    private Context context;
    private ExpressionEvaluator evaluator;
    private Map<String, Object> vars;

    public void setVariables(Map<String, Object> variables) {
        for (String key : variables.keySet()) {
            try {
                ValueExpression ve = evaluator.createValueExpression(context, ""${"" + key + ""}"", Object.class);
                ve.setValue(context, variables.get(key));
            } catch (MethodNotFoundException e) {
                throw new RuntimeException(""Could not find method for variable "" + key, e);
            }
        }
    }

    public void addFunction(String name, Method function) {
        functions.put(name, function);
    }

    public Object resolveVariable(String variableName) throws MethodNotFoundException {
        return getCurrent().getValueExpression(""${"" + variableName + ""}"").getValue(getContext());
    }

    public ELEvaluator getCurrent() {
        return current.get();
    }

    public Object getVariable(String variableName) throws MethodNotFoundException {
        return resolveVariable(variableName);
    }

    public Context getContext() {
        return context;
    }

    public T evaluate(String expression) throws Exception {
        ELEvaluator evaluator = getCurrent();
        ValueExpression ve = evaluator.createValueExpression(context, ""${ "" + expression + ""}"", Object.class);
        return (T) ve.getValue(context);
    }
}"
87,"import java.math.BigInteger;

public class TransactionOutput {
    private long index;
    private BigInteger value;
    private byte[] scriptBytes;
    private Sha256Hash hash;
    private int height;

    public TransactionOutput(long index, BigInteger value, byte[] scriptBytes, Sha256Hash hash, int height) {
        this.index = index;
        this.value = value;
        this.scriptBytes = scriptBytes;
        this.hash = hash;
        this.height = height;
    }

    public long getIndex() {
        return index;
    }

    public BigInteger getValue() {
        return value;
    }

    public byte[] getScriptBytes() {
        return scriptBytes;
    }

    public Sha256Hash getHash() {
        return hash;
    }

    public int getHeight() {
        return height;
    }

    @Override
    public int hashCode() {
        return Objects.hash(index, value, scriptBytes, hash, height);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof TransactionOutput)) {
            return false;
        }
        TransactionOutput that = (TransactionOutput) o;
        return Objects.equals(index, that.index) &&
                Objects.equals(value, that.value) &&
                Arrays.equals(scriptBytes, that.scriptBytes) &&
                Objects.equals(hash, that.hash) &&
                height == that.height;
    }

    @Override
    public String toString() {
        return ""TransactionOutput{"" +
                ""index="" + index +
                "", value="" + value +
                "", scriptBytes="" + Arrays.toString(scriptBytes) +
                "", hash="" + hash +
                "", height="" + height +
                '}';
    }

    public void serializeToStream(OutputStream outputStream) throws IOException {
        // Implement this method to write the transaction output to a stream
    }
}"
88,"public class MonsterShooter {
  private float xStartPos;
  private FloatBuffer lModelAmbient;
  private float zPos;
  private float yPos;
  private float MOVE_FORWARD_SPEED;
  private float yStartPos;
  private float walkbiasangle;
  private float walkbias;
  private int BULLET_INTERVAL;
  private long bulletTime;
  private int MAX_BULLETS;
  private float ROTATE_SPEED;
  private Monster[] monsters;
  private float xPos;
  private float MOVE_BACKWARD_SPEED;
  private int MAX_MONSTERS;
  private FloatBuffer lightPosition;
  private FloatBuffer whiteLight;
  private boolean[] monstersLiving;
  private float heading;
  private float STRAFE_SPEED;
  private float zStartPos;
  private ArrayList<Bullet> bullets;

  public void turnRight() {
    // Implement the logic to turn right here
  }

  public void restart() {
    // Implement the logic to restart here
  }

  public void start() {
    // Implement the logic to start here
  }

  public void update() {
    // Implement the logic to update here
  }

  public boolean isFinished() {
    // Implement the logic to check if the game is finished here
  }

  public void walkForwards() {
    // Implement the logic to move forward here
  }

  public void renderFloor() {
    // Implement the logic to render the floor here
  }

  public void walkBackwards() {
    // Implement the logic to move backwards here
  }

  public void strafeLeft() {
    // Implement the logic to strafe left here
  }

  public Level LoadFromFile(String filename) {
    // Implement the logic to load a level from a file here
  }

  public void strafeRight() {
    // Implement the logic to strafe right here
  }

  public void renderWalls() {
    // Implement the logic to render the walls here
  }

  public void turnLeft() {
    // Implement the logic to turn left here
  }

  public Level ReadFromXML(String filename) {
    // Implement the logic to read a level from an XML file here
  }

  public void render() {
    // Implement the logic to render the game here
  }
}"
89,"import java.util.*;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class GetOfferDetailsResponse {
    private static final String API_KEY = ""YOUR_API_KEY"";

    public static void main(String[] args) {
        // Set up the request
        String url = ""https://api.bestbuy.com/v1/products/sku/5432768.json?apiKey="" + API_KEY;

        // Send the request and get the response
        Gson gson = new Gson();
        JsonObject jsonResponse = gson.fromJson(new JsonParser().parse(new URL(url).openStream()), JsonObject.class);

        // Parse the JSON response
        GetOfferDetailsResponse response = gson.fromJson(jsonResponse, GetOfferDetailsResponse.class);

        // Print the result
        System.out.println(""Offer details:"");
        System.out.println(""  Name: "" + response.getName());
        System.out.println(""  Price: "" + response.getPrice());
        System.out.println(""  Currency: "" + response.getCurrency());
        System.out.println(""  Fulfillment partner: "" + response.getFulfillmentPartner());
        System.out.println(""  Offer media:"");
        for (OfferMedia offerMedia : response.getOfferMedia()) {
            System.out.println(""    Type: "" + offerMedia.getType());
            System.out.println(""    URL: "" + offerMedia.getUrl());
        }
        System.out.println(""  Products:"");
        for (Product product : response.getProducts()) {
            System.out.println(""    Name: "" + product.getName());
            System.out.println(""    Price: "" + product.getPrice());
            System.out.println(""    Currency: "" + product.getCurrency());
        }
        System.out.println(""  Redemption addresses:"");
        for (RedemptionAddress redemptionAddress : response.getRedemptionAddresses()) {
            System.out.println(""    Address: "" + redemptionAddress.getAddress());
            System.out.println(""    City: "" + redemptionAddress.getCity());
        }
        System.out.println(""  Source geos:"");
        for (Geo sourceGeo : response.getSourceGeos()) {
            System.out.println(""    Country: "" + sourceGeo.getCountry());
            System.out.println(""    Region: "" + sourceGeo.getRegion());
            System.out.println(""    City: "" + sourceGeo.getCity());
        }
        System.out.println(""  Target geos:"");
        for (Geo targetGeo : response.getTargetGeos()) {
            System.out.println(""    Country: "" + targetGeo.getCountry());
            System.out.println(""    Region: "" + targetGeo.getRegion());
            System.out.println(""    City: "" + targetGeo.getCity());
        }
    }
}

class OfferDetailsResponse {
    private String name;
    private Double price;
    private String currency;
    private FulfillmentPartner fulfillmentPartner;
    private List<OfferMedia> offerMedia;
    private List<Product> products;
    private List<RedemptionAddress> redemptionAddresses;
    private List<Geo> sourceGeos;
    private List<Geo> targetGeos;

    // Getters and setters for all fields
}

class OfferMedia {
    private String type;
    private String url;

    // Getters and setters for all fields
}

class Product {
    private String name;
    private Double price;
    private String currency;

    // Getters and setters for all fields
}

class RedemptionAddress {
    private String address;
    private String city;

    // Getters and setters for all fields
}

class Geo {
    private String country;
    private String region;
    private String city;

    // Getters and setters for all fields
}

enum FulfillmentPartner {
    AMZ,
    MER,
    FBA
}"
9,"import com.amazonaws.services.s3.transfer.TransferManager;
import com.amazonaws.services.s3.AmazonS3;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class AWSConfig {
    private Properties props = new Properties();
    private String BUCKET_NAME = ""my-bucket"";
    private AmazonS3 s3;
    private TransferManager mManager;
    private S3ADirectOutputStream mStream;

    public void setProperties() throws IOException {
        FileInputStream fis = new FileInputStream(""aws.properties"");
        props.load(fis);
        fis.close();
    }

    public String getBucketName() {
        return BUCKET_NAME;
    }

    public void setAmazonS3(AmazonS3 s3) {
        this.s3 = s3;
    }

    public AmazonS3 getAmazonS3() {
        return s3;
    }

    public TransferManager getTransferManager() {
        if (mManager == null) {
            mManager = new TransferManager(getAmazonS3());
        }
        return mManager;
    }

    public S3ADirectOutputStream getStream(String key) throws IOException {
        if (mStream == null) {
            mStream = new S3ADirectOutputStream(s3, BUCKET_NAME, key);
        }
        return mStream;
    }

    public void close() throws IOException {
        if (mManager != null) {
            mManager.shutdownNow();
            mManager = null;
        }
        if (mStream != null) {
            mStream.close();
            mStream = null;
        }
    }
}"
90,"package com.example;

import java.util.Objects;

public class RMConfiguration {
    private Long inactivityTimeout;
    private Long acknowledgementInterval;
    private String rmNamespace;
    private boolean sequenceTransportSecurityRequired;
    private String rm10AddressingNamespace;
    private boolean inOrder;
    private boolean exponentialBackoff;
    private Long baseRetransmissionInterval;
    private DeliveryAssurance deliveryAssurance;

    public void setInactivityTimeout(Long inactivityTimeout) {
        this.inactivityTimeout = inactivityTimeout;
    }

    public void setRMNamespace(String rmNamespace) {
        this.rmNamespace = rmNamespace;
    }

    public Long getInactivityTimeout() {
        return inactivityTimeout;
    }

    public void setAcknowledgementInterval(Long acknowledgementInterval) {
        this.acknowledgementInterval = acknowledgementInterval;
    }

    public Long getAcknowledgementInterval() {
        return acknowledgementInterval;
    }

    public void setSequenceSTRRequired(boolean sequenceSTRRequired) {
        this.sequenceTransportSecurityRequired = sequenceSTRRequired;
    }

    public boolean isSequenceTransportSecurityRequired() {
        return sequenceTransportSecurityRequired;
    }

    public String getAddressingNamespace() {
        return rm10AddressingNamespace;
    }

    public void setRM10AddressingNamespace(String rm10AddressingNamespace) {
        this.rm10AddressingNamespace = rm10AddressingNamespace;
    }

    public boolean isInOrder() {
        return inOrder;
    }

    public void setInOrder(boolean inOrder) {
        this.inOrder = inOrder;
    }

    public void setExponentialBackoff(boolean exponentialBackoff) {
        this.exponentialBackoff = exponentialBackoff;
    }

    public boolean isExponentialBackoff() {
        return exponentialBackoff;
    }

    public Long getBaseRetransmissionInterval() {
        return baseRetransmissionInterval;
    }

    public void setBaseRetransmissionInterval(Long baseRetransmissionInterval) {
        this.baseRetransmissionInterval = baseRetransmissionInterval;
    }

    public DeliveryAssurance getDeliveryAssurance() {
        return deliveryAssurance;
    }

    public void setDeliveryAssurance(DeliveryAssurance deliveryAssurance) {
        this.deliveryAssurance = deliveryAssurance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RMConfiguration that = (RMConfiguration) o;
        return Objects.equals(inactivityTimeout, that.inactivityTimeout) &&
                Objects.equals(acknowledgementInterval, that.acknowledgementInterval) &&
                Objects.equals(rmNamespace, that.rmNamespace) &&
                sequenceTransportSecurityRequired == that.sequenceTransportSecurityRequired &&
                Objects.equals(rm10AddressingNamespace, that.rm10AddressingNamespace) &&
                inOrder == that.inOrder &&
                exponentialBackoff == that.exponentialBackoff &&
                Objects.equals(baseRetransmissionInterval, that.baseRetransmissionInterval) &&
                deliveryAssurance == that.deliveryAssurance;
    }

    @Override
    public int hashCode() {
        return Objects.hash(inactivityTimeout, acknowledgementInterval, rmNamespace, sequenceTransportSecurityRequired,
                rm10AddressingNamespace, inOrder, exponentialBackoff, baseRetransmissionInterval, deliveryAssurance);
    }
}"
91,"import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class PaymentChannelServer {
    private static final int DEFAULT_TIMEOUT = 30 * 60; // 30 minutes in seconds

    private NioServer server;
    private Wallet wallet;
    private TransactionBroadcaster broadcaster;
    private ProtobufParser<Protos.TwoWayChannelMessage> socketProtobufHandler;
    private PaymentChannelCloseException.CloseReason closeReason = PaymentChannelCloseException.CloseReason.CLOSED_BY_CLIENT;
    private Coin minAcceptedChannelSize;
    private ExecutorService executor;

    public PaymentChannelServer(InetSocketAddress address, Wallet wallet, TransactionBroadcaster broadcaster) {
        this.server = new NioServer(address);
        this.wallet = wallet;
        this.broadcaster = broadcaster;
    }

    public void bindAndStart() throws IOException {
        server.bind();
        server.start();
        executor = Executors.newSingleThreadExecutor();
    }

    public void onNewConnection(ServerConnectionEventHandler eventHandler) {
        // TODO: handle new connection
    }

    public void close() throws IOException {
        server.close();
        if (executor != null) {
            executor.shutdownNow();
        }
    }

    private class ServerConnectionEventHandler implements NioServer.OnNewConnectionListener {
        @Override
        public void onNewConnection(NioServer server, InetSocketAddress clientAddress) {
            // TODO: handle new connection
        }
    }
}"
92,"// Java code for the Debugger class
public class Debugger {
    private String verbose;
    private Map<String, Integer> reportTopics;
    private Stack<String> should_report;
    private String frontend;
    private String imports;
    private ErrorQueue eq;
    private String loader;
    private String time;
    private String debug;
    private String cfg;
    private String context;
    private String visit;
    private String resolver;
    private Collection<String> topics;
    private boolean noReporting;
    private String errors;

    // constructor
    public Debugger(String verbose, Map<String, Integer> reportTopics, Stack<String> should_report, String frontend, String imports, ErrorQueue eq, String loader, String time, String debug, String cfg, String context, String visit, String resolver, Collection<String> topics, boolean noReporting, String errors) {
        this.verbose = verbose;
        this.reportTopics = reportTopics;
        this.should_report = should_report;
        this.frontend = frontend;
        this.imports = imports;
        this.eq = eq;
        this.loader = loader;
        this.time = time;
        this.debug = debug;
        this.cfg = cfg;
        this.context = context;
        this.visit = visit;
        this.resolver = resolver;
        this.topics = topics;
        this.noReporting = noReporting;
        this.errors = errors;
    }

    // method to report a message of the specified level
    public void report(int level, String message) {
        if (should_report(level)) {
            eq.enqueue(new ErrorInfo(message));
        }
    }

    // method to check whether a message should be reported
    private boolean should_report(int level) {
        return reportTopics.containsKey(level);
    }

    // method to set the queue for storing errors
    public void setQueue(ErrorQueue eq) {
        this.eq = eq;
    }

    // method to set the current topic
    public void pushTopic(String topic) {
        should_report.push(topic);
    }

    // method to remove the current topic from the stack
    public void popTopic() {
        should_report.pop();
    }

    // method to add a new topic to the stack
    public void addTopic(String topic) {
        should_report.add(topic);
    }

    // method to get the current error queue
    public ErrorQueue getQueue() {
        return eq;
    }
}"
93,"import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Marshaller;
import javax.xml.namespace.QName;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.List;

public class JAXBExample {
    public static void main(String[] args) throws Exception {
        // Create a new instance of the SignCertificateRequest class
        SignCertificateRequest request = new SignCertificateRequest();

        // Set the required fields for the request
        request.setAuth(new Auth());
        request.getAuth().setUsername(""username"");
        request.getAuth().setPassword(""password"");

        // Create a new instance of the CertificateInfo class
        CertificateInfo certificateInfo = new CertificateInfo();
        certificateInfo.setCertificateType(""X509"");
        certificateInfo.setCertificate(""-----BEGIN CERTIFICATE-----\n"" +
                ""MIIC/DCCA+GgAwIBAgIJAO9KN67pQrWMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n"" +
                ""BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX\n"" +
                ""aWRnaXRzIFB0eSBMdGQwHhcNMTkwMTE4MTIxOTE2WhcNMjAwMTE3MTIxOTE2WjBF\n"" +
                ""MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEDAOBgNVBAsTB1Jvb3QgQ29tcGFy\n"" +
                ""ZTERMA8GA1UEChMIZWxwIEdsb2JhbCBDqTELMAkGA1UEAxMCU0UtMIIBIjANBgkq\n"" +
                ""hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt3lYC9FvR4VsXu56/W1zJIuDd6+7f6Nh\n"" +
                ""/PpBTbV1HG+3Uxwv82JMiFqOA1j/Z0QNb9EKlCJYy5kRl/gX1zr49G57f7U9eGs\n"" +
                ""pZt3L+DH6VGxWO2hJuW6B9YvqY2i0jxdRKTGgNQoF6801b4IcRQMu6k7a5AyMXZ\n"" +
                ""0CvpO7/UH6mw3sW201zL7fVlY9i706rW3+V74tG71gTbKQQRu1QSjxEtAZFU5Dh\n"" +
                ""qCcYIJ2j/kPV8K6eOaXM9BfyD713r0mwl4oqpqvXWUdGKbC53Q+iQTJhzJUAxR5\n"" +
                ""t72/Zg6H238PpFJ07sY2NV4uMJyE8rI18cVZo6W6QIDAQABoxowDDAKBggrBgEF\n"" +
                ""CQBCDAYikTAJBgNVHRMExtDBTBgNVHSUEdDAKBggrBgEFBQcDCjBSb290Q0ExFzAV\n"" +
                ""BgNVBAsTDmRlY2t1cm9uIFNTTCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCA\n"" +
                ""QoCggEBAL75kp+Lz/cXr04FHMbjgB35P7dVf1lO67R9S5a2tqvhH5I08mwJyY9E\n"" +
                ""oUUQRH3Kk9i1Lw2rF4N6cM/pJC91b1G+xYV0JlXZA/D7zSdWtB5638vFbhf905Y\n"" +
                ""j+JQa8829y5gwP+m84TUkR3iMqc1oEwL4HJAZu4VtOIvKpqWr/7eKb6GYCXZ+1xh\n"" +
                ""2jFQX50/PfB7d9X86RiV1/3yMkKQX2K9mKcJA4o6DHl4Ip5a33qNt48CQwWKGnE\n"" +
                ""TaO0XsYvZxPj8zUUr6B3d1Fy4h9/2g1u3Mx7AHJ+pLm28DVJ27fk1I3G55oVbW\n"" +
                ""7SqYaQOvE5tWQ8iB7VrXcNZQ0dZ8lT94g96/2yAYwKD+sUxb9CY7Pu4H68F1Lk\n"" +
                ""38f88j43+EWpzIvJQ51qZ8o2e0dRVgm9K87Xa8y0JA6KiM4wDyx+UlN+s3XBgC\n"" +
                ""SqkfQoqPcHYWO5I1tYzZZ6jXR+T9/bF2EwGX7085K9V8p08Kd45lqLNhRBqn3M\n"" +
                ""xD3PkQsJUf1JuLcI7vzrS+O4jCi4gH6Gt1GwbLl0y8+/Vz6A2W8/F0oBT5E94q\n"" +
                ""R0ZMKX7Q33xD92vkIWYeSjJ8NmC+8i80tPXcW+bLUlcZrGJ/AyF6zO+W4h+d+B1\n"" +
                ""T7X2Vg39xwHuK/5aqkQIvEy0Rs8jMpPfDxmLh8q5YtG3JYXNz+VUiJdE3AZO2\n"" +
                ""1bY6C40o9Tg2u7c/W4kFg+K7vWG3wS9Q/sDmFj5BhQ0rKHX8lLNy6i7fMN9AZ3\n"" +
                ""zV5eJbxC/pP1JQoYt4Ud0R+jXWOwuGs+1c4qh7kq4VKF8lKmE/S7HrM4+iZ9a\n"" +
                ""eN6xZvLbR5gp2P+z8Y8J35jQ0tI8CXQT1WG+U2sZkQwqF/R87AJHc5Mk4iW83d\n"" +
                ""KaJyQVvp6BhPjg9LxZr3X6X+EOGbTfYNQo9KDm2lqU21/0VL51RF57Y8t3+5kC\n"" +
                ""3K6wWpMhjS/e9Xg/1PJzLrXv4ZbHxIiNfTkEjQmB3lQcOo0qG3sVb2KRQMtA7\n"" +
                ""DnZ0678YJyhgC3Y+SzUmX/L4dqXpQ1WJ9rqJF5PB5aUZ4/xHQE5kHs4lq2G6Vw\n"" +
                ""MKfRJuB9hOA+3N0tgT2i8vZcL646XI18F3mW+8jUXaC/yvP93dYDqYkVbGHs5l\n"" +
                ""KJXZBzJ6p9AwOzY0KuGQ7T2x4MhN1fIr03gJ81W6+E31e/tZL02c4U5q31/RZC\n"" +
                ""Xyfj/4PsJDkV5ZbzvA0Hj40KNw7TGlRg8mSx+9r+K9Q2h6M/tGyI6YUQBX0nC\n"" +
                ""p/aR74O9VLQ/JZ5WuYbRD83zP0lw8dFmXSqHvAf/oEkTJgV05628+M0rZYyU9\n"" +
                ""xjK41sNiLvIQCW/QK1p0eG5R5D367cXS6lwbO712FmT+PV8hb50JgB0HQkqZ6\n"" +
                ""AYaVzZMf8v5tWv8L4CZdR5/xDfIxE9N167GQe3O2sK+ZXlY+5iB/wFcJrTbSj\n"" +
                ""6hXqUHkQgRu6WyC4ZV86a8t12d5D9EA9p8G7JZ37m0oPzJNl+2Q6x67e+YOwc\n"" +
                ""MUi/F1KH41+77vjvfCxqbIa8h+Vy97R5K8GpRrZ0PWX+gTx4zl637mJN/X+sG+\n"" +
                ""3oMtjhcHQ==\n"" +
                ""-----END CERTIFICATE-----\n"");
        request.setCertificateInfo(certificateInfo);

        // Marshal the request object to a JAXBElement<SignCertificateRequest>
        JAXBContext jaxbContext = JAXBContext.newInstance(SignCertificateRequest.class);
        Marshaller marshaller = jaxbContext.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        StringWriter stringWriter = new StringWriter();
        JAXBElement<SignCertificateRequest> jaxbElement = new JAXBElement<>(_SignCertificateRequest_QNAME, SignCertificateRequest.class, request);
        marshaller.marshal(jaxbElement, stringWriter);

        // Print the XML representation of the request object
        System.out.println(""JAXBElement<SignCertificateRequest>:"");
        System.out.println(stringWriter.toString());
    }
}"
94,"public class TestResult {
    private Long expectedDataUnitId;
    private Long seqNo;
    private Long dataSetId;
    private Long dataUnitId;
    private String expectedValue;
    private String actualValue;
    private Long expectedDataSetId;
    private String errorCode;
    private Long testId;
    private String failedAttributeName;
    private String srcFileName;
    private String errorMsg;

    public void setExpectedDataUnitId(Long expectedDataUnitId) {
        this.expectedDataUnitId = expectedDataUnitId;
    }

    public Long getExpectedDataUnitId() {
        return this.expectedDataUnitId;
    }

    public void setSeqNo(Long seqNo) {
        this.seqNo = seqNo;
    }

    public Long getSeqNo() {
        return this.seqNo;
    }

    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }

    public Long getDataSetId() {
        return this.dataSetId;
    }

    public void setDataUnitId(Long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }

    public Long getDataUnitId() {
        return this.dataUnitId;
    }

    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }

    public String getExpectedValue() {
        return this.expectedValue;
    }

    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }

    public String getActualValue() {
        return this.actualValue;
    }

    public void setExpectedDataSetId(Long expectedDataSetId) {
        this.expectedDataSetId = expectedDataSetId;
    }

    public Long getExpectedDataSetId() {
        return this.expectedDataSetId;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return this.errorCode;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public Long getTestId() {
        return this.testId;
    }

    public void setFailedAttributeName(String failedAttributeName) {
        this.failedAttributeName = failedAttributeName;
    }

    public String getFailedAttributeName() {
        return this.failedAttributeName;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public String getSrcFileName() {
        return this.srcFileName;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public String getErrorMsg() {
        return this.errorMsg;
    }

    @Override
    public String toString() {
        return ""TestResult{"" +
                ""expectedDataUnitId="" + expectedDataUnitId +
                "", seqNo="" + seqNo +
                "", dataSetId="" + dataSetId +
                "", dataUnitId="" + dataUnitId +
                "", expectedValue='"" + expectedValue + '\'' +
                "", actualValue='"" + actualValue + '\'' +
                "", expectedDataSetId="" + expectedDataSetId +
                "", errorCode='"" + errorCode + '\'' +
                "", testId="" + testId +
                "", failedAttributeName='"" + failedAttributeName + '\'' +
                "", srcFileName='"" + srcFileName + '\'' +
                "", errorMsg='"" + errorMsg + '\'' +
                '}';
    }
}"
95,"public List<Group> getGroupsForUser(String username) {
    // Connect to the database and retrieve the list of groups for the specified user
    List<Group> groups = new ArrayList<>();
    try (Connection connection = DriverManager.getConnection(DB_URL, USERNAME, PASSWORD)) {
        String query = ""SELECT * FROM groups WHERE username = ?"";
        PreparedStatement statement = connection.prepareStatement(query);
        statement.setString(1, username);
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            Group group = new Group();
            group.setId(resultSet.getInt(""id""));
            group.setName(resultSet.getString(""name""));
            groups.add(group);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return groups;
}"
96,"import java.io.*;
import java.net.*;
import org.slf4j.Logger;

public class FlushOutstandingData {
  private static final Logger LOGGER = LoggerFactory.getLogger(FlushOutstandingData.class);

  public void flushOutstandingData(UDPEndPoint clientEndpoint, ClientSession clientSession) throws IOException {
    // flush outstanding data and make sure it is acknowledged
    try (Socket socket = getSocket(clientSession)) {
      try (OutputStream outputStream = socket.getOutputStream()) {
        UDPEndPoint endpoint = getEndpoint(outputStream);
        void sendBlocking() throws IOException {
          int read = readFromInputStream(inputStream);
          if (read > 0) {
            LOGGER.info(""Read {} bytes from input stream"", read);
            socket.send(endpoint, outputStream);
            statistics.incrementBytesWritten(read);
          } else {
            LOGGER.info(""No data available to flush"");
          }
        }
      }
    } catch (IOException e) {
      LOGGER.error(""Error flushing outstanding data"", e);
      throw new IOException(""Error flushing outstanding data"", e);
    }
  }

  private Socket getSocket(ClientSession clientSession) throws IOException {
    return clientSession.getSocket();
  }

  private OutputStream getOutputStream(Socket socket) throws IOException {
    return socket.getOutputStream();
  }

  private UDPEndPoint getEndpoint(OutputStream outputStream) throws IOException {
    return outputStream.getEndpoint();
  }

  private int readFromInputStream(InputStream inputStream) throws IOException {
    byte[] buffer = new byte[1024];
    int bytesRead = inputStream.read(buffer);
    if (bytesRead > 0) {
      return bytesRead;
    } else {
      return -1;
    }
  }

  private UDTStatistics getStatistics() throws IOException {
    return socket.getStatistics();
  }
}"
97,"public class RemoteControlAPIs {
    private static final boolean HAS_REMOTE_CONTROL_APIS = false;

    // Object to store textual information to be displayed.
    private MetadataEditorCompat mActualMetadataEditor;

    // Constructor for the RemoteControlAPIs class.
    public RemoteControlAPIs() {
        this.mActualMetadataEditor = new MetadataEditorCompat();
    }

    // Method to add textual information to be displayed.
    public void setPlaybackState(int state) {
        if (HAS_REMOTE_CONTROL_APIS) {
            this.mActualMetadataEditor.putLong(METADATA_KEY_ARTWORK, state);
        }
    }

    // Method to apply the textual information to be displayed.
    public void apply() {
        if (HAS_REMOTE_CONTROL_APIS) {
            this.mActualRemoteControlClient.editMetadata(this.mActualMetadataEditor);
        }
    }

    // Method to remove the textual information from being displayed.
    public void removeFromMediaRouter() {
        if (HAS_REMOTE_CONTROL_APIS) {
            this.mActualRemoteControlClient.clear();
        }
    }

    // Method to clear all textual information from being displayed.
    public void clear() {
        if (HAS_REMOTE_CONTROL_APIS) {
            this.mActualMetadataEditor.clear();
        }
    }

    // Method to add textual information to be displayed to a MediaRouter object.
    public void addToMediaRouter(MediaRouter router) {
        if (HAS_REMOTE_CONTROL_APIS) {
            this.mActualRemoteControlClient = new RemoteControlClientCompat();
            this.mActualRemoteControlClient.attachToMediaRouter(router);
        }
    }

    // Method to get the actual remote control client object.
    public Object getActualRemoteControlClientObject() {
        if (HAS_REMOTE_CONTROL_APIS) {
            return this.mActualRemoteControlClient;
        } else {
            return null;
        }
    }

    // Method to set the transport control flags for the remote control client.
    public void setTransportControlFlags(int flags) {
        if (HAS_REMOTE_CONTROL_APIS) {
            this.mActualRemoteControlClient.setTransportControlFlags(flags);
        }
    }
}"
98,"package com.example;

import android.os.Handler;

public class GeneralMotorCon {
    private static final String TAG = ""GeneralMotorCon"";

    private int spin90Time;
    private int batLvl;
    private long threadTimer;
    private int spinSpeed;
    private CommandManager cmd;
    private int hoverTime;
    private int speed;
    private int spin90Speed;
    private ARDrone drone;
    private int spinTime;

    public GeneralMotorCon() {
        this.spin90Time = 500; // 500 milliseconds (default value)
        this.batLvl = 100; // default battery level
        this.threadTimer = 0; // no timer by default
        this.speed = 200; // default speed
        this.spin90Speed = 90; // default spin speed
        this.hoverTime = 500; // default hover time
    }

    public void setBatLvl(int batLvl) {
        this.batLvl = batLvl;
    }

    public int getBatLvl() {
        return this.batLvl;
    }

    public void onStop() {
        // stop the drone and reset the battery level
        this.drone.stop();
        this.batLvl = 100;
    }

    public void raiseAltitude() {
        this.drone.raiseAltitude(this.speed);
    }

    public void lowerAltitude() {
        this.drone.lowerAltitude(this.speed);
    }

    public void takeoff() {
        // start the drone and set its altitude to 0
        this.drone.start();
        this.drone.setAltitude(0);
    }

    public void forward() {
        this.drone.forward(this.speed);
    }

    public void backward() {
        this.drone.backward(this.speed);
    }

    public void left() {
        this.drone.left(this.speed);
    }

    public void right() {
        this.drone.right(this.speed);
    }

    public void spinLeft() {
        // start the drone and set its altitude to 0
        this.drone.start();
        this.drone.setAltitude(0);

        // spin the drone left at a speed of spinSpeed
        Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                GeneralMotorCon.this.drone.spinLeft(GeneralMotorCon.this.spin90Speed);
            }
        }, GeneralMotorCon.this.spin90Time);
    }

    public void spinRight() {
        // start the drone and set its altitude to 0
        this.drone.start();
        this.drone.setAltitude(0);

        // spin the drone right at a speed of spinSpeed
        Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                GeneralMotorCon.this.drone.spinRight(GeneralMotorCon.this.spin90Speed);
            }
        }, GeneralMotorCon.this.spin90Time);
    }

    public void spin90Left() {
        // start the drone and set its altitude to 0
        this.drone.start();
        this.drone.setAltitude(0);

        // spin the drone left at a speed of 90
        Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                GeneralMotorCon.this.drone.spinLeft(90);
            }
        }, GeneralMotorCon.this.spinTime);
    }

    public void spin90Right() {
        // start the drone and set its altitude to 0
        this.drone.start();
        this.drone.setAltitude(0);

        // spin the drone right at a speed of 90
        Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                GeneralMotorCon.this.drone.spinRight(90);
            }
        }, GeneralMotorCon.this.spinTime);
    }

    public static GeneralMotorCon getInstance() {
        return new GeneralMotorCon();
    }
}"
99,"import com.google.common.collect.ImmutableMap;

public class GroupConfiguration {
    private final ImmutableMap<String, String> metadata;
    private final int maxEntities;
    private final int minEntities;
    private final String name;
    private final int cooldown;

    public static Builder toBuilder(GroupConfiguration configuration) {
        return new Builder(configuration);
    }

    public ImmutableMap<String, String> getMetadata() {
        return metadata;
    }

    public int getMaxEntities() {
        return maxEntities;
    }

    public int getMinEntities() {
        return minEntities;
    }

    public String getName() {
        return name;
    }

    public int getCooldown() {
        return cooldown;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GroupConfiguration that = (GroupConfiguration) o;
        return Objects.equals(metadata, that.metadata) &&
                maxEntities == that.maxEntities &&
                minEntities == that.minEntities &&
                name.equals(that.name) &&
                cooldown == that.cooldown;
    }

    @Override
    public int hashCode() {
        return Objects.hash(metadata, maxEntities, minEntities, name, cooldown);
    }

    @Override
    public String toString() {
        return ""GroupConfiguration{"" +
                ""metadata="" + metadata +
                "", maxEntities="" + maxEntities +
                "", minEntities="" + minEntities +
                "", name='"" + name + '\'' +
                "", cooldown="" + cooldown +
                '}';
    }

    public static class Builder {
        private ImmutableMap<String, String> metadata;
        private int maxEntities;
        private int minEntities;
        private String name;
        private int cooldown;

        public Builder(GroupConfiguration configuration) {
            this.metadata = configuration.metadata;
            this.maxEntities = configuration.maxEntities;
            this.minEntities = configuration.minEntities;
            this.name = configuration.name;
            this.cooldown = configuration.cooldown;
        }

        public Builder metadata(Map<String, String> metadata) {
            this.metadata = ImmutableMap.copyOf(metadata);
            return this;
        }

        public Builder maxEntities(int maxEntities) {
            this.maxEntities = maxEntities;
            return this;
        }

        public Builder minEntities(int minEntities) {
            this.minEntities = minEntities;
            return this;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder cooldown(int cooldown) {
            this.cooldown = cooldown;
            return this;
        }

        public GroupConfiguration build() {
            return new GroupConfiguration(this);
        }
    }
}"
