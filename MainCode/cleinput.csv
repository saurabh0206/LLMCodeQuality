Example,Generated Java Code
1,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

class NestingLevel {
    int depth;
    int lastToken;
    int scope;

    public NestingLevel(int d, int l, int s) {
        depth = d;
        lastToken = l;
        scope = s;
    }
}

public class Refactor {
    private boolean isInScopeChain = false;
    private int lastTokenCount = 0;
    private ArrayList<NestingLevel> nestingLevels;

    public void collectFuncNodes(ObjArray funcObjects, ArrayList<Integer> functionBracePositions,
            int functionNum, ArrayList<HashMap<String, String>> functionVarMappings, int sourceCompress) {
        ArrayList<Integer> funcNodes = new ArrayList<>();
        nestingLevels = new ArrayList<>();

        int scopeCnt = 0;
        int nodeCnt = 0;
        int currentScope = 0;
        int minCompress = 0;
        int maxCompress = 0;

        for (int i = 0, len = funcObjects.size(); i < len; i++) {
            Object obj = funcObjects.get(i);
            if (obj instanceof Map) {
                Map<String, Object> item = (Map<String, Object>) obj;

                if (item.containsKey(""type"") && item.get(""type"").toString().equals(""FunctionDeclaration"")) {
                    funcNodes.add(i);
                    String id = (String) item.get(""id"");
                    ArrayList<Map<String, String>> arr = new ArrayList<>();
                    functionVarMappings.add(arr);

                    String[] scopes = (String[]) item.getOrDefault(""scopes"", new String[0]);
                    for (int k = 0, klen = scopes.length; k < klen; k++) {
                        arr.add(new HashMap<>());
                    }
                }
                if (item.containsKey(""start"")) {
                    nodeCnt++;
                    System.out.println(item.get(""start""));
                }
            }
            if (obj instanceof ArrayList) {
                ArrayList<Object> arr = (ArrayList<Object>) obj;

                for (int j = 0, jlen = arr.size(); j < jlen; j++) {
                    Object subObj = arr.get(j);

                    if (subObj instanceof ObjArray) {
                        ObjArray subArr = (ObjArray) subObj;
                        if (!subArr.isArray()) {
                            continue;
                        }
                        if (subArr.size() > 0) {
                            Map<String, String> item = subArr.getArrayItem(sourceCompress);

                            if (item != null) {
                                if (item.containsKey(""type"") && item.get(""type"").toString().equals(""Identifier"")) {
                                    if (!isInScopeChain) {
                                        String id = item.get(""name"");
                                        int scopelvl = Integer.parseInt(item.get(""scope""));

                                        if (scopelvl == currentScope) {
                                            HashMap<String, String> mapping = functionVarMappings.get(functionNum);
                                            mapping.get(functionBracePositions.get(functionNum)).put(id, id);
                                        } else {
                                            if (scopelvl > currentScope) {
                                                scopeCnt++;
                                                isInScopeChain = true;
                                            } else {
                                                leaveNestingLevel();
                                            }
                                            reset();
                                            HashMap<String, String> mapping = functionVarMappings.get(functionNum);
                                            mapping.get(functionBracePositions.get(functionNum)).put(id, id);
                                            enterNestingLevel(scopelvl);
                                        }
                                    } else {
                                        System.out.println(item);
                                        isInScopeChain = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        minCompress = sourceCompress;
        for (NestingLevel level : nestingLevels) {
            if (level.scope > minCompress) {
                minCompress = level.scope;
            }
        }
        System.out.println(functionVarMappings + "", "" + minCompress);
    }

    public void enterNestingLevel(int scope) {
        nestingLevels.add(new NestingLevel(nestingLevels.size(), lastTokenCount, scope));
    }

    public void leaveNestingLevel() {
        NestingLevel lastLevel = nestingLevels.get(nestingLevels.size() - 1);
        System.out.println(lastLevel.scope);
        int offset = lastLevel.scope + 1;
        HashMap<String, String> mapping = functionVarMappings.get(lastLevel.scope);
        Map.Entry<String, String> id = mapping.entrySet().iterator().next();

        System.out.println(id.getValue() + "", "");
    }

    public void reset() {
        lastTokenCount = 0;
    }

    public String getMappedToken(int start, int end) {
        String token = "";

        return token;
    }

    public String getPreviousTokenMapping(int funcPos, int position) {
        String token = "";

        return token;
    }
}"
2,"import com.google.common.primitives.Bytes;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.math.BigInteger;

public class FileSha256 {
  private final Sha256Hash hash;

  protected FileSha256(Sha256Hash hash) {
    this.hash = hash;
  }

  public static FileSha256 create(File file) throws IOException {
    final HashFunction sha256 = Hashing.sha256();
    final Hasher hasher = sha256.newHasher();
    FileInputStream stream = new FileInputStream(file);
    try {
      byte[] buffer = new byte[16384];
      int bytesRead;
      while ((bytesRead = stream.read(buffer)) != -1) {
        hasher.putBytes(buffer, 0, bytesRead);
      }
    } finally {
      stream.close();
    }
    return new FileSha256(Sha256Hash.fromBytes(hasher.hash().asBytes()));
  }

  public static final FileSha256 ZERO_HASH = new FileSha256(Sha256Hash.fromBytes(new byte[32]));

  @Override
  public int hashCode() {
    return hash.hashCode();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof FileSha256)) {
      return false;
    }
    return hash.equals(((FileSha256) obj).hash);
  }

  @Override
  public String toString() {
    return hash.toString();
  }

  public int compareTo(FileSha256 hash) {
    return Bytes.compare(this.hash.getBytes(), hash.hash.getBytes());
  }

  public byte[] getBytes() {
    return hash.getBytes();
  }

  public BigInteger toBigInteger() {
    return hash.toBigInteger();
  }

  public Sha256Hash duplicate() {
    return hash.duplicate();
  }
}"
3,"import java.util.UUID;

public class MYCLASS {
    private static final Logger LOG = Logger.getLogger(MYCLASS.class.getName());

    private String id;

    public MYCLASS(boolean canCreate) {
        if (canCreate) {
            this.id = UUID.randomUUID().toString();
        }
    }

    public String readObjectID() {
        return id;
    }

    public String createObjectID() {
        if (id == null) {
            id = UUID.randomUUID().toString();
        }
        return id;
    }

    public String generateID() {
        return UUID.randomUUID().toString();
    }

    @Override
    public String toString() {
        return ""MYCLASS{"" +
                ""id='"" + id + '\' +
                '}';
    }
}"
4,"import org.hamcrest.Description;
import org.hamcrest.Factory;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeDiagnosingMatcher;

public class GreaterThan<T extends Comparable<T>> extends TypeSafeDiagnosingMatcher<T> {

    private final T value;

    public GreaterThan(T value) {
        this.value = value;
    }

    @Factory
    public static <T extends Comparable<T>> Matcher<T> greaterThan(T value) {
        return new GreaterThan<T>(value);
    }

    @Override
    protected boolean matchesSafely(T item, Description mismatchDescription) {
        return item.compareTo(value) > 0;
    }

    @Override
    public void describeTo(Description description) {
        description.appendText(""a value greater than "").appendValue(value);
    }
}"
5,"public class Fraction {
    private int num;
    private int denom;

    public Fraction(int num, int denom) {
        this.num = num;
        this.denom = denom;
    }

    public int getDenom() {
        return denom;
    }

    public boolean isOne() {
        return num == 1 && denom == 1;
    }

    public int getScaled(int factor) {
        return num * factor / denom;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Fraction fraction = (Fraction) o;
        return num == fraction.num && denom == fraction.denom;
    }

    public int getNum() {
        return num;
    }
}"
6,"import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.google.cloud.bigtable.hbase.BigtableConfiguration;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.util.Bytes;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class WriteGenericJSON {
  private static final byte[] COLUMN_FAMILY_NAME = Bytes.toBytes(""tweet"");

  public static void writeGenericJSON(String projectId, String instanceId, String tableId) {
    // String projectId = ""my-project-id"";
    // String instanceId = ""my-instance-id"";
    // String tableId = ""mobile-time-series"";

    try (Connection connection = BigtableConfiguration.connect(projectId, instanceId)) {
      Table table = connection.getTable(TableName.valueOf(Bytes.toBytes(tableId)));
      long timestamp = System.currentTimeMillis() * 1000; // current time in microseconds
      byte[] rowKey = Bytes.toBytes(""tablet#a0b81f74#20190501"");
      Put put = new Put(rowKey);

      Map<String, String> fields = new HashMap<>();
      fields.put(""lat"", ""37.33233141"");
      fields.put(""id_str"", ""1125537471509590017"");
      fields.put(""screen_name"", null);
      fields.put(""place_name"", null);
      fields.put(""image"", null);
      fields.put(""user_name"", ""@bglick"");
      fields.put(""lng"", ""-122.0312186"");
      fields.put(""created_at"", ""Mon May 06 19:34:05 +0000 2019"");
      fields.put(""loc_radius"", null);
      fields.put(""user_id"", ""15245514"");
      fields.put(""text"", ""Major incident on the # A1 # M111 # London"");
      ArrayList<String> extras = new ArrayList<>();
      extras.add(""firstExtra"");
      extras.add(""secondExtra"");

      // Build a generic JSON object, filling in the fields
      GenericJSONBuilder builder = new GenericJSONBuilder(timestamp);
      builder.setIdStr(fields.get(""id_str"")).setPlaceName(fields.get(""place_name"")).addText(fields.get(""text""))
          .addField(""image"", fields.get(""image"")).setUserid(fields.get(""user_id"")).addExtras(extras);
      // Set geospatial coordinate
      if (fields.containsKey(""lat"") && fields.containsKey(""lng"")) {
        builder.addCoordinate(Double.parseDouble(fields.get(""lat"")), Double.parseDouble(fields.get(""lng"")));
      }
      // Set author information
      if (fields.containsKey(""screen_name"")) {
        builder.setAuthor(fields.get(""screen_name""));
      }
      if (fields.containsKey(""user_name"")) {
        builder.setAuthor(fields.get(""user_name""));
      }
      // Set locational radius, if present
      if (fields.containsKey(""loc_radius"")) {
        builder.setCoordinateRadius(Integer.parseInt(fields.get(""loc_radius"")));
      }
      // Set created time
      if (fields.containsKey(""created_at"")) {
        builder.setCreatedTime(new Date(fields.get(""created_at"")));
      }

      // Insert the data into a Put
      put.add(COLUMN_FAMILY_NAME, Bytes.toBytes(""generic_data""),
          Bytes.toBytes(builder.buildFieldJSON().toString()));
      table.put(put);

      System.out.printf(""Successfully wrote row %s%n"", Bytes.toString(put.getRow()));
    } catch (IOException | JSONException e) {
      System.out.println(""Error during WriteGenericJSON: \n"" + e.toString());
    }
  }

  public static class GenericJSONBuilder {
    // core
    private JSONObject genericJSON = new JSONObject();
    private long timestamp;

    // optional
    private String idStr;
    private String placeName;
    private JSONArray text = new JSONArray();
    private JSONObject coordinatesObj;
    private JSONObject authorObj;
    private int coordinateRadius;
    private Date createdTime;
    private ArrayList<String> extras = new ArrayList<>();

    public GenericJSONBuilder(long timestamp) {
      this.timestamp = timestamp;
    }

    public GenericJSONBuilder setIdStr(String idStr) {
      this.idStr = idStr;
      return this;
    }

    public GenericJSONBuilder setPlaceName(String placeName) {
      this.placeName = placeName;
      return this;
    }

    public GenericJSONBuilder addText(String tweetText) {
      this.text.put(tweetText);
      return this;
    }

    public GenericJSONBuilder addField(String name, String value) {
      this.genericJSON.put(name, value);
      return this;
    }

    public GenericJSONBuilder setUserid(String userId) {
      getJSONObject().put(""userid"", userId);
      return this;
    }

    public JSONObject getJSONObject() {
      return this.genericJSON;
    }

    public GenericJSONBuilder setCreatedTime(Date createdTime) {
      this.createdTime = createdTime;
      return this;
    }

    public GenericJSONBuilder setCoordinate(double lat, double lng) {
      if (this.coordinatesObj == null) {
        this.coordinatesObj = new JSONObject();
      }
      this.coordinatesObj.put(""latitude"", lat);
      this.coordinatesObj.put(""longitude"", lng);
      return this;
    }

    public GenericJSONBuilder setCoordinateRadius(int radius) {
      this.coordinateRadius = radius;
      return this;
    }

    public GenericJSONBuilder setAuthor(String author) {
      if (this.authorObj == null) {
        this.authorObj = new JSONObject();
      }
      this.authorObj.put(""name"", author);
      return this;
    }

    public GenericJSONBuilder addExtras(ArrayList<String> extras) {
      JSONArray extrasArr = new JSONArray();
      for (String extra : extras) {
        extrasArr.put(extra);
      }
      this.genericJSON.put(""extras"", extrasArr);
      return this;
    }

    public String buildFieldJSON() throws JSONException {
      JSONObject builtObject = getJSONObject();
      if (idStr != null) {
        builtObject.put(""id_str"", idStr);
      }
      if (placeName != null) {
        builtObject.put(""place_name"", placeName);
      }
      if (text != null && text.length() > 0) {
        builtObject.put(""text"", text);
      }
      if (coordinatesObj != null) {
        builtObject.put(""coordinates"", coordinatesObj);
        if (coordinateRadius > 0) {
          coordinatesObj.put(""coordinate_radius"", coordinateRadius);
        }
      }
      if (authorObj != null) {
        builtObject.put(""author"", authorObj);
      }
      if (createdTime != null) {
        builtObject.put(""created_at"", createdTime);
      }
      return builtObject.toString(2);
    }
  }
}"
7,"public void stop(BundleContext bundleContext) throws Exception {
    if(events != null && sender != null) {
        events.removeListener(sender);
    }
    if(factories != null) {
        for(Map.Entry<String, XMPPConnectionFactory> entry : factories.entrySet()) {
            for(XMPPConnection conn : entry.getValue().getConnections()) {
                conn.disconnect();
            }
        }
    }
}"
8,"import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import io.github.resilience4j.core.IntervalFunction;
import io.vavr.CheckedRunnable;
import io.vavr.CheckedSupplier;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Function;
import java.util.function.Predicate;
import javax.annotation.CheckReturnValue;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class BufferedBlockInputStreamSeekTest {
  private static final int BUFFER_SIZE = 10;
  private static final byte[] BUFFER =
      new byte[] {
        (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
        (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09
      };
  private static final int BLOCK_SIZE = 4;

  @Mock private InputStream innerInputStream;

  @Mock private ScheduledExecutorService executorService;

  @Mock private Retry.Context context;

  @Captor private ArgumentCaptor<CheckedRunnable> actionCaptor;

  @Captor private ArgumentCaptor<CheckedSupplier<Boolean>> conditionCaptor;

  @Captor private ArgumentCaptor<Predicate<Throwable>> retryOnPredicateCaptor;

  @Captor private ArgumentCaptor<Function<Throwable, Duration>> retryIntervalFunctionCaptor;

  private BufferedBlockInputStream mTestStream;

  @Before
  public void before() throws IOException {
    mTestStream = new BufferedBlockInputStream(innerInputStream, executorService, BUFFER_SIZE, BLOCK_SIZE);
    mTestStream.read(BUFFER);
  }

  @After
  public void after() throws IOException {
    assertThat(mTestStream.available()).isEqualTo(0);
    mTestStream.close();
  }

  @Test
  public void bufferRead() throws Throwable {
    // Seek back to the beginning
    mTestStream.seek(0);

    // Read 5 bytes from the stream
    byte[] b = new byte[5];
    assertThat(mTestStream.read(b, 0, 5)).isEqualTo(5);

    // Verify that the underlying stream was read from once
    verify(innerInputStream, times(1)).read(actionCaptor.capture());
    CheckedRunnable action = actionCaptor.getValue();
    // The read should have been executed exactly once
    action.run();
  }

  @Test
  public void skip() throws Throwable {
    // Seek back to the beginning
    mTestStream.seek(0);

    // Skip 5 bytes from the stream
    assertThat(mTestStream.skip(5)).isEqualTo(5);

    // Verify that the underlying stream was read from once
    verify(innerInputStream, times(1)).read(actionCaptor.capture());
    CheckedRunnable action = actionCaptor.getValue();
    // The read should have been executed exactly once
    action.run();
  }

  @Test
  public void bulkRead() throws Throwable {
    // Seek back to the beginning
    mTestStream.seek(0);

    // Read all 10 bytes from the stream
    byte[] b = new byte[10];
    assertThat(mTestStream.read(b, 0, 10)).isEqualTo(10);

    // Verify that the underlying stream was read from three times
    verify(innerInputStream, times(3)).read(actionCaptor.capture());
    CheckedRunnable action1 = actionCaptor.getAllValues().get(0);
    CheckedRunnable action2 = actionCaptor.getAllValues().get(1);
    CheckedRunnable action3 = actionCaptor.getAllValues().get(2);
    // The first two reads should have been executed exactly once
    action1.run();
    action2.run();
    // The third read should have been executed only once
    action3.run();
  }

  @Test
  public void singleByteRead() throws Throwable {
    // Seek back to the beginning
    mTestStream.seek(0);

    // Read a single byte from the stream
    assertThat(mTestStream.read()).isEqualTo(0x00);

    // Verify that the underlying stream was read from once
    verify(innerInputStream, times(1)).read(actionCaptor.capture());
    CheckedRunnable action = actionCaptor.getValue();
    // The read should have been executed exactly once
    action.run();
  }

  @Test
  public void singleByteReadWithTimeout() throws Throwable {
    // Seek back to the beginning
    mTestStream.seek(0);

    // Set a timeout of 10 ms
    mTestStream.setTimeout(10, TimeUnit.MILLISECONDS);

    // Read a single byte from the stream
    assertThat(mTestStream.read()).isEqualTo(0x00);

    // Verify that the executor service was scheduled to run once
    verify(executorService, times(1)).scheduleAtFixedRate(actionCaptor.capture(), conditionCaptor.capture(),
        anyLong(), anyLong(), any(TimeUnit.class));

    // Get the action and condition
    CheckedRunnable action = actionCaptor.getValue();
    CheckedSupplier<Boolean> condition = conditionCaptor.getValue();

    // The action should have been executed exactly once
    action.run();

    // The condition should have been checked exactly once
    assertThat(condition.get()).isFalse();
  }

  @Test
  public void singleByteReadWithTimeoutAndRetry() throws Throwable {
    // Seek back to the beginning
    mTestStream.seek(0);

    // Set a timeout of 10 ms
    mTestStream.setTimeout(10, TimeUnit.MILLISECONDS);

    // Set a retry policy
    mTestStream.retry(Retry.anyOf(IOException.class, TimeoutException.class), Retry.fixedDelay(100, TimeUnit.MILLISECONDS));

    // Read a single byte from the stream
    assertThat(mTestStream.read()).isEqualTo(0x00);

    // Verify that the executor service was scheduled to run once
    verify(executorService, times(1)).scheduleAtFixedRate(actionCaptor.capture(), conditionCaptor.capture(),
        anyLong(), anyLong(), any(TimeUnit.class));

    // Get the action and condition
    CheckedRunnable action = actionCaptor.getValue();
    CheckedSupplier<Boolean> condition = conditionCaptor.getValue();

    // The action should have been executed exactly once
    action.run();

    // The condition should have been checked exactly once
    assertThat(condition.get()).isFalse();

    // Verify that the retry policy was applied
    verify(context, times(1)).onNextAttempt(retryOnPredicateCaptor.capture(), retryIntervalFunctionCaptor.capture());

    // Get the retry on predicate and retry interval function
    Predicate<Throwable> retryOnPredicate = retryOnPredicateCaptor.getValue();
    Function<Throwable, Duration> retryIntervalFunction = retryIntervalFunctionCaptor.getValue();

    // The retry on predicate should match the retry policy
    assertThat(retryOnPredicate.test(any(IOException.class))).isTrue();
    assertThat(retryOnPredicate.test(any(TimeoutException.class))).isTrue();

    // The retry interval function should match the retry policy
    assertThat(retryIntervalFunction.apply(any(IOException.class))).isEqualTo(Duration.ofMillis(100));
    assertThat(retryIntervalFunction.apply(any(TimeoutException.class))).isEqualTo(Duration.ofMillis(100));
  }

  @CheckReturnValue
  private <T> T any(Class<T> clazz) {
    return clazz.cast(null);
  }
}"
9,"import java.lang.ref.Unreachable;
import java.lang.ref.WeakReference;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public final class GcAssertions {
  private GcAssertions() {}
  /**
   * Tries to perform a `` full ' garbage collection cycle including processing of weak references and
   * invocation of finalize methods and waits for it to complete. Ensures that at least one weak
   * reference has been cleared and one finalize method has been run before thismethod returns. This
   * method may be useful when testing the garbage collection mechanism itself, or inhibiting a
   * spontaneous gc initiation in subsequent code. In contrast, a plain call to
   * java.lang.System#gc does not ensure finalizationprocessing and may run concurrently, for example,
   * if the jvm flag -Xmx+ExplicitGCInvokesConcurrent is used. Whenever possible, it is preferable to
   * test directly for some observable change resulting from gc, as with #awaitClear. Because there are
   * no guarantees for the order of gc finalization processing, there may still be some unfinished work
   * for the gc to do after this method returns. This method does not create any memory pressure as
   * would be required to cause soft references to be processed.
   *
   * @param placeHolder a place holder to keep this object from being gc-ed.
   * @param timeoutSeconds the maximum number of seconds to wait for gc to complete
   */
  public static void await(Object placeHolder, long timeoutSeconds) {
    awaitClear(placeHolder, timeoutSeconds);
    // Wait for processing of our un-referenced latch.
    LatchFinalizer latch = createUnreachableLatchFinalizer();
    awaitDone(latch, timeoutSeconds * 1000);
    // Ensure the gc has done its job by waiting on the latch.
    if (!isDone(latch, timeoutSeconds * 1000)) {
      throw formatRuntimeException(""gc did not complete as requested"");
    };
  }

  private static LatchFinalizer createUnreachableLatchFinalizer() {
    LatchFinalizer latch = new LatchFinalizer();
    WeakReference<LatchFinalizer> ref = new WeakReference<>(latch);
    latch = null;
    if (ref.get() == null) {
      // We are unreachable at this point.
      return ref.get();
    }
    throw formatRuntimeException(""Creating an unreachable latch failed"");
  }

  /** Wait for `latch` to reach zero. */
  private static void awaitDone(LatchFinalizer latch, long timeoutMicros) {
    awaitDone(latch.latch, timeoutMicros);
  }

  /** Wait for the latch to reach zero. */
  private static void awaitDone(CountDownLatch latch, long timeoutMicros) {
    try {
      if (!latch.await(timeoutMicros, TimeUnit.MICROSECONDS)) {
        throw formatRuntimeException(""gc did not finish in time"");
      }
    } catch (InterruptedException e) {
      throw formatRuntimeException(e, ""Interrupted"");
    }
  }

  /** Is the latch at zero. */
  private static boolean isDone(LatchFinalizer latch, long timeoutMicros) {
    return isDone(latch.latch, timeoutMicros);
  }

  /** Is the latch at zero. */
  private static boolean isDone(CountDownLatch latch, long timeoutMicros) {
    try {
      return latch.await(timeoutMicros, TimeUnit.MICROSECONDS);
    } catch (InterruptedException e) {
      throw formatRuntimeException(e, ""Interrupted"");
    }
  }

  private static RuntimeException formatRuntimeException(String message) {
    return formatRuntimeException(null, message);
  }

  private static RuntimeException formatRuntimeException(Throwable e, String message) {
    StringBuilder sb = new StringBuilder();
    sb.append(message);
    if (e != null) {
      sb.append(""\n   caused by: "");
      sb.append(e.toString());
    }
    return new RuntimeException(sb.toString());
  }

  static class LatchFinalizer extends Unreachable {
    final CountDownLatch latch = new CountDownLatch(1);

    LatchFinalizer() {
      super();
    }

    @Override
    public void finalize() {
      super.finalize();
      latch.countDown();
    }
  }
}"
10,"import org.junit.After;
import org.junit.Before;

import java.io.IOException;

public class LocalTransferManagerIntegrationTest {

  private TransferManager mManager;
  private String BUCKET_NAME = ""default"";
  private String KEY = ""random.txt"";
  private S3ADirectOutputStream mStream;

  @Before
  public void setUp() throws IOException {
    // Provide credentials by setting environment variables as shown in AWS SDK for Java
    // documentation. If you provide credentials in other ways (e.g. using an instance profile)
    // you will need to modify this so the SDK can find the credentials.
    mManager = AmazonS3ClientBuilder.defaultClient();
    mStream = (S3ADirectOutputStream) mManager.openDirectOutputStream(BUCKET_NAME, KEY, ""text/plain"");
  }

  @After
  public void tearDown() throws IOException {
    // Shutting down client and deleting test file
    mStream.close();
    mManager.shutdown();
    mManager.deleteObject(BUCKET_NAME, KEY);
  }

  //...
}"
11,"import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.LinkedListMultimap;
import com.google.common.collect.ListMultimap;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

public class FunctionDocs {
  // A string which will join all the lines in the documentation
  protected static final String LINE_SEPARATOR = ""\n"";

  // The functions comment string
  private String docs;
  // A multimap used to store the comments for the parameters
  private ListMultimap<String, String> parameterComments;

  public FunctionDocs() {
    this.docs = "";
    this.parameterComments = LinkedListMultimap.create();
  }

  public FunctionDocs(String text) {
    this();
    appendComment(text);
  }

  public String getComments() {
    StringBuilder builder = new StringBuilder();
    String temp = docs;
    String parameterComment = Strings.emptyToNull(getParameterCommentsAsString());
    if (!Strings.isNullOrEmpty(parameterComment)) {
      temp += LINE_SEPARATOR + LINE_SEPARATOR + parameterComment;
    }
    builder.append(temp);
    return builder.toString();
  }

  private String getParameterCommentsAsString() {
    List<String> lines = new LinkedList<>();
    for (String key : parameterComments.keys()) {
      lines.add(String.format(""@param %s %s"", key, parameterComments.get(key)));
    }
    return Strings.join(lines, LINE_SEPARATOR);
  }

  public boolean hasDocs() {
    return !Strings.isNullOrEmpty(docs);
  }

  public void setDocs(String text) {
    Preconditions.checkNotNull(text);
    docs = text.trim();
  }

  public int appendComment(String text) {
    Preconditions.checkNotNull(text);
    docs += formatComment(text).trim();
    return docs.length();
  }

  public static String defaultFor(String s) {
    return Strings.isNullOrEmpty(s) ? "" : s;
  }

  public static String formatComment(String comment) {
    String[] lines = comment.split(LINE_SEPARATOR);
    StringBuilder sb = new StringBuilder();
    sb.append(defaultFor(lines[0])).append(LINE_SEPARATOR);
    return sb.toString();
  }

  public List<String> getParameterNames() {
    return new ArrayList<>(parameterComments.keySet());
  }

  public String getParameter(String name) {
    if (parameterComments.containsKey(name)) {
      return parameterComments.get(name).get(0);
    }
    return null;
  }

  public void setParameter(String name, String comment) {
    parameterComments.put(name, comment);
  }

  private static enum Token {
    CloseParen,
    Comment,
    OpenParen,
    Param,
    Tag,
    Text,
  }

  /**
   * Break into tokens (comment or text).
   *
   * @param in Original c-style comment string.
   * @return list of Tokens
   */
  public static List<Token> lex(String in) {
    List<Token> tokens = new ArrayList<Token>();
    boolean escaped = false;
    int paren = 0; // paren nesting level
    String tag = null;
    String name = null;
    String comment = null;
    String text = null;

    Deque<String> stack = new ArrayDeque<String>();

    for (char ch : in.toCharArray()) {
      switch (ch) {
        case '/':
          if (escaped) {
            stack.push(text);
            text = ""/"";
            comment = null;
            escaped = false;
          } else if (comment == null) {
            stack.push(text);
            comment = ""/"";
            text = null;
          } else {
            comment += ch;
          }
          break;

        case '*':
          if (!escaped && comment != null) {
            comment += ch;
          }
          break;

        case '\r':
        case '\n':
          if (!escaped && comment == null) {
            break;
          }
          // fall through

        case ' ':
        case '\t':
          // consume whitespace inside tags
          if (text != null) {
            text += ch;
          }
          break;

        case '\\':
          // next char is escaped
          if (escaped) {
            // pushes to stack, pops on another escape
            stack.push(text);
            text = String.valueOf(ch);
            escaped = false;
          } else {
            escaped = true;
          }
          break;

        case ':':
          if (escaped) {
            stack.push(text);
            text = "":"";
            escaped = false;
          }
          break;

        case '.':
        case '@':
          tag = "";
          name = "";
          comment = null; // must be param comment
          text = null;
          tokens.add(Token.Tag);
          break;

        case '(':
          if (paren == 0) {
            if (tag != null) {
              tokens.add(Token.Param);
            } else {
              tokens.add(Token.OpenParen);
            }
          }
          paren++;
          break;

        case ')':
          paren--;
          if (paren == 0) {
            if (tag != null) {
              tokens.add(Token.Tag);
            } else {
              tokens.add(Token.CloseParen);
            }
          }
          break;

        default:
          if (tag == null) {
            if (comment == null) {
              if (text == null) {
                text = "";
              }
              text += ch;
            } else {
              comment += ch;
            }
          } else {
            if (name == null) {
              name += ch;
            } else {
              comment += ch;
            }
          }
      }
      if (!stack.isEmpty()) {
        if (text == null) {
          text = stack.pop();
        } else {
          text += stack.pop();
        }
      }
      if (tag != null && name != null && comment != null) {
        tokens.add(Token.Tag);
        tag = null;
        name = null;
        comment = null;
      }
    }
    tokens.add(Token.Text); // fake token denoting end of text

    List<Token> merged = new ArrayList<Token>();
    Token last = Token.Text;
    for (Token token : tokens) {
      if (token != Token.Text || last != Token.Text) {
        merged.add(token);
      }
      last = token;
    }

    return merged;
  }

  /**
   * Extract Javadoc from c-style comment.
   *
   * @param in Original c-style comment string.
   * @return map of param names to comments
   */
  public static FunctionDocs parse(String in) {
    FunctionDocs docs = new FunctionDocs();

    List<Token> tokens = lex(in);
    List<String> names = new ArrayList<String>();

    String text = null;
    String tag = null;
    String comment = null;

    boolean inDoc = false;

    for (Token token : tokens) {
      switch (token) {

        case OpenParen:
          text = "";
          break;

        case CloseParen:
          if (inDoc) {
            docs.appendComment(text);
          }
          text = null;
          break;

        case Tag:
          if (inDoc) {
            docs.appendComment(text);
          }
          if (tag == null) {
            if (comment != null) {
              // assume last tag has ended
              tag = comment;
              comment = null;
            }
          } else {
            if (comment != null) {
              if (tag.equals(""@param"")) {
                if (names.isEmpty()) {
                  // reuse the text from the @function tag
                  docs.setParameter(text, comment);
                } else {
                  docs.setParameter(names.get(0), comment);
                  names = names.subList(1, names.size());
                }
              } else {
                // assume all others are the @function tag
                docs.setDocs(comment);
              }
              comment = null;
            }
            tag = null;
          }
          text = "";
          break;

        case Comment:
          if (inDoc) {"
12,"import java.util.List;
import java.util.logging.Logger;

class MyClass {
  private static final Logger LOG = Logger.getLogger(MyClass.class.getName());
  private long delayBetweenRetries;
  private List<String> alternateAddresses;

  public void selectAlternateAddress() {
    LOG.info(""Selecting an alternate address from: "" + alternateAddresses);
    // Logic to select an alternate address from 'alternateAddresses'
    String selectedAddress = ...;
    // Logic to set the delay between retries
    long delay = ...;
    setDelayBetweenRetries(delay);
  }

  public void setDelayBetweenRetries(long delayBetweenRetries) {
    this.delayBetweenRetries = delayBetweenRetries;
  }

  public List<Endpoint> getEndpoints() {
    // Logic to get a list of endpoints
    return ...;
  }

  public Endpoint getNextAlternate() {
    // Logic to get the next alternate endpoint
    return ...;
  }

  public long getDelayBetweenRetries() {
    return delayBetweenRetries;
  }

  public void setAlternateAddresses(List<String> alternateAddresses) {
    this.alternateAddresses = alternateAddresses;
  }

  public List<Endpoint> getAlternateEndpoints() {
    // Logic to get a list of alternate endpoints
    return ...;
  }

  public Endpoint selectAlternateEndpoint() {
    // Logic to select an alternate endpoint
    return ...;
  }

  public List<String> getAlternateAddresses() {
    return alternateAddresses;
  }
}"
13,"import java.util.*;

class TSTNode {
    char data;
    TSTNode left;
    TSTNode root;
    TSTNode right;
    ArrayList<String> al;
    boolean is_End_Of_String;

    TSTNode(char ch) {
        data = ch;
        left = null;
        root = null;
        right = null;
        al = new ArrayList<>();
        is_End_Of_String = false;
    }
}

class TrieST {
    TSTNode root = null;

    // If TST is empty
    boolean isEmpty() {
        return root == null;
    }

    // If current TSTNode is null
    boolean isEmpty(TSTNode temp) {
        return temp == null;
    }

    // Insert a new word to the TST
    void insert(String key, String value) {
        if (root == null) {
            root = new TSTNode(key.charAt(0));
        }
        insert(root, key, 1, value);
    }

    // Insert a new word to the TST
    void insert(TSTNode temp, String key, int index, String value) {
        if (isEmpty(temp)) {
            temp = new TSTNode(key.charAt(index));
        }

        if (key.charAt(index) < temp.data) {
            insert(temp.left, key, index, value);
        } else if (key.charAt(index) > temp.data) {
            insert(temp.right, key, index, value);
        } else {
            if (index == key.length() - 1) {
                temp.al.add(value);
                temp.is_End_Of_String = true;
            } else {
                insert(temp.root, key, index + 1, value);
            }
        }
    }

    // Search a word in the TST
    boolean search(String key) {
        return search(root, key, 0);
    }

    // Search a word in the TST
    boolean search(TSTNode temp, String key, int index) {
        if (isEmpty(temp)) {
            return false;
        }
        if (key.charAt(index) < temp.data) {
            return search(temp.left, key, index);
        } else if (key.charAt(index) > temp.data) {
            return search(temp.right, key, index);
        } else {
            if (index == key.length() - 1) {
                return temp.is_End_Of_String;
            } else {
                return search(temp.root, key, index + 1);
            }
        }
    }

    // Delete a word from the TST
    void delete(String key) {
        delete(root, key, 0);
    }

    // Delete a word from the TST
    void delete(TSTNode temp, String key, int index) {
        if (isEmpty(temp)) {
            return;
        }
        if (key.charAt(index) < temp.data) {
            delete(temp.left, key, index);
        } else if (key.charAt(index) > temp.data) {
            delete(temp.right, key, index);
        } else {
            if (index == key.length() - 1) {
                temp.is_End_Of_String = false;
                temp.al.clear();
            } else {
                delete(temp.root, key, index + 1);
            }
        }
    }

    // Traverse the TST
    void traverse(TSTNode temp, String s) {
        if (temp == null) {
            return;
        }
        traverse(temp.left, s);

        if (temp.is_End_Of_String) {
            for (String str : temp.al) {
                System.out.println(s + temp.data + str);
            }
        }

        traverse(temp.root, s + temp.data);

        traverse(temp.right, s);
    }

    // Make the TST empty
    void makeEmpty() {
        root = null;
    }

    // Convert the TST to String
    String toString() {
        StringBuilder sb = new StringBuilder();
        traverse(root, "" "");
        return sb.toString();
    }

    // Main function
    public static void main(String[] args) {
        TrieST t = new TrieST();
        t.insert(""the"", ""a"");
        t.insert(""a"", ""b"");
        t.insert(""there"", ""c"");
        t.insert(""answer"", ""d"");
        t.insert(""any"", ""e"");
        t.insert(""by"", ""f"");
        t.insert(""bye"", ""g"");
        t.insert(""their"", ""h"");

        System.out.println(t.search(""the""));
        System.out.println(t.search(""these""));
        System.out.println(t.search(""their""));
        System.out.println(t.toString());
        t.delete(""there"");
        System.out.println(t.toString());
        t.makeEmpty();
        System.out.println(t.isEmpty());
    }
}"
14,"results = new TreeMap<String, SortedMap<String, SortedMap<String, SortedMap<String, byte[]>>>>();
        byte[] Row = null;
        Scan scan = new Scan().setMaxVersions();
        scan.setCacheBlocks(false);
        scan.setBatch(100);
        Table hTable = conn.getTable(tableName);
        ResultScanner scanner = hTable.getScanner(scan);
        for (Result r : scanner) {
          Row = r.getRow();
          String[] keys = Bytes.toString(Row).split(""\t"");
          if (results.containsKey(keys[0])) {
            if (results.get(keys[0]).containsKey(keys[1])) {
              if (results.get(keys[0]).get(keys[1]).containsKey(keys[2])) {
                results.get(keys[0]).get(keys[1]).get(keys[2]).put(keys[3], r.getValue(fam3, qual3));
              } else {
                SortedMap<String, SortedMap<String, byte[]>> m4 = new TreeMap<String, SortedMap<String, byte[]>>();
                m4.put(keys[3], r.getValue(fam3, qual3));
                results.get(keys[0]).get(keys[1]).put(keys[2], m4);
              }
            } else {
              SortedMap<String, SortedMap<String, byte[]>> m3 = new TreeMap<String, SortedMap<String, byte[]>>();
              SortedMap<String, byte[]> m4 = new TreeMap<String, byte[]>();
              m4.put(keys[3], r.getValue(fam3, qual3));
              m3.put(keys[2], m4);
              results.get(keys[0]).put(keys[1], m3);
            }
          } else {
            SortedMap<String, SortedMap<String, SortedMap<String, byte[]>>> m2 =
                new TreeMap<String, SortedMap<String, SortedMap<String, byte[]>>>();
            SortedMap<String, SortedMap<String, byte[]>> m3 = new TreeMap<String, SortedMap<String, byte[]>>();
            SortedMap<String, byte[]> m4 = new TreeMap<String, byte[]>();
            m4.put(keys[3], r.getValue(fam3, qual3));
            m3.put(keys[2], m4);
            m2.put(keys[1], m3);
            results.put(keys[0], m2);
          }
        }
        scanner.close();
        hTable.close();"
15,"import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

class UserStoreManager {
    private final Map<String, Map<String, String>> userStoreManagers = new HashMap<>();
    private final Set<String> availableDomainNames = new HashSet<>();

    public void clearUserStoreManager() {
        userStoreManagers.clear();
    }

    public void addUserStoreManager(String domainName, String username, String password) {
        if (!availableDomainNames.contains(domainName)) {
            availableDomainNames.add(domainName);
        }
        Map<String, String> credentials = new HashMap<>();
        credentials.put(""username"", username);
        credentials.put(""password"", password);
        userStoreManagers.put(domainName, credentials);
    }

    public Map<String, String> getUserStoreManager(String domainName) {
        return userStoreManagers.get(domainName);
    }
}"
16,"import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Map;
import javax.xml.namespace.NamespaceContext;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

public class XmlParser {

    private Document doc;
    private XPath xPath;

    public XmlParser(InputStream stream) throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        doc = builder.parse(new InputSource(stream));
        xPath = XPathFactory.newInstance().newXPath();
        xPath.setNamespaceContext(new NamespaceContext() {
            @Override
            public String getNamespaceURI(String prefix) {
                return doc.lookupNamespaceURI(prefix);
            }

            @Override
            public String getPrefix(String namespaceURI) {
                return doc.lookupPrefix(namespaceURI);
            }

            @Override
            public Iterator getPrefixes(String namespaceURI) {
                return null;
            }
        });
    }

    public Map<String, String> getNamespaces() {
        return null;
    }

    public URI[] getLinks(String XML_NAMESPACE) {
        return null;
    }

    public String getPrefix(String XML_NAMESPACE) {
        return null;
    }

    public <T> T[] getNodes(String XML_NAMESPACE, QName qName) {
        return null;
    }

    public <T> T[] getNodes(String XML_NAMESPACE, String xPathExpression) {
        return null;
    }

    public void setBuffering(boolean b) {}

    public String getValue(String XML_NAMESPACE, QName qName) {
        return null;
    }

    public String getValue(String XML_NAMESPACE, String xPathExpression) {
        String result = null;
        try {
            result = xPath.evaluate(xPathExpression, doc, XPathConstants.STRING.type());
        } catch (XPathExpressionException e) {
            e.printStackTrace();
        }
        return result;
    }

    public <T> T getValue(String XML_NAMESPACE, QName qName, Class<T> type) {
        return null;
    }

    public URI getLink(String XML_NAMESPACE, QName qName) {
        return null;
    }

    public URI getLink(String XML_NAMESPACE, String xPathExpression) {
        return null;
    }

    public String getNamespaceURI(String XML_NAMESPACE, String prefix) {
        return null;
    }

    public Iterator<?> getPrefixes(String XML_NAMESPACE) {
        return null;
    }

    public Object readPrimitiveValue(String XML_NAMESPACE, QName qName) {
        return null;
    }

    public <T> T getNode(String XML_NAMESPACE, QName qName) {
        return null;
    }

    public <T> T getNode(String XML_NAMESPACE, String xPathExpression) {
        return null;
    }

    public URI getBaseURI() {
        return null;
    }

    public Object evaluate(String XML_NAMESPACE, String expression) {
        return null;
    }

    public <T> T readNode(String XML_NAMESPACE, QName qName) {
        return null;
    }
}"
17,"List<JavaFileObject> outputFiles = validate(extensionInfo, loader, eq, outputFiles, allExtensions, jobs, outputWidth);
if (eq.hasErrors()) {
  return false;
}

for (ExtensionInfo ext : allExtensions) {
  ext.getOverriddenFields();
  ext.addExtension(sourceExtension);
  ext.serializeClassInfo();
}
return runToGoal(sourceExtension, compileFiles);"
18,"import android.content.Context;
import android.content.SharedPreferences;
import android.location.LocationManager;

public class GpsUtils {

    public static boolean getGPS(Context context) {
        // TODO: Implement this method to enable/disable GPS
        // Return true if GPS is enabled, false otherwise.
        boolean gpsEnabled = false;
        try {
            LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
            gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return gpsEnabled;
    }

    public static void enableGPS(Context context) {
        // TODO: Implement this method to enable GPS
        SharedPreferences preferences = context.getSharedPreferences(""GpsUtils"", Context.MODE_PRIVATE);
        boolean gpsEnabled = preferences.getBoolean(""gpsEnabled"", false);
        if (!gpsEnabled) {
            LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
            try {
                locationManager.setTestProviderEnabled(LocationManager.GPS_PROVIDER, true);
                preferences.edit().putBoolean(""gpsEnabled"", true).apply();
            } catch (SecurityException e) {
                e.printStackTrace();
            }
        }
    }

    public static void disableGPS(Context context) {
        // TODO: Implement this method to disable GPS
        SharedPreferences preferences = context.getSharedPreferences(""GpsUtils"", Context.MODE_PRIVATE);
        boolean gpsEnabled = preferences.getBoolean(""gpsEnabled"", false);
        if (gpsEnabled) {
            LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
            try {
                locationManager.setTestProviderEnabled(LocationManager.GPS_PROVIDER, false);
                preferences.edit().putBoolean(""gpsEnabled"", false).apply();
            } catch (SecurityException e) {
                e.printStackTrace();
            }
        }
    }
}"
19,"public static int isLayoutDirectionRTL(View view) {
    TypedValue mTmpValue = new TypedValue();
    if (!view.getContext().getTheme().resolveAttribute(android.R.attr.layoutDirection, mTmpValue, true)) {
        return 0;
    }
    if (mTmpValue.data == View.LAYOUT_DIRECTION_RTL) {
        return 1;
    } else {
        return 0;
    }
}"
20,"api.register(
        ApiFutures.transform(
            api.get(element),
            new Function<ApiFuture<Element>, ApiFuture<Void>>() {
              @Nullable
              @Override
              public ApiFuture<Void> apply(ApiFuture<Element> input) {
                final Element element = input.get();
                final Checklist checklist = element.getChecklist();
                if (checklist == null || checklist.isEmpty()) {
                  return Futures.immediateFuture(null);
                }
                Set<String> statusKeys = checklist.getKeySet();
                for (String aStatusKey : statusKeys) {
                  api.register(
                      ApiFutures.transform(
                          api.get(checklist.getStatus(aStatusKey)),
                          new Function<ApiFuture<ChecklistStatus>, ApiFuture<Void>>() {
                            @Nullable
                            @Override
                            public ApiFuture<Void> apply(ApiFuture<ChecklistStatus> input) {
                              final ChecklistStatus status = input.get();
                              status.register(
                                  ApiFutures.transform(
                                      api.get(status.getMetadata()),
                                      new Function<
                                          ApiFuture<Metadata>, ApiFuture<Void>>() {
                                        @Nullable
                                        @Override
                                        public ApiFuture<Void> apply(
                                            ApiFuture<Metadata> input) {
                                          final Metadata metadata = input.get();
                                          System.out.printf(""User %s: %s\n"",
                                              metadata.getUser().getEmail(), status.getName());
                                          return Futures.immediateFuture(null);
                                        }
                                      }));
                              return Futures.immediateFuture(null);
                            }
                          }));
                }
                return Futures.immediateFuture(null);
              }
            }));"
21,"import java.util.Calendar;
import java.util.GregorianCalendar;
import net.sf.marineapi.nmea.util.Date;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

/**
 * Unit tests
 *
 * @author Garth Wells (gwells@gwells.org)
 */
public class DateTest
{
   private Date testSubject;

   @Before
   public void setUp()
   {
      this.testSubject = new Date();
      this.testSubject.setYear(2003);
      this.testSubject.setMonth(2);
      this.testSubject.setDay(1);
   }

   @Test
   public void testMethodForNetSfMarineapiNmeaUtil_date_setdayInt()
   {
      this.testSubject.setDay(1);
      assertEquals(1, this.testSubject.getDay());
   }

   @Test
   public void testGetMonth()
   {
      assertEquals(2, this.testSubject.getMonth());
   }

   @Test
   public void testEqualsItself()
   {
      assertTrue(this.testSubject.equals(this.testSubject));
   }

   @Test
   public void testSetYearNegative()
   {
      this.testSubject.setYear(-79);
      assertEquals(-79, this.testSubject.getYear());
   }

   @Test
   public void testConstructorWithValues()
   {
      Date d = new Date(1, 2003, 7);
      assertEquals(1, d.getMonth());
      assertEquals(2003, d.getYear());
      assertEquals(7, d.getDay());
   }

   @Test
   public void testGetYear()
   {
      assertEquals(2003, this.testSubject.getYear());
   }

   @Test
   public void testToISO8601WithTimeAndZeroZone()
   {
      assertEquals(""2003-03-01T00:00:00.000Z"", this.testSubject.toISO8601WithTimeAndZeroZone());
   }

   @Test
   public void testToISO8601FourDigitYear()
   {
      assertEquals(""2003-03-01"", this.testSubject.toISO8601WithFourDigitYear());
   }

   @Test
   public void testSetDay()
   {
      this.testSubject.setDay(7);
      assertEquals(7, this.testSubject.getDay());
   }

   @Test
   public void testSetYearFourDigit()
   {
      this.testSubject.setYear(2003);
      assertEquals(2003, this.testSubject.getYear());
   }

   @Test
   public void testToStringTwoDigitYear()
   {
      this.testSubject.setYear(99);
      assertEquals(""03-01-99"", this.testSubject.toString());
   }

   @Test
   public void testToISO8601WithTimeAndPositiveOffset()
   {
      Calendar cal = GregorianCalendar.getInstance();
      assertEquals(cal.getTimeZone().getOffset(cal.getTimeInMillis()), this.testSubject.toISO8601WithTimeAndOffset(cal.getTimeZone().getOffset(cal.getTimeInMillis())).length() - 6);
   }

   @Test
   public void testToISO8601TwoDigitYear()
   {
      this.testSubject.setYear(99);
      assertEquals(""03-01-99"", this.testSubject.toISO8601WithTwoDigitYear());
   }

   @Test
   public void testSetYearFiveDigits()
   {
      this.testSubject.setYear(01234);
      assertEquals(1234, this.testSubject.getYear());
   }

   @Test
   public void testToISO8601WithTimeAndNegativeOffset()
   {
      Calendar cal = GregorianCalendar.getInstance();
      assertEquals(cal.getTimeZone().getOffset(cal.getTimeInMillis()), this.testSubject.toISO8601WithTimeAndOffset(-cal.getTimeZone().getOffset(cal.getTimeInMillis())).length() - 6);
   }

   @Test
   public void testGetDay()
   {
      assertEquals(1, this.testSubject.getDay());
   }

   @Test
   public void testSetMonthOutOfBounds()
   {
      try
      {
         this.testSubject.setMonth(20);
         fail();
      }
      catch(IllegalArgumentException e)
      {
         // ignore
      }
   }

   @Test
   public void testConstructor()
   {
      Date d = new Date();
      assertNotNull(d);
   }

   @Test
   public void testToStringFourDigitYear()
   {
      assertEquals(""2003-03-01"", this.testSubject.toString());
   }

   @Test
   public void testEqualsAfterInit()
   {
      Date d = new Date(3, 2003, 1);
      assertEquals(d, this.testSubject);
   }

   @Test
   public void testEqualsWrongType()
   {
      assertFalse(this.testSubject.equals(""abc""));
   }

   @Test
   public void testSetYearTwoDigit()
   {
      this.testSubject.setYear(99);
      assertEquals(99, this.testSubject.getYear());
   }

   @Test
   public void testEqualsWhenChanged()
   {
      Date d = new Date(3, 2003, 1);
      this.testSubject.setMonth(3);
      assertFalse(d.equals(this.testSubject));
   }

   @Test
   public void testToISO8601WithTime()
   {
      assertEquals(""2003-03-01T00:00:00.000Z"", this.testSubject.toISO8601WithTime());
   }

   @Test
   public void testConstructorWithString()
   {
      Date d = new Date(""2003-03-01"");
      assertEquals(3, d.getMonth());
      assertEquals(2003, d.getYear());
      assertEquals(1, d.getDay());
   }

   @Test
   public void testToStringTwoDigitYear()
   {
      this.testSubject.setYear(99);
      assertEquals(""03-01-99"", this.testSubject.toString());
   }

   @Test
   public void testGetMonthOutOfBounds()
   {
      try
      {
         new Date(20, 2003, 1);
         fail();
      }
      catch(IllegalArgumentException e)
      {
         // ignore
      }
   }

   @Test
   public void testSetYearThreeDigits()
   {
      this.testSubject.setYear(101);
      assertEquals(101, this.testSubject.getYear());
   }

}"
22,"public int nextAvailableTile(Array<Array<Array<Card>>> tiles, int player, int lane) {
    if (player == HUMAN_PLAYER) {
        lane = getMaxLane(tiles, lane, enemyBaseAttacked, laneWithLessAllies);
    } else if (player == COMPUTER_PLAYER) {
        lane = getMaxLane(tiles, lane, playerBaseAttacked, laneWithMoreEnemiesInvading);
    } else {
        return -1;
    }
    for(int i = 4; i >= 1; i--) {
        if (tiles.get(lane).get(i).length == 0) {
            return i;
        }
    }
    return -1;
}

private int getMaxLane(Array<Array<Array<Card>>> map, int lane, int playerBaseAttacked, int laneWithMoreEnemies) {
    if (playerBaseAttacked != -1) {
        if (map.get(lane).length > 4) {
            return lane;
        } else if (map.get(laneWithMoreEnemies).length > 4) {
            return laneWithMoreEnemies;
        } else {
            return playerBaseAttacked;
        }
    } else {
        return lane;
    }
}"
23,"import java.util.Arrays;
import java.util.Objects;

public class InverseMatrix {
    public static void main(String[] args) {
        double[][] input = {{1, 2}, {3, 4}};
        Matrix matrix = new Matrix(input);

        try {
            Matrix inverse = matrix.inverse();
            System.out.println(""Inverse of the matrix:"");
            System.out.println(inverse);
        } catch (Exception e) {
            System.out.println(""The matrix is not invertible."");
        }
    }

    static class Matrix {
        private final double[][] values;

        public Matrix(double[][] values) {
            this.values = values;
        }

        public Matrix inverse() {
            if (!isSquare()) {
                throw new IllegalArgumentException(""Matrix must be square to find inverse."");
            }

            double determinant = determinant();
            if (determinant == 0) {
                throw new IllegalArgumentException(""Matrix is not invertible."");
            }

            double[][] cofactorMatrix = cofactorMatrix();
            double[][] adjugateMatrix = transpose(cofactorMatrix);
            return multiply(adjugateMatrix, 1 / determinant);
        }

        public double determinant() {
            if (!isSquare()) {
                throw new IllegalArgumentException(""Matrix must be square to find determinant."");
            }

            int n = values.length;
            if (n == 1) {
                return values[0][0];
            }

            double determinant = 0;
            for (int i = 0; i < n; i++) {
                determinant += values[0][i] * cofactor(0, i);
            }

            return determinant;
        }

        private double[][] cofactorMatrix() {
            int n = values.length;
            double[][] cofactorMatrix = new double[n][n];

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    cofactorMatrix[i][j] = cofactor(i, j);
                }
            }

            return cofactorMatrix;
        }

        private double cofactor(int row, int column) {
            int n = values.length;
            int sign = (row + column) % 2 == 0 ? 1 : -1;

            double[][] subMatrix = createSubMatrix(row, column);
            return sign * determinant(new Matrix(subMatrix));
        }

        private double[][] transpose(double[][] matrix) {
            int n = matrix.length;
            double[][] transposed = new double[n][n];

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    transposed[i][j] = matrix[j][i];
                }
            }

            return transposed;
        }

        private double[][] multiply(double[][] matrix, double scalar) {
            int n = matrix.length;
            double[][] multiplied = new double[n][n];

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    multiplied[i][j] = matrix[i][j] * scalar;
                }
            }

            return multiplied;
        }

        private double[][] createSubMatrix(int row, int column) {
            int n = values.length;
            double[][] subMatrix = new double[n - 1][n - 1];

            for (int i = 0; i < n; i++) {
                if (i == row) {
                    continue;
                }

                for (int j = 0; j < n; j++) {
                    if (j == column) {
                        continue;
                    }

                    subMatrix[i - (i > row ? 1 : 0)][j - (j > column ? 1 : 0)] = values[i][j];
                }
            }

            return subMatrix;
        }

        private boolean isSquare() {
            return values.length == values[0].length;
        }

        @Override
        public String toString() {
            return Arrays.deepToString(values);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Matrix matrix = (Matrix) o;
            return Arrays.deepEquals(values, matrix.values);
        }

        @Override
        public int hashCode() {
            return Objects.hash(values);
        }
    }
}"
24,"import java.util.List;

public class JobExitStatus {

    public static final JobExitStatus NOOP = new JobExitStatus(""NOOP"");
    public static final JobExitStatus FILES_AVAILABLE = new JobExitStatus(""FILES_AVAILABLE"");
    public static final JobExitStatus CAPTURE_SOURCE_METADATA_ERRORS = new JobExitStatus(""CAPTURE_SOURCE_METADATA_ERRORS"");
    public static final JobExitStatus SOURCE_DELETION_ERRORS = new JobExitStatus(""SOURCE_DELETION_ERRORS"");
    public static final JobExitStatus DOWNLOAD_ERRORS = new JobExitStatus(""DOWNLOAD_ERRORS"");
    public static final JobExitStatus CONFIG_VALIDATION_FAIL = new JobExitStatus(""CONFIG_VALIDATION_FAIL"");
    public static final JobExitStatus MOVEFILES_WORKAREA_ERRORS = new JobExitStatus(""MOVEFILES_WORKAREA_ERRORS"");
    public static final JobExitStatus EXECUTING = new JobExitStatus(""EXECUTING"");
    public static final JobExitStatus DB_NOT_ACCESSABLE = new JobExitStatus(""DB_NOT_ACCESSABLE"");
    public static final JobExitStatus ANOTHER_FETCHER_IS_RUNNING = new JobExitStatus(""ANOTHER_FETCHER_IS_RUNNING"");
    public static final JobExitStatus RUNFAILED = new JobExitStatus(""RUNFAILED"");
    public static final JobExitStatus MULTIPLE_PARTIAL_ERRORS = new JobExitStatus(""MULTIPLE_PARTIAL_ERRORS"");
    public static final JobExitStatus MOVEFILES_DESTINATION_ERRORS = new JobExitStatus(""MOVEFILES_DESTINATION_ERRORS"");
    public static final JobExitStatus NO_NEW_FILES_FOUND = new JobExitStatus(""NO_NEW_FILES_FOUND"");
    public static final JobExitStatus WORK_AREA_NOT_ACCESSABLE = new JobExitStatus(""WORK_AREA_NOT_ACCESSABLE"");
    public static final JobExitStatus PROCESS_VALIDATION_FAIL = new JobExitStatus(""PROCESS_VALIDATION_FAIL"");
    public static final JobExitStatus DESTINATION_NOT_ACCESSABLE = new JobExitStatus(""DESTINATION_NOT_ACCESSABLE"");
    public static final JobExitStatus UNKNOWN = new JobExitStatus(""UNKNOWN"");
    public static final JobExitStatus DELAYERING_ERRORS = new JobExitStatus(""DELAYERING_ERRORS"");
    public static final JobExitStatus NO_FILES_FOUND = new JobExitStatus(""NO_FILES_FOUND"");
    public static final JobExitStatus SOURCE_NOT_ACCESSABLE = new JobExitStatus(""SOURCE_NOT_ACCESSABLE"");
    public static final JobExitStatus COMPLETED = new JobExitStatus(""COMPLETED"");
    private static final List<JobExitStatus> partialFailureCodes =
        List.of(CAPTURE_SOURCE_METADATA_ERRORS, SOURCE_DELETION_ERRORS, DOWNLOAD_ERRORS,
            CONFIG_VALIDATION_FAIL, MOVEFILES_WORKAREA_ERRORS, MOVEFILES_DESTINATION_ERRORS,
            WORK_AREA_NOT_ACCESSABLE, PROCESS_VALIDATION_FAIL, DESTINATION_NOT_ACCESSABLE,
            DELAYERING_ERRORS);

    private final String thisExitStatus;
    private final List<JobExitStatus> partialExitCodes;

    public JobExitStatus(String thisExitStatus) {
        this(thisExitStatus, List.of());
    }

    public JobExitStatus(String thisExitStatus, List<JobExitStatus> partialExitCodes) {
        this.thisExitStatus = thisExitStatus;
        this.partialExitCodes = partialExitCodes;
    }

    public ExitStatus getExitStatus() {
        return ExitStatus.valueOf(thisExitStatus.toUpperCase());
    }

    public List<JobExitStatus> getPartialFailureCodes() {
        return partialExitCodes;
    }

    public boolean isPartialFailureCode() {
        return partialFailureCodes.contains(this);
    }

    @Override
    public String toString() {
        return thisExitStatus;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        JobExitStatus that = (JobExitStatus) o;

        if (!thisExitStatus.equals(that.thisExitStatus)) {
            return false;
        }
        return partialExitCodes.equals(that.partialExitCodes);
    }

    @Override
    public int hashCode() {
        int result = thisExitStatus.hashCode();
        result = 31 * result + partialExitCodes.hashCode();
        return result;
    }

    public String getExitDescription() {
        return thisExitStatus;
    }
}"
25,"import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.geom.Rectangle2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListCellRenderer;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JEditorPane;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ListCellRenderer;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.StyleSheet;
import javax.swing.text.html.HTMLDocument.HTMLReader.TagAction;
import javax.swing.text.html.ObjectView;

import org.apache.commons.io.FileUtils;
import org.knopflerfish.eclipse.core.SwingWorker;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.BundleListener;
import org.osgi.framework.FrameworkEvent;
import org.osgi.framework.FrameworkListener;
import org.osgi.framework.ServiceEvent;
import org.osgi.framework.ServiceListener;
import org.osgi.framework.ServiceReference;
import org.osgi.framework.ServiceRegistration;
import org.osgi.service.component.ComponentContext;
import org.osgi.util.tracker.ServiceTracker;

import com.ardor3d.util.GameTaskQueueManager;
import com.ardor3d.util.GarbageCollector.HeapDump;
import com.jettison.json.JSONArray;
import com.jettison.json.JSONException;
import com.jettison.json.JSONObject;
import com.yeelight.sdk.YeelightClient;
import com.yeelight.sdk.YeelightDevice;
import com.yeelight.sdk. YeelightDeviceEvent;

import uk.co.caprica.vlcj.component.EmbeddedMediaListPlayerComponent;
import uk.co.caprica.vlcj.component.EmbeddedMediaPlayerComponent;
import uk.co.caprica.vlcj.player.media.Media;
import uk.co.caprica.vlcj.player.media.MediaRef;
import uk.co.caprica.vlcj.player.MediaPlayer;
import uk.co.caprica.vlcj.player.MediaPlayerEventAdapter;
import uk.co.caprica.vlcj.player.MediaPlayerFactory;
import uk.co.caprica.vlcj.player.embedded.EmbeddedMediaPlayer;"
26,"import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableList.Builder;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.google.inject.name.Named;
import java.security.Key;
import java.util.List;
import org.joda.time.DateTime;
import org.joda.time.Duration;
import org.opensaml.core.xml.AbstractXMLObjectBuilder;
import org.opensaml.core.xml.XMLObject;
import org.opensaml.core.xml.XMLObjectBuilder;
import org.opensaml.core.xml.config.XMLObjectProviderRegistrySupport;
import org.opensaml.saml.common.SAMLObjectBuilder;
import org.opensaml.saml.saml2.core.AttributeStatement;
import org.opensaml.saml.saml2.core.AuthnRequest;
import org.opensaml.saml.saml2.core.Conditions;
import org.opensaml.saml.saml2.core.Issuer;
import org.opensaml.saml.saml2.core.NameID;
import org.opensaml.saml.saml2.core.NameIDType;
import org.opensaml.saml.saml2.core.RequestAbstractType;
import org.opensaml.saml.saml2.core.Response;
import org.opensaml.saml.saml2.core.Status;
import org.opensaml.saml.saml2.core.StatusCode;
import org.opensaml.saml.saml2.core.StatusMessage;
import org.opensaml.saml.saml2.core.Subject;
import org.opensaml.saml.saml2.core.SubjectConfirmation;
import org.opensaml.saml.saml2.core.SubjectConfirmationData;
import org.opensaml.saml.saml2.core.impl.AttributeStatementBuilder;
import org.opensaml.saml.saml2.core.impl.AuthnRequestBuilder;
import org.opensaml.saml.saml2.core.impl.ConditionsBuilder;
import org.opensaml.saml.saml2.core.impl.IssuerBuilder;
import org.opensaml.saml.saml2.core.impl.NameIDBuilder;
import org.opensaml.saml.saml2.core.impl.ResponseBuilder;
import org.opensaml.saml.saml2.core.impl.StatusBuilder;
import org.opensaml.saml.saml2.core.impl.StatusCodeBuilder;
import org.opensaml.saml.saml2.core.impl.StatusMessageBuilder;
import org.opensaml.saml.saml2.core.impl.SubjectBuilder;
import org.opensaml.saml.saml2.core.impl.SubjectConfirmationBuilder;
import org.opensaml.saml.saml2.core.impl.SubjectConfirmationDataBuilder;
import org.opensaml.xmlsec.signature.Signature;
import org.opensaml.xmlsec.signature.impl.SignatureBuilder;

public class SamlTokenProvider implements TokenProvider {

  private static final Duration AUTHN_REQUEST_VALIDITY = Duration.standardDays(1);
  private static final String SAML2_PROTOCOL_URN = ""urn:oasis:names:tc:SAML:2.0:protocol"";
  private static final String LONE_SAML_ISSUER_VALUE = ""LOCAL_SAML_ISSUER"";

  private final SamlAssertionWrapper samlAssertionWrapper;
  private final SubjectProvider subjectProvider;
  private final ConditionsProvider conditionsProvider;
  private final List<AttributeStatementProvider> attributeStatementProviders;
  private final Logger log;
  private final boolean signToken;

  @Inject
  public SamlTokenProvider(
      SamlAssertionWrapper samlAssertionWrapper,
      @Named(""subjectProvider"") SubjectProvider subjectProvider,
      @Named(""conditionsProvider"") ConditionsProvider conditionsProvider,
      @Named(""attributeStatementProviders"") List<AttributeStatementProvider> attributeStatementProviders,
      Logger log,
      @Named(""signToken"") boolean signToken) {
    this.samlAssertionWrapper = Preconditions.checkNotNull(samlAssertionWrapper);
    this.subjectProvider = Preconditions.checkNotNull(subjectProvider);
    this.conditionsProvider = Preconditions.checkNotNull(conditionsProvider);
    this.attributeStatementProviders =
        Preconditions.checkNotNull(attributeStatementProviders);
    this.log = Preconditions.checkNotNull(log);
    this.signToken = signToken;
  }

  @Override
  public boolean canHandleToken(TokenCallback callback) {
    return callback instanceof SamlCallbackHandler;
  }

  @Override
  public TokenProviderResponse createToken(TokenCallback callback) throws CallbackHandlingException {
    SamlCallbackHandler handler = (SamlCallbackHandler) callback;

    NameID nameId =
        new NameIDBuilder()
            .setName(subjectProvider.getId())
            .setFormat(NameIDType.TRANSIENT)
            .setSPNameQualifier(handler.issuer())
            .buildObject();

    Subject subject =
        new SubjectBuilder()
            .setNameID(nameId)
            .addSubjectConfirmation(generateConfirmation(handler.getClientAddress()))
            .buildObject();

    Response.Builder responseBuilder = buildResponse(handler.issuer());
    responseBuilder.setSubject(subject);
    responseBuilder.setConditions(conditionsProvider.getConditions());

    XMLObjectBuilder<?> issuerBuilder =
        XMLObjectProviderRegistrySupport.getBuilderFactory().getBuilder(Issuer.DEFAULT_ELEMENT_NAME);
    Issuer issuer =
        ((IssuerBuilder) issuerBuilder).buildObject(Issuer.DEFAULT_ELEMENT_NAME, Issuer.TYPE_NAME);
    issuer.setValue(LONE_SAML_ISSUER_VALUE);
    responseBuilder.setIssuer(issuer);

    List<Assertion> assertions =
        ImmutableList.<Assertion>builder()
            .add(
                samlAssertionWrapper.createAssertion(
                    samlAssertionWrapper.createSamlObject(nameId, subject), createAttributeStatements()))
            .addAll(samlAssertionWrapper.provideAdditionalAssertions())
            .build();

    for (Assertion a : assertions) {
      responseBuilder.getAssertions().add(a);
    }

    Response response = responseBuilder.buildObject();
    if (signToken) {
      signSamlToken(response, handler.getSigningKey());
      log.info(""Signed response "" + response.getID());
    }

    return new TokenProviderResponse(response.toString(), ""SAMLResponse"", null, samlAssertionWrapper.getAuthnContext());
  }

  private List<AttributeStatement> createAttributeStatements() {
    Builder<AttributeStatement> statements = ImmutableList.builder();
    if (subjectProvider.getAttributes() != null) {
      AttributeStatement statement =
          new AttributeStatementBuilder()
              .addAttributeStatements(subjectProvider.getAttributes())
              .buildObject();
      statements.add(statement);
    }
    for (AttributeStatementProvider provider : attributeStatementProviders) {
      statements.addAll(provider.getAttributeStatements());
    }
    return statements.build();
  }

  private SubjectConfirmation generateConfirmation(String clientAddress) {
    SubjectConfirmation.Builder confirmation = new SubjectConfirmationBuilder();
    SubjectConfirmationData data = new SubjectConfirmationDataBuilder().buildObject();
    data.setInResponseTo(samlAssertionWrapper.getRequestId());
    data.setAddress(clientAddress);
    data.setNotOnOrAfter(new DateTime().plus(AUTHN_REQUEST_VALIDITY));
    confirmation.setMethod(SubjectConfirmation.METHOD_BEARER);
    confirmation.setSubjectConfirmationData(data);
    return confirmation.buildObject();
  }

  private Response.Builder buildResponse(String issuer) {
    Response.Builder response =
        new ResponseBuilder()
            .setDestination(samlAssertionWrapper.getResponseUrl())
            .setIssuer(Issuer.DEFAULT_ELEMENT_NAME)
            .setStatus(buildStatus())
            .setVersion(samlAssertionWrapper.getSamlVersion());
    if (samlAssertionWrapper.getIssueInstant() != null) {
      response.setIssueInstant(samlAssertionWrapper.getIssueInstant());
    } else {
      response.setIssueInstant(new DateTime());
    }
    response.setID(samlAssertionWrapper.getId());
    response.setInResponseTo(samlAssertionWrapper.getInResponseTo());
    return response;
  }

  private Status buildStatus() {
    StatusBuilder statusBuilder = new StatusBuilder();
    Status status = statusBuilder.buildObject();
    StatusCode statusCode = new StatusCodeBuilder().setValue(StatusCode.SUCCESS).buildObject();
    status.setStatusCode(statusCode);
    return status;
  }

  private void signSamlToken(Response samlObject, Key key) {"
27,"public class AssetManager {
    private static final String LOG = AssetManager.class.getSimpleName();
    private static AssetManager instance;

    private TiledMapManager tiledMapManager;

    private Array<Asset> textures = new Array<>();
    private Array<Asset> sounds = new Array<>();
    private Array<Asset> rpgMaps = new Array<>();
    private Array<Asset> textureRegions = new Array<>();

    private Array<Asset> assetsToLoad = new Array<>();

    private AssetManager() {
    }

    public static AssetManager getInstance() {
        if (instance == null) {
            instance = new AssetManager();
        }
        return instance;
    }

    public void loadAssets() {
        for (Asset asset : assetsToLoad) {
            if (asset.getType().equals(""TextureAtlas"")) {
                loadTextureAtlas(asset.getName());
            } else if (asset.getType().equals(""Texture"")) {
                loadTextures(asset.getName());
            } else if (asset.getType().equals(""TiledMap"")) {
                loadMaps(asset.getName());
            } else if (asset.getType().equals(""Sound"")) {
                loadSounds(asset.getName());
            }
        }
    }

    public void loadTextureAtlas(String assetName) {
        Asset atlasAsset = new Asset(""TextureAtlas"", assetName);
        if (textures.contains(atlasAsset, true)) {
            return;
        }
        textures.add(atlasAsset);
        Atlas atlas = new Atlas(Gdx.files.internal(assetName + "".atlas""), Texture.TextureFilter.Nearest, true);
        TextureAtlas textureAtlas = new TextureAtlas(atlas);
        assetManager.load(assetName + "".atlas"", TextureAtlas.class);
        assetManager.finishLoadingAsset(assetName + "".atlas"");
        textures.add(new Asset(""TextureAtlas"", assetName + "".atlas"", textureAtlas));
    }

    public void loadTextures(String assetName) {
        Asset textureAsset = new Asset(""Texture"", assetName);
        if (textures.contains(textureAsset, true)) {
            return;
        }
        textures.add(new Asset(""Texture"", assetName));
        assetManager.load(assetName, Texture.class);
        assetManager.finishLoadingAsset(assetName);
    }

    public void loadMaps(String assetName) {
        Asset rpgMapAsset = new Asset(""TiledMap"", assetName);
        if (rpgMaps.contains(rpgMapAsset, true)) {
            return;
        }
        rpgMaps.add(new Asset(""TiledMap"", assetName));
        assetManager.load(assetName, TiledMap.class);
        assetManager.finishLoadingAsset(assetName);
    }

    public void loadSounds(String assetName) {
        Asset soundAsset = new Asset(""Sound"", assetName);
        if (sounds.contains(soundAsset, true)) {
            return;
        }
        sounds.add(new Asset(""Sound"", assetName));
        assetManager.load(assetName, Sound.class);
        assetManager.finishLoadingAsset(assetName);
    }

    public void unloadSounds() {
        for (Asset sound : sounds) {
            sound.getResource(""Sound"").dispose();
        }
        sounds.clear();
    }

    public void dispose() {
        disposeTextures();
        disposeMaps();
        disposeAtlas();
    }

    public void disposeTextures() {
        for (Asset texture : textures) {
            texture.getResource(""Texture"").dispose();
        }
        textures.clear();
    }

    public void disposeMaps() {
        for (Asset rpgMap : rpgMaps) {
            rpgMap.getResource(""TiledMap"").dispose();
        }
        rpgMaps.clear();
    }

    public void disposeAtlas() {
        for (Asset textureAtlas : textures) {
            if (textureAtlas.getType().equals(""TextureAtlas"")) {
                textureAtlas.getResource(""TextureAtlas"").dispose();
            }
        }
        textures.clear();
    }

    public TextureRegion getTextureRegion(String assetName) {
        for (Asset textureRegion : textureRegions) {
            if (textureRegion.getName().equals(assetName)) {
                return textureRegion.getResource(""TextureRegion"");
            }
        }
        return null;
    }

    public TiledMap getTiledMap(String assetName) {
        for (Asset rpgMap : rpgMaps) {
            if (rpgMap.getName().equals(assetName)) {
                return rpgMap.getResource(""TiledMap"");
            }
        }
        return null;
    }

    public Texture getTexture(String assetName) {
        for (Asset texture : textures) {
            if (texture.getName().equals(assetName)) {
                return texture.getResource(""Texture"");
            }
        }
        return null;
    }

    public void setAssetsToLoad(Array<Asset> assetsToLoad) {
        this.assetsToLoad = assetsToLoad;
    }
}"
28,"import com.google.devtools.build.lib.analysis.config.InvalidConfigurationException;
import com.google.devtools.build.lib.runtime.RepositoryManager;
import com.google.devtools.build.lib.runtime.StoredSettings;
import com.google.devtools.build.lib.skyframe.packages.ProjectModel;
import com.google.devtools.build.lib.util.io.TimestampGranularityMonitor;
import com.google.devtools.build.lib.vfs.FileSystemUtils;
import com.google.devtools.build.lib.vfs.Path;
import com.google.devtools.build.skyframe.SkyFunction;
import com.google.devtools.build.skyframe.SkyKey;
import com.google.devtools.build.skyframe.SkyValue;
import java.io.IOException;
import java.util.Map;
import javax.annotation.Nullable;

public class ProjectManager implements SkyFunction {
  private final StoredSettings settings;
  private final RepositoryManager repositoryManager;
  private final FileBasedConfig projectConfigs;
  private final Logger logger;

  private Map<String, ProjectModel> projectCache;

  public ProjectManager(
      StoredSettings settings,
      RepositoryManager repositoryManager,
      FileBasedConfig projectConfigs,
      Logger logger) {
    this.settings = settings;
    this.repositoryManager = repositoryManager;
    this.projectConfigs = projectConfigs;
    this.logger = logger;
  }

  @Nullable
  @Override
  public SkyValue compute(SkyKey skyKey, Environment env)
      throws ProjectEvaluationException, InvalidConfigurationException, InterruptedException {
    String projectId = (String) skyKey.argument();
    try {
      if (projectCache != null) {
        ProjectModel projectModel = projectCache.get(projectId);
        if (projectModel != null) {
          return projectModel;
        }
      }

      projectConfigs.sync();
      if (!FileSystemUtils.isDirectory(projectConfigs.getProjectDirectory(projectId))) {
        projectCache.put(projectId, null);
        return null;
      }

      Path projectDirectory = projectConfigs.getProjectDirectory(projectId);
      ProjectModel projectModel =
          ProjectModel.builder(projectId, projectDirectory)
              .readOnlyFileSystem(projectConfigs.getFileSystem(projectId))
              .settings(settings)
              .repositoryManager(repositoryManager)
              .logger(logger)
              .build();
      projectCache.put(projectId, projectModel);
      return projectModel;
    } catch (IOException e) {
      throw new ProjectEvaluationException(e);
    }
  }

  @Nullable
  @Override
  public String extractTag(SkyKey skyKey) {
    return null;
  }

  public void start(
      Map<String, ProjectModel> projectCache,
      ObjectCache<String> projectMarkdownCache,
      ObjectCache<String> projectRepositoriesMarkdownCache) {
    this.projectCache = projectCache;

    // RepositoryManager and BuildtoolRuntimeProvider assume default project config on startup, get it
    // here.
    try {
      getProjectConfigs();
    } catch (IOException e) {
      throw new RuntimeException(""Error getting project configs on startup"", e);
    }

    projectConfigs.addReloadListener(
        () -> {
          // NOTE: This only reloads the main project config. Unloading/reloading projects is handled
          // lazily over the lifetime of the build by the ProjectConfigTarget to avoid leaking the
          // configuration cache, and invalidating any caching/memoization that uses ProjectConfigs or
          // ProjectModel.
          projectMarkdownCache.invalidateAll();
          projectRepositoriesMarkdownCache.invalidateAll();
          reloadProjectMarkdown();
        });
    FileSystemUtils.addContentChangedListener(projectConfigs.getProductPathForLogging(), projectCache);
    TimestampGranularityMonitor.INSTANCE.addChangeListener(projectCache);
  }

  public Map<String, ProjectModel> getProjectConfigs() throws IOException {
    return projectConfigs.readProjectConfigs();
  }

  public List<ProjectModel> getProjectModels() {
    if (projectCache == null) {
      return ImmutableList.of();
    }
    return ImmutableList.copyOf(projectCache.values());
  }

  public void reloadProjectMarkdown() {
    if (projectCache != null) {
      for (ProjectModel projectModel : projectCache.values()) {
        projectModel.getMarkdownCache().invalidate();
        projectModel.getRepositoryMarkdownCache().invalidate();
      }
    }
  }

  public void stop() {}
}"
29,"import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Color {

    private final int r;
    private final int g;
    private final int b;
    private final Map<RGB, String> namedColors;

    public Color(int r, int g, int b, Map<RGB, String> namedColors) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.namedColors = namedColors;
    }

    public static Color of(int r, int g, int b) {
        return new Color(r, g, b, new HashMap<>());
    }

    public static Color of(int r, int g, int b, Map<RGB, String> namedColors) {
        return new Color(r, g, b, namedColors);
    }

    public int getR() {
        return r;
    }

    public int getG() {
        return g;
    }

    public int getB() {
        return b;
    }

    public Optional<String> getNamedColor() {
        return Optional.ofNullable(namedColors.get(new RGB(r, g, b)));
    }

    public Optional<String> getNamedColor(double maxDist) {
        return namedColors.entrySet().stream()
                .filter(entry -> calculateColorDistSq(r, g, b, entry.getKey().getR(), entry.getKey().getG(), entry.getKey().getB()) < maxDist * maxDist)
                .max(Map.Entry.comparingByValue(Function.identity()))
                .map(Map.Entry::getValue);
    }

    public double calculateColorDistSq(int r1, int g1, int b1, int r2, int g2, int b2) {
        return (r1 - r2) * (r1 - r2) + (g1 - g2) * (g1 - g2) + (b1 - b2) * (b1 - b2);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Color color = (Color) o;
        return r == color.r &&
                g == color.g &&
                b == color.b;
    }

    @Override
    public int hashCode() {
        return r * 10000 + g * 100 + b;
    }

    public static class RGB {

        private final int r;
        private final int g;
        private final int b;

        public RGB(int r, int g, int b) {
            this.r = r;
            this.g = g;
            this.b = b;
        }

        public int getR() {
            return r;
        }

        public int getG() {
            return g;
        }

        public int getB() {
            return b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            RGB rgb = (RGB) o;
            return r == rgb.r &&
                    g == rgb.g &&
                    b == rgb.b;
        }

        @Override
        public int hashCode() {
            return r * 10000 + g * 100 + b;
        }
    }
}"
30,"import java.util.logging.Logger;

public class BigQuerySourceConfiguration implements Cloneable {

  private static final Logger LOG = Logger.getLogger(BigQuerySourceConfiguration.class.getName());

  private static String getSuffixFromType(String type) {
    switch (type) {
      case ""STRING"":
      case ""BYTES"":
      case ""BOOLEAN"":
      case ""FLOAT"":
      case ""DOUBLE"":
      case ""GEOGRAPHY"":
      case ""NUMERIC"":
      case ""DATETIME"":
      case ""DATE"":
      case ""TIME"":
      case ""TIMESTAMP"":
      case ""INTEGER"":
      case ""BIGINT"":
        return ""beam-bq-row.avro"";
      case ""ARRAY"":
      case ""STRUCT"":
      case ""UNION"":
      case ""RECORD"":
      case ""ENUM"":
        return ""beam-bq-row_proto.avro"";
      default:
        throw new IllegalArgumentException(
            String.format(""Unrecognized BigQuery type: %s"", type));
    }
  }

  private final String CLASS_NAME = this.getClass().getName();

  private String name;
  private String schema;
  private String type;
  private String revision;

  public BigQuerySourceConfiguration() {
    // For Jackson
  }

  public BigQuerySourceConfiguration(
      String name, String schema, String type, String revision) {
    setName(name);
    setSchema(schema);
    setType(type);
    setRevision(revision);
  }

  @Override
  public BigQuerySourceConfiguration clone() {
    try {
      return (BigQuerySourceConfiguration) super.clone();
    } catch (CloneNotSupportedException e) {
      throw new RuntimeException(""Failed to Clone BigQuerySourceConfiguration"", e);
    }
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String getSchema() {
    return schema;
  }

  public void setSchema(String schema) {
    this.schema = schema;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  @Override
  public String toString() {
    return String.format(
        ""%s(name=%s, schema=%s, type=%s, revision=%s)"",
        CLASS_NAME, name, schema, type, revision);
  }

  public void setRevision(String revision) {
    this.revision = revision;
  }

  public String getRevision() {
    return revision;
  }
}"
31,"import com.google.common.base.Objects;
import org.darkcoinj.core.*;

import java.math.BigInteger;
import java.util.*;

/**
 * Network parameters used by the dashj library.
 */
public class DashNetParams extends NetworkParameters {
    public static final int ALERT_HEADER = 0xe9b6c11d; // 0xe9b6c11d == BIP0005 ""alert"" headerbits
    public static final int ADDRESS_HEADER = 76; // starts with 'X'
    public static final int P2SH_HEADER = 16; // starts with '7'
    public static final int DUMPED_PRIVATE_KEY_HEADER = 128; // starts with 'P'
    public static final int INTERVAL = 10 * 60; // 10 minutes
    public static final int TARGET_TIMESPAN = 3 * 7 * 24 * 60 * 60; // 3.5 days
    public static final int TARGET_SPACING = 150; // 2.5 minutes
    public static final long MAX_MONEY = 20000000 * Coin.CENT; // 20 million wealth
    public static final int RETARGET_BLOCK_COUNT = 100;
    public static final int DIP0001_WINDOW_SIZE = 100;
    public static final int DIP0001_SWITCH_HEIGHT = 214500;
    public static final int SPENDABLE_COINBASE_DEPTH = 100;
    private static DashNetParams regTestParams;
    private static DashNetParams prodNetParams;
    private static DashNetParams testNet3Params;
    private static DashNetParams testNet2Params;
    private static DashNetParams unitTests;

    public static synchronized NetworkParameters getParametersFromAddressByte(int addressByte) {
        switch (addressByte) {
            case ADDRESS_HEADER:
                return prodNetParams;
            case 76:
                return prodNetParams; // what the hell is 76?
            case 196:
                return testNet3Params;
            case 0x6f: // testnet prefix 'o'
                return testNet2Params;
            default:
                throw new RuntimeException(""Invalid address byte "" + addressByte);
        }
    }

    public static synchronized NetworkParameters getUnitTest() {
        if (unitTests == null) {
            unitTests = new DashNetParams(UnitTestParams.get());
        }
        return unitTests;
    }

    public static synchronized NetworkParameters getRegTest() {
        if (regTestParams == null) {
            regTestParams = new DashNetParams(RegTestParams.get());
        }
        return regTestParams;
    }

    public static synchronized NetworkParameters getTestNet2() {
        if (testNet2Params == null) {
            testNet2Params = new DashNetParams(TestNet2Params.get());
        }
        return testNet2Params;
    }

    public static synchronized NetworkParameters getTestNet3() {
        if (testNet3Params == null) {
            testNet3Params = new DashNetParams(TestNet3Params.get());
        }
        return testNet3Params;
    }

    public static synchronized NetworkParameters getProdNet() {
        if (prodNetParams == null) {
            prodNetParams = new DashNetParams(ProdNetParams.get());
        }
        return prodNetParams;
    }

    private DashNetParams() {
        super();
    }

    public DashNetParams(NetworkParameters copiedParams) {
        super(copiedParams);
        paramsSet.clear(); // Dash does not support multi-signature transactions
    }

    final static Map<Integer, Sha256Hash> checkpoints = new HashMap<Integer, Sha256Hash>();

    static {
        checkpoints.put(0, Sha256Hash.wrap(""0000093926437d74b1b497007f32a93ebf568384d39883f0dba8e94dca489d43""));
        checkpoints.put(2100, Sha256Hash.wrap(""000000029e2c98221250727b88b969a5dba9012510668f0a4f1e4de94b98988c""));
        checkpoints.put(20900, Sha256Hash.wrap(""000000006800fe2a9190e32f80c99841ae65d371ccadeb97a0de23de4f4633ad""));
        checkpoints.put(25000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(50000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(75000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(100000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(125000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(150000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(175000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(200000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(225000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(250000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints.put(275000, Sha256Hash.wrap(""000000005364f7845b7111da8f39b2b8a59d172ae99a28b52925992ab5dbc2c8""));
        checkpoints."
32,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

import redis.clients.jedis.Jedis;

public class Indexer {

    private Jedis jedis;
    private String urlSetKey = ""urlSet"";
    private String termCounterKey = ""termCounter"";

    public Indexer() {
        // connect to redis server on localhost
        jedis = new Jedis(""localhost"");
    }

    public void indexPage(String url, String content) {
        // add the url to the urlset
        jedis.sadd(urlSetKey, url);

        // parse the content and get the terms
        Set<String> terms = getTerms(content);

        // for each term, increment the count in the term counter
        for (String term : terms) {
            jedis.hincrBy(termCounterKey, term, 1);
        }
    }

    public void deleteURLSets() {
        jedis.del(urlSetKey);
    }

    public void deleteTermCounters() {
        jedis.del(termCounterKey);
    }

    public Set<String> getURLs() {
        return jedis.smembers(urlSetKey);
    }

    public Map<String, Integer> getCounts() {
        Map<String, Integer> counts = new HashMap<>();
        for (Entry<String, String> entry : jedis.hgetAll(termCounterKey).entrySet()) {
            counts.put(entry.getKey(), Integer.parseInt(entry.getValue()));
        }
        return counts;
    }

    public Map<String, Integer> getCountsFaster() {
        // Get the keys for the term counters
        Set<String> termCounterKeys = jedis.hkeys(termCounterKey);

        // Create a map to store the counts
        Map<String, Integer> counts = new HashMap<>();

        // Get the counts for each term counter
        for (String termCounterKey : termCounterKeys) {
            counts.put(termCounterKey, Integer.parseInt(jedis.hget(termCounterKey, ""count"")));
        }

        return counts;
    }

    public void loadIndex() {
        try {
            // open the index file
            BufferedReader reader = new BufferedReader(new FileReader(new File(""index.txt"")));

            // read the urls and terms from the file
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("" "");
                String url = parts[0];
                String term = parts[1];

                // add the url to the urlset
                jedis.sadd(urlSetKey, url);

                // increment the count for the term
                jedis.hincrBy(termCounterKey, term, 1);
            }

            // close the file
            reader.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public boolean isIndexed(String url) {
        return jedis.sismember(urlSetKey, url);
    }

    public void deleteAllKeys() {
        jedis.flushAll();
    }

    public static void main(String[] args) {
        // create an indexer instance
        Indexer indexer = new Indexer();

        // add some pages to the index
        indexer.indexPage(""http://www.example.com"", ""this is a test page"");
        indexer.indexPage(""http://www.example.com/about"", ""this is the about page"");
        indexer.indexPage(""http://www.example.com/blog"", ""this is the blog page"");

        // print the index
        indexer.printIndex();

        // delete the index
        indexer.deleteAllKeys();
    }

    public void printIndex() {
        // get the urls and terms from the index
        Set<String> urls = getURLs();
        Map<String, Integer> counts = getCounts();

        // print the urls and terms
        for (String url : urls) {
            System.out.println(url);
            for (Entry<String, Integer> entry : counts.entrySet()) {
                if (jedis.sismember(url, entry.getKey())) {
                    System.out.println(""\t"" + entry.getKey() + "" ("" + entry.getValue() + "")"");
                }
            }
        }
    }

    private Set<String> getTerms(String content) {
        // split the content into words
        String[] words = content.split("" "");

        // create a set to store the terms
        Set<String> terms = new TreeSet<>();

        // add the words to the set
        for (String word : words) {
            terms.add(word.toLowerCase());
        }

        // return the set of terms
        return terms;
    }

}"
33,"import com.google.common.collect.Sets;

import java.util.List;
import java.util.Set;

public class BlockMetadataManagerView {

  private final StorageDir mDir;
  private final long mBlocksToMoveOutSize = 0;
  private final long mBlocksToMoveInSize = 0;
  private final StorageTierView mTierView;
  private final Set<Long> mBlocksToMoveIn = Sets.newConcurrentHashSet();
  private final Set<Long> mBlocksToMoveOut = Sets.newConcurrentHashSet();

  public long getEvitableBytes() {
    return 0;
  }

  public StorageTierView getParentTierView() {
    return null;
  }

  public boolean isMarkedToMoveOut(long blockId) {
    return mBlocksToMoveOut.contains(blockId);
  }

  public void markBlockMoveIn(long blockId, TempBlockMeta tempBlockMeta) {
    mBlocksToMoveIn.add(blockId);
    mBlocksToMoveOut.remove(blockId);
    mTierView.addBlockMeta(blockId, tempBlockMeta);
  }

  public TempBlockMeta createTempBlockMeta(int dirViewIndex) {
    return null;
  }

  public int getDirViewIndex() {
    return 0;
  }

  public long getCommittedBytes() {
    return 0;
  }

  public List<BlockMeta> getEvictableBlocks() {
    return null;
  }

  public long getCapacityBytes() {
    return 0;
  }

  public long getAvailableBytes() {
    return 0;
  }

  public BlockStoreLocation toBlockStoreLocation() {
    return null;
  }

  public void markBlockMoveOut(long blockId) {
    mBlocksToMoveOut.add(blockId);
    mBlocksToMoveIn.remove(blockId);
    mTierView.removeBlockMeta(blockId);
  }
}"
34,"import java.util.List;

public interface OAuthAuthorization {

    void setScopes(List<OAuthPermission> scopes);

    void setPreAuthorized(boolean preAuthorized);

    void setSubject(UserSubject subject);

    String getTokenKey();

    boolean isPreAuthorized();

    long getLifetime();

    Client getClient();

    long getIssuedAt();

    String getTokenSecret();

    List<OAuthPermission> getScopes();
}"
35,"public final class Repeater {

    private static final int RPT_STR = 1 << 0;
    private static final int RPT_CHAR = 1 << 1;
    private static final int RPT_BYTE = 1 << 2;
    private static final int RPT_INT = 1 << 3;

    private static final char CHAR_EOF = 0x2000;

    private final int bitVec;
    private final char type;
    private int repeatCount;
    private int charByte;

    public Repeater(int bitVec, char type, int repeatCount, int charByte) {
        this.bitVec = bitVec;
        this.type = type;
        this.repeatCount = repeatCount;
        this.charByte = charByte;
    }

    public int getFormatRepeatCount() {
        if ((bitVec & RPT_STR) != 0 || (bitVec & RPT_CHAR) != 0) {
            return repeatCount;
        }
        return (type == 'x') ? 1 : 0;
    }

}"
36,"import java.util.Date;

public class DataValidationDetails {

    private Long expectedDataUnitId;
    private Long seqNo;
    private Long dataSetId;
    private Long dataUnitId;
    private String expectedValue;
    private String actualValue;
    private Long expectedDataSetId;
    private String errorCode;
    private Long testId;
    private String failedAttributeName;
    private Date errorTime;
    private String srcFileName;
    private String errorMsg;

    public Long getExpectedDataUnitId() {
        return expectedDataUnitId;
    }

    public void setExpectedDataUnitId(Long expectedDataUnitId) {
        this.expectedDataUnitId = expectedDataUnitId;
    }

    public Long getSeqNo() {
        return seqNo;
    }

    public void setSeqNo(Long seqNo) {
        this.seqNo = seqNo;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }

    public Long getDataUnitId() {
        return dataUnitId;
    }

    public void setDataUnitId(Long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }

    public String getExpectedValue() {
        return expectedValue;
    }

    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }

    public String getActualValue() {
        return actualValue;
    }

    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }

    public Long getExpectedDataSetId() {
        return expectedDataSetId;
    }

    public void setExpectedDataSetId(Long expectedDataSetId) {
        this.expectedDataSetId = expectedDataSetId;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public Long getTestId() {
        return testId;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public String getFailedAttributeName() {
        return failedAttributeName;
    }

    public void setFailedAttributeName(String failedAttributeName) {
        this.failedAttributeName = failedAttributeName;
    }

    public Date getErrorTime() {
        return errorTime;
    }

    public void setErrorTime(Date errorTime) {
        this.errorTime = errorTime;
    }

    public String getSrcFileName() {
        return srcFileName;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    @Override
    public String toString() {
        return ""DataValidationDetails{"" +
                ""expectedDataUnitId="" + expectedDataUnitId +
                "", seqNo="" + seqNo +
                "", dataSetId="" + dataSetId +
                "", dataUnitId="" + dataUnitId +
                "", expectedValue='"" + expectedValue + '\' +
                "", actualValue='"" + actualValue + '\' +
                "", expectedDataSetId="" + expectedDataSetId +
                "", errorCode='"" + errorCode + '\' +
                "", testId="" + testId +
                "", failedAttributeName='"" + failedAttributeName + '\' +
                "", errorTime="" + errorTime +
                "", srcFileName='"" + srcFileName + '\' +
                "", errorMsg='"" + errorMsg + '\' +
                '}';
    }
}"
37,"import java.util.HashMap;
import java.util.Iterator;

public class SymbolSet {

    private HashMap<String, Symbol> _all;

    public SymbolSet() {
        _all = new HashMap<String, Symbol>();
    }

    public boolean add(String sym) {
        Symbol s = new Symbol(sym);
        if (_all.containsKey(sym)) {
            return false;
        }
        _all.put(sym, s);
        return true;
    }

    public Iterator<Symbol> iterator() {
        return _all.values().iterator();
    }

    public int size() {
        return _all.size();
    }

    public void not_null() {
        for (Symbol s : _all.values()) {
            if (s.isNull()) {
                throw new IllegalArgumentException(""SymbolSet contains null symbol"");
            }
        }
    }

    public int hashCode() {
        int hc = 0;
        for (Symbol s : _all.values()) {
            hc += s.hashCode();
        }
        return hc;
    }

    public boolean is_superset_of(SymbolSet other) {
        for (Symbol s : other._all.values()) {
            if (!_all.containsKey(s.getText())) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object other) {
        if (!(other instanceof SymbolSet)) {
            return false;
        }
        SymbolSet otherSet = (SymbolSet) other;
        return is_superset_of(otherSet) && otherSet.is_superset_of(this);
    }

    public boolean equals(SymbolSet other) {
        return is_superset_of(other) && other.is_superset_of(this);
    }

    public boolean is_subset_of(SymbolSet other) {
        return other.is_superset_of(this);
    }

    public String toString() {
        return _all.toString();
    }

    public void remove(String sym) {
        _all.remove(sym);
    }

    public void remove(Symbol sym) {
        _all.remove(sym.getText());
    }

    public static class Symbol {

        private String _text;

        public Symbol(String text) {
            _text = text;
        }

        public String getText() {
            return _text;
        }

        public boolean isNull() {
            return _text.equals(""$$"");
        }

        public int hashCode() {
            return _text.hashCode();
        }

        public boolean equals(Object other) {
            if (!(other instanceof Symbol)) {
                return false;
            }
            Symbol otherSymbol = (Symbol) other;
            return _text.equals(otherSymbol._text);
        }

        public String toString() {
            return _text;
        }
    }
}"
38,"private static void handleWsRec(Node node, PrintWriter out, boolean stripWhitespace, Map<QName, String> attributes) throws IOException {
    boolean basic = getQName(node).equals(BASIC);
    if (basic) {
        String ws = getWhitespaceString(node, stripWhitespace);
        out.write(ws);
    }

    boolean leadingSep = basic;
    for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
        short nodeType = child.getNodeType();
        switch (nodeType) {
            case Node.TEXT_NODE:
            case Node.CDATA_SECTION_NODE:
                // These blocks are handled in the normalizeWhitespace method
                break;
            case Node.ELEMENT_NODE:
                if (leadingSep) {
                    out.write(SEPARATOR);
                    leadingSep = false;
                }
                handleWsRec(child, out, stripWhitespace, attributes);
                break;
            case Node.COMMENT_NODE:
                break;
            default:
                LOGGER.warning(""Unexpected node type "" + node.getNodeType() + "". Will be ignored."");
        }
    }
    if (basic) {
        // handle trailing whitespace
        String ws = getWhitespaceString(node, stripWhitespace);
        if (ws.length() > 0) {
            if (!leadingSep) {
                out.write(SEPARATOR);
            }
            out.write(ws);
        }
    }
}"
39,"import javax.xml.bind.MarshalledObject;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.adapters.XmlAdapter;

public class MarshalRegistry implements java.io.Serializable {
    private Map<Object, String> instances = Collections.<Object, String>emptyMap();
    private Map<String, Object> notMarshalled = Collections.<String, Object>emptyMap();
    private static int nextId = 0;

    public MarshalRegistry() {
    }

    public MarshalledObject create(Object object, MarshalRegistry.Context context, Marshaller marshaller) throws Exception {
        String id = getInstanceId(object, context);
        if (id == null) {
            id = ""object_"" + nextId++;
            instances = new HashMap<>(instances);
            instances.put(object, id);
        }
        return marshaller.getXMLAdapter(MarshalledObject.class).marshal(id);
    }

    public Object unmarshal(MarshalledObject objectObj, MarshalRegistry.Context context, Unmarshaller unmarshaller) throws Exception {
        Object original = null;
        String id = objectObj.get();
        if (id != null) {
            original = instances.get(id);
            if (original == null) {
                original = notMarshalled.get(id);
                if (original == null) {
                    // Not referenced previously
                    // most likely the target object will be annotated with @XmlAnyElement
                    Object r = unmarshaller.unmarshal(objectObj.getReader(), Object.class);
                    addNotMarshalled(id, r);
                    original = r;
                }
            }
        }
        if (original == null) {
            original = unmarshaller.unmarshal(objectObj.getReader());
        }
        return original;
    }

    public String getInstanceId(Object object, MarshalRegistry.Context context) {
        for (Iterator<Object> iter = iterator(context); iter.hasNext();) {
            Object other = iter.next();
            if (object == other) {
                return instances.get(other);
            }
        }
        return null;
    }

    public Iterator<Object> iterator(MarshalRegistry.Context context) {
        return instances.keySet().iterator();
    }

    public void addNotMarshalled(String id, Object object) {
        notMarshalled = new HashMap<>(notMarshalled);
        notMarshalled.put(id, object);
    }

    public static class Context implements java.io.Serializable {
        private MarshalRegistry registry;

        public Context(MarshalRegistry registry) {
            this.registry = registry;
        }

        public MarshalRegistry getRegistry() {
            return registry;
        }
    }

    public static class Adapter extends XmlAdapter<MarshalledObject, Object> {
        private transient MarshalRegistry registry;

        @Override
        public void setContext(Object context) {
            registry = ((MarshalRegistry.Context) context).getRegistry();
        }

        @Override
        public MarshalledObject marshal(Object object) throws Exception {
            return registry.create(object, (MarshalRegistry.Context) getContext(), (Marshaller) ((XMLAdapter.UnmarshallingBinder) getContext()).getUnmarshaller().getUnmarshaller());
        }

        @Override
        public Object unmarshal(MarshalledObject object) throws Exception {
            return registry.unmarshal(object, (MarshalRegistry.Context) getContext(), (Unmarshaller) ((XMLAdapter.MarshallingBinder) getContext()).getMarshaller().getMarshaller());
        }
    }
}"
40,"import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import java.util.Optional;
import java.util.stream.Stream;

public class Main {
  public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    List<Integer> newList = Main.nonNullList(list);
    System.out.println(newList);

    List<Integer> list2 = new ArrayList<>();
    list2.add(1);
    list2.add(2);

    List<String> map = Main.map(list2, (Integer i) -> Integer.toString(i));
    System.out.println(map);

    List<Integer> list3 = new ArrayList<>();
    list3.add(1);
    list3.add(2);

    List<Integer> list4 = new ArrayList<>();
    list4.add(1);
    list4.add(2);

    Iterator<Pair<Integer, Integer>> pairs = Main.pairs(list3, list4);
    while (pairs.hasNext()) {
      System.out.println(pairs.next());
    }
  }

  public static <T> List<T> nonNullList(List<T> list) {
    return Optional.ofNullable(list).orElse(new ArrayList<>());
  }

  public static <T, U> List<U> map(List<T> list, Function<T, U> mapper) {
    return list.stream().map(mapper).toList();
  }

  public static <T> Iterator<Pair<T, T>> pairs(List<T> list1, List<T> list2) {
    return Stream.of(list1, list2).flatMap(list -> list.stream()).distinct().sorted().map(e -> Pair.of(e, e)).iterator();
  }
}

class Pair<T> {
  private final T first;
  private final T second;

  public static <T> Pair<T> of(T first, T second) {
    return new Pair<>(first, second);
  }

  public Pair(T first, T second) {
    this.first = first;
    this.second = second;
  }

  public T first() {
    return first;
  }

  public T second() {
    return second;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Pair<?> pair = (Pair<?>) o;
    return first.equals(pair.first) && second.equals(pair.second);
  }

  @Override
  public int hashCode() {
    return Objects.hash(first, second);
  }

  @Override
  public String toString() {
    return ""("" + first + "", "" + second + "")"";
  }
}"
41,"import com.google.cloud.dataplex.v1.MetadataServiceClient;
import com.google.cloud.dataplex.v1.MetaData.ParametersMetaData;
import com.google.cloud.dataplex.v1.MetaData.Template;
import com.google.cloud.dataplex.v1.MetaData.Template.ParameterValue;
import com.google.cloud.dataplex.v1.MetaData.Template.SQLParameter;
import com.google.cloud.dataplex.v1.MetaData.WorkflowImpl;
import com.google.protobuf.FieldMask;
import com.google.protobuf.util.FieldMaskUtil;
import java.io.IOException;

public class UpdateTemplate {

  public static void updateTemplate() throws IOException {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""my-project-id"";
    String location = ""us-central1"";
    String lakeId = ""my-lake-id"";
    String zoneId = ""my-zone-id"";
    String templateId = ""my-template-id"";
    updateTemplate(projectId, location, lakeId, zoneId, templateId);
  }

  // Updates the Template.
  public static void updateTemplate(
      String projectId,
      String location,
      String lakeId,
      String zoneId,
      String templateId)
      throws IOException {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (MetadataServiceClient client = MetadataServiceClient.create()) {
      // Construct the full Template name.
      String templateName =
          String.format(
              ""projects/%s/locations/%s/lakes/%s/zones/%s/templates/%s"",
              projectId, location, lakeId, zoneId, templateId);

      // Construct the Template object to update.
      Template template =
          Template.newBuilder()
              .setName(templateName)
              .setDescription(""Updated Template"")
              .putParameterValues(""param_1"", ParameterValue.newBuilder().setNumberValue(1234).build())
              .putParameterValues(
                  ""param_2"", ParameterValue.newBuilder().setStringValue(""updated-value"").build())
              .putSqlParameters(
                  ""param_3"", SQLParameter.newBuilder().setDefaultValue(""new-default-value"").build())
              .build();

      // Construct the field mask.
      FieldMask fieldMask =
          FieldMaskUtil.fromString(""description,parameter_values,sql_parameters"");

      // Send the update request to the API.
      Template result = client.updateTemplate(template, fieldMask);
      System.out.println(""Template update successful: "" + result.getName());
    }
  }
}"
42,"import java.io.Serializable;

public class About implements Serializable {

    private static final long serialVersionUID = 1L;
    private String aboutName;
    private static final Logger LOG = Logger.getLogger(About.class);

    public String getName() {
        return aboutName;
    }

    public String getInfo() {
        return LOG.getName();
    }

    public boolean enable() {
        return true;
    }

    public boolean disable() {
        return false;
    }
}"
43,"import java.io.StringReader;
import java.util.Iterator;
import javax.xml.namespace.NamespaceContext;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.Characters;
import javax.xml.stream.events.EndElement;
import javax.xml.stream.events.EntityReference;
import javax.xml.stream.events.Namespace;
import javax.xml.stream.events.ProcessingInstruction;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class stax {
    public static void main(String[] args) {
        try {
            String xml = ""<root xmlns=\""http://example.com/root\"">"" + ""  <a xmlns=\""http://example.com/a\"" attribute='value'/>"" + ""  <b xmlns=\""http://example.com/b\"" attribute='value'/>"" + ""</root>"";
            XMLInputFactory factory = XMLInputFactory.newInstance();
            XMLEventReader reader = factory.createXMLEventReader(new StringReader(xml));
            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            NamespaceContext namespaceContext = new NamespaceContext() {
                public String getNamespaceURI(String prefix) {
                    if (""root"".equals(prefix)) {
                        return ""http://example.com/root"";
                    } else if (""a"".equals(prefix)) {
                        return ""http://example.com/a"";
                    } else if (""b"".equals(prefix)) {
                        return ""http://example.com/b"";
                    } else {
                        return null;
                    }
                }

                public String getPrefix(String uri) {
                    return null;
                }

                public Iterator getPrefixes(String namespaceUri) {
                    return null;
                }
            };
            Document document = documentBuilder.newDocument();
            Element rootElement = document.createElementNS(""http://example.com/root"", ""root"");
            document.appendChild(rootElement);
            while (reader.hasNext()) {
                XMLEvent event = reader.nextEvent();
                if (event.isStartElement()) {
                    StartElement startElement = event.asStartElement();
                    Element element = document.createElementNS(startElement.getName().getNamespaceURI(), startElement.getName().getLocalPart());
                    rootElement.appendChild(element);
                    Iterator<Attribute> attributes = startElement.getAttributes();
                    while (attributes.hasNext()) {
                        Attribute attribute = attributes.next();
                        element.setAttributeNS(attribute.getName().getNamespaceURI(), attribute.getName().getLocalPart(), attribute.getValue());
                    }
                } else if (event.isEndElement()) {
                    EndElement endElement = event.asEndElement();
                    String uri = endElement.getName().getNamespaceURI();
                    String localName = endElement.getName().getLocalPart();
                    NodeList childNodes = rootElement.getElementsByTagNameNS(uri, localName);
                    Element element = (Element) childNodes.item(childNodes.getLength() - 1);
                    element.getParentNode().removeChild(element);
                } else if (event.isCharacters()) {
                    Characters characters = event.asCharacters();
                    rootElement.appendChild(document.createTextNode(characters.getData()));
                } else if (event.isProcessingInstruction()) {
                    ProcessingInstruction processingInstruction = event.asProcessingInstruction();
                    rootElement.appendChild(document.createProcessingInstruction(processingInstruction.getTarget(), processingInstruction.getData()));
                } else if (event.isEntityReference()) {
                    EntityReference entityReference = event.asEntityReference();
                    rootElement.appendChild(document.createEntityReference(entityReference.getName()));
                } else if (event.isNamespace()) {
                    Namespace namespace = event.asNamespace();
                    String prefix = namespace.getPrefix();
                    String uri = namespace.getNamespaceURI();
                    rootElement.setAttributeNS(""http://www.w3.org/2000/xmlns/"", (prefix == null) ? ""xmlns"" : ""xmlns:"" + prefix, uri);
                }
            }
            System.out.println(document.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}"
44,"import java.math.BigDecimal;
import java.sql.Timestamp;

public class DataUnitInfo {

    private static final long serialVersionUID = 1L;
    private String isSystemDerived;
    private String isActive;
    private BigDecimal predecessorId;
    private String srcFileName;
    private BigDecimal successorId;
    private BigDecimal feedId;
    private String checksum;
    private String transmissionDatasetId;
    private String comments;
    private String inactivationReasonType;
    private String isFormatValid;
    private long dataUnitId;
    private Timestamp receiptDate;
    private String srcUniqueFileName;
    private Timestamp createdDate;
    private Long dataSetId;
    private BigDecimal fileSize;
    private String destFileName;
    private String loadedInCats;
    private String checksumType;
    private Timestamp modifiedDate;
    private BigDecimal runId;
    private String isPrepopulated;
    private String isBulk;
    private String isUpdate;
    private String receiptDateType;
    private String status;

    public void setIsSystemDerived(String isSystemDerived) {
        this.isSystemDerived = isSystemDerived;
    }

    public void setIsPrepopulated(String isPrepopulated) {
        this.isPrepopulated = isPrepopulated;
    }

    public String getStatus() {
        return status;
    }

    public String getIsUpdate() {
        return isUpdate;
    }

    public long getDataUnitId() {
        return dataUnitId;
    }

    public BigDecimal getFileSize() {
        return fileSize;
    }

    public void setInactivationReasonType(String inactivationReasonType) {
        this.inactivationReasonType = inactivationReasonType;
    }

    public void setDataUnitId(long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }

    public String getComments() {
        return comments;
    }

    public Timestamp getCreatedDate() {
        return createdDate;
    }

    public void setFileSize(BigDecimal fileSize) {
        this.fileSize = fileSize;
    }

    public BigDecimal getPredecessorId() {
        return predecessorId;
    }

    public void setIsUpdate(String isUpdate) {
        this.isUpdate = isUpdate;
    }

    public String getReceiptDateType() {
        return receiptDateType;
    }

    public BigDecimal getFeedId() {
        return feedId;
    }

    public void setReceiptDate(Timestamp receiptDate) {
        this.receiptDate = receiptDate;
    }

    public Timestamp getModifiedDate() {
        return modifiedDate;
    }

    public void setSuccessorId(BigDecimal successorId) {
        this.successorId = successorId;
    }

    public void setDestFileName(String destFileName) {
        this.destFileName = destFileName;
    }

    public void setIsBulk(String isBulk) {
        this.isBulk = isBulk;
    }

    public String getIsFormatValid() {
        return isFormatValid;
    }

    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }

    public void setIsActive(String isActive) {
        this.isActive = isActive;
    }

    public void setChecksumType(String checksumType) {
        this.checksumType = checksumType;
    }

    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }

    public String getInactivationReasonType() {
        return inactivationReasonType;
    }

    public String getSrcUniqueFileName() {
        return srcUniqueFileName;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setReceiptDateType(String receiptDateType) {
        this.receiptDateType = receiptDateType;
    }

    public BigDecimal getRunId() {
        return runId;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public String getChecksumType() {
        return checksumType;
    }

    public String getSrcFileName() {
        return srcFileName;
    }

    public String getChecksum() {
        return checksum;
    }

    public String getDestFileName() {
        return destFileName;
    }

    public Timestamp getReceiptDate() {
        return receiptDate;
    }

    public void setTransmissionDatasetId(String transmissionDatasetId) {
        this.transmissionDatasetId = transmissionDatasetId;
    }

    public String getTransmissionDatasetId() {
        return transmissionDatasetId;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    public String getLoadedInCats() {
        return loadedInCats;
    }

    public BigDecimal getSuccessorId() {
        return successorId;
    }

    public void setLoadedInCats(String loadedInCats) {
        this.loadedInCats = loadedInCats;
    }

    public String getIsPrepopulated() {
        return isPrepopulated;
    }

    public void setSrcUniqueFileName(String srcUniqueFileName) {
        this.srcUniqueFileName = srcUniqueFileName;
    }

    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }

    public void setIsFormatValid(String isFormatValid) {
        this.isFormatValid = isFormatValid;
    }

    public String getIsBulk() {
        return isBulk;
    }

    public void setRunId(BigDecimal runId) {
        this.runId = runId;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public void setModifiedDate(Timestamp modifiedDate) {
        this.modifiedDate = modifiedDate;
    }

    public void setCreatedDate(Timestamp createdDate) {
        this.createdDate = createdDate;
    }

    public void setPredecessorId(BigDecimal predecessorId) {
        this.predecessorId = predecessorId;
    }

    public String getIsSystemDerived() {
        return isSystemDerived;
    }
}"
45,"import com.codahale.metrics.Counter;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.Histogram;
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.atomic.AtomicInteger;

public class DataServerMetrics {
  private static final AtomicInteger ID_GENERATOR = new AtomicInteger();
  private final MetricRegistry metricRegistry;
  public final String name;

  public DataServerMetrics(String name) {
    this.name = name;
    this.metricRegistry = new MetricRegistry();
    this.metricRegistry.register(name + "".queries"", new Meter());
  }

  public Counter getQueries() {
    return metricRegistry.counter(name + "".queries"");
  }

  // ... and similar accessor methods for other metric types
}"
46,"import org.bitcoinj.core.*;
import org.bitcoinj.script.*;
import java.util.*;

public class GetRedeemScriptKey {
    public static void main(String[] args) {
        // TODO: Replace these with real values.
        String privateKey = ""yourPrivateKey"";
        String address = ""yourAddress"";

        EcKey key = ECKey.fromPrivate(new BigInteger(privateKey));
        Address addressFromKey = Address.fromKey(NetworkParameters.prodNet(), key);
        if (!addressFromKey.toString().equals(address)) {
            throw new RuntimeException(""Addresses don't match"");
        }

        redeemScript = ScriptBuilder.createP2SHOutputScript(address);
        // Create RedeemData using key and redeemScript
        RedeemData redeemData = RedeemData.of(key, redeemScript);
        // Get the first key that has private bytes
        ECKey firstKey = RedeemData.keysWithPrivateBytes(Arrays.asList(redeemData)).iterator().next();
    }
}"
47,"import com.google.monitoring.runtime.instrumentation.Instrumentation;
import java.util.logging.Logger;

final class InstrumentationService {
  private final Logger log = Logger.getLogger(InstrumentationService.class.getName());
  private final Instrumentation instrumentation;

  InstrumentationService() {
    instrumentation = Instrumentation.get();
    log.info(""Initialized instrumentation service"");
  }

  /** We're using Instrumentation here as a placeholder. */
  Class<? extends Service> getInterface() {
    return Instrumentation.class;
  }
}"
48,"import com.google.cloud.security.privateca.v1.JwtParameters;

public class SetMaxSigningKeySet {

  public static void main(String[] args) {
    // TODO(developer): Replace these variables before running the sample.
    /* Project ID or project number of the Cloud project you want to use. */
    String projectId = ""YOUR_PROJECT_ID"";

    /*
     * Full path of the location where the CA resides in. For a list of locations,
     * see: https://cloud.google.com/certificate-authority-service/docs/locations.
     */
    String location = ""YOUR_CA_LOCATION"";
    /* The resource name for this CA google.cloud.security.privateca.v1.CertificateAuthorityName. */
    String caPoolName = ""YOUR_CA_POOL_NAME"";

    setMaxSigningKeySet(projectId, location, caPoolName);
  }

  // Set the maximum key size used to generate a symmetric key to sign the issued certificate.
  public static void setMaxSigningKeySet(
      String projectId, String location, String caPoolName) {
    try (CertificateAuthorityServiceClient client =
        CertificateAuthorityServiceClient.create()) {

      // Initialize request argument(s).
      JwtParameters jwtParameters =
          JwtParameters.newBuilder().setMaximumKeySize(256).build();

      // Set fields in the CertificateAuthority.
      CaPool.Builder caPool = CaPool.newBuilder().setJwtParameters(jwtParameters);

      // Build the name from the project, location, and ca pool.
      CaPoolName name = CaPoolName.of(projectId, location, caPoolName);

      // Create and update the certificate authority pool.
      CaPool response = client.updateCaPool(name, caPool.build());
      System.out.println(""Updated maximum key size for signing key: "" + response.getName());
    } catch (IOException e) {
      throw new RuntimeException(""Couldn't create client."", e);
    }
  }
}"
49,"import com.google.cloud.bigquery.BigQuery;
import com.google.cloud.bigquery.BigQueryException;
import com.google.cloud.bigquery.BigQueryOptions;
import com.google.cloud.bigquery.QueryJobConfiguration;
import com.google.cloud.bigquery.QueryParameterValue;
import com.google.cloud.bigquery.TableResult;

// Sample to get field value
public class GetFieldValue {

  public static void main(String[] args) {
    // TODO(developer): Replace these variables before running the sample.
    String query = ""SELECT @field_name FROM [bigquery-public-data:samples.shakespeare] LIMIT 1"";
    String fieldName = ""word_count"";
    getFieldValue(query, fieldName);
  }

  public static void getFieldValue(String query, String fieldName) {
    try {
      // Initialize client that will be used to send requests. This client only needs to be created
      // once, and can be reused for multiple requests.
      BigQuery bigquery = BigQueryOptions.getDefaultInstance().getService();

      // Note: Standard SQL is required to use query parameters.
      QueryJobConfiguration queryConfig =
          QueryJobConfiguration.newBuilder(query)
              .addNamedParameter(""field_name"", QueryParameterValue.string(fieldName))
              .build();

      TableResult results = bigquery.query(queryConfig);

      results
          .iterateAll()
          .forEach(row -> row.forEach(val -> System.out.printf(""%s\n"", val.toString())));

      System.out.println(""Field value retrieved successfully"");
    } catch (BigQueryException | InterruptedException e) {
      System.out.println(""Field value not retrieved. \n"" + e.toString());
    }
  }
}"
50,"import java.lang.String;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

public interface NetworkParameters {
  /**
   * Shortcut for parameters for the production network.
   * @deprecated use NetworkParameters.mainNet() instead.
   */
  @Deprecated
  NetworkParameters prodNet = mainNet();

  /**
   * Shortcut for parameters for testing an unspendable coin.
   */
  NetworkParameters unitTests = unitTests();

  /**
   * Shortcut for parameters for the testnet.
   */
  NetworkParameters testNet = testNet();

  /**
   * Shortcut for parameters for the regtest mode.
   */
  NetworkParameters regTests = regTests();

  /**
   * Shortcut for parameters for the testnet2 mode.
   */
  NetworkParameters testNet2 = testNet2();

  /**
   * Shortcut for parameters for the testnet3 mode.
   */
  NetworkParameters testNet3 = testNet3();

  /**
   * Get the {@link NetworkParameters} object for the given string ID, or null if a matching ID is not known.
   * @param id a string network ID.
   * @return networkParameters or null.
   * @throws NullPointerException if ID is null.
   */
  static NetworkParameters fromID(String id) {
      for (NetworkParameters p : NetworkParameters.values()) {
          if (p.id.equals(id)) {
              return p;
          }
      }
      return null;
  }

  /**
   * Get the {@link NetworkParameters} object for the given payment protocol ID, or null if a matching ID is not known.
   * @param pmtProtocolId a string payment protocol ID.
   * @return networkParameters or null.
   * @throws NullPointerException if PmtProtocolId is null.
   */
  static NetworkParameters fromPmtProtocolID(String pmtProtocolId) {
      for (NetworkParameters p : NetworkParameters.values()) {
          if (p.paymentProtocolId.equals(pmtProtocolId)) {
              return p;
          }
      }
      return null;
  }

  /**
   * Returns the network parameters for Bitcoin's production (live) network.
   * @return a NetworkParameters object.
   */
  static NetworkParameters mainNet() {
      NetworkParameters params = new NetworkParameters();
      params.id = ""org.bitcoin.production"";
      params.paymentProtocolId = ""main"";
      params.acceptableAddressCodes = new int[] { 0 };
      params.dumpedPrivateKeyHeader = 128;
      params.addressHeader = 0;
      params.p2shHeader = 5;
      params.bip32HeaderPub = 0x0488B21E; //The 4 byte header that serializes in base58 to ""xpub"".
      params.bip32HeaderPriv = 0x0488ADE4; //The 4 byte header that serializes in base58 to ""xprv""
      params.interval = INTERVAL; // 10 minutes
      params.targetTimespan = TARGET_TIMESPAN; // 14 days
      params.maxTarget = MAX_TARGET;
      params.port = 8333;
      params.packetMagic = 0xf9beb4d9L;
      params.genesisBlock = genesisBlock;
      params.dnsSeeds = new String[] {
          ""seed.bitcoin.sipa.be"",         // Pieter Wuille
          ""dnsseed.bluematt.me"",         // Matt Corallo
          ""dnsseed.bitcoin.dashjr.org"",  // Luke Dashjr
          ""seed.bitcoinstats.com"",       // Chris Decker
          ""seed.bitcoin.jonasschnelli.ch"",// Jonas Schnelli
          ""seed.btc.petertodd.org"",      // Peter Todd
          ""seed.bitcoin.sprovoost.nl"",   // Sjors Provoost
          ""dnsseed.emzy.de"",             // Stephan Oeste
      };
      params.subsidyDecreaseBlockCount = 210000;
      params.spendableCoinbaseDepth = 100;
      params.subsidyDecreaseBlockCount = 210000;
      params.dumpedPrivateKeyHeader = 128;
      params.acceptableAddressCodes = new int[] { 0 };
      params.alertSigningKey = SATOSHI_KEY;
      return params;
  }

  /**
   * Returns a testnet {@link NetworkParameters} object.
   * @return a TestNetParams object.
   */
  static NetworkParameters testNet() {
      NetworkParameters params = NetworkParameters.prodNet();
      params.id = ""org.bitcoin.test"";
      params.addressHeader = 111;
      params.p2shHeader = 196;
      params.port = 18333;
      params.packetMagic = 0xfabfb5daL;
      params.dnsSeeds = new String[] {
          ""testnet-seed.bitcoin.petertodd.org"",
          ""testnet-seed.bluematt.me"",
      };
      params.genesisBlock = testNetGenesisBlock;
      params.subsidyDecreaseBlockCount = 20160;
      params.spendableCoinbaseDepth = 100;
      params.alertSigningKey = TESTNET_SATOSHI_KEY;
      return params;
  }

  /**
   * Returns a regtest {@link NetworkParameters} object.
   * @return a TestNetParams object.
   */
  static NetworkParameters regTests() {
      NetworkParameters params = NetworkParameters.prodNet();
      params.id = ""org.bitcoin.regtest"";
      params.addressHeader = 111;
      params.p2shHeader = 196;
      params.port = 18444;
      params.interval = INTERVAL;
      params.targetTimespan = TARGET_TIMESPAN;
      params.maxTarget = MAX_TARGET;
      params.dnsSeeds = null;
      params.genesisBlock = regTestGenesisBlock;
      params.subsidyDecreaseBlockCount = 150;
      params.spendableCoinbaseDepth = 0;
      params.alertSigningKey = TESTNET_SATOSHI_KEY;
      return params;
  }

  /**
   * Returns a unit test {@link NetworkParameters} object.
   * @return a UnitTestParams object.
   */
  static NetworkParameters unitTests() {
      NetworkParameters params = NetworkParameters.prodNet();
      params.id = ""org.bitcoin.unittest"";
      params.addressHeader = 111;
      params.p2shHeader = 196;
      params.port = 18334;
      params.genesisBlock = unitTestGenesisBlock;
      params.dnsSeeds = null;
      params.spendableCoinbaseDepth = 0;
      params.subsidyDecreaseBlockCount = 100;
      params.alertSigningKey = TESTNET_SATOSHI_KEY;
      return params;
  }

  /**
   * Returns a testnet2 {@link NetworkParameters} object.
   * @return a TestNet2Params object.
   */
  static NetworkParameters testNet2() {
      NetworkParameters params = NetworkParameters.prodNet();
      params.id = ""org.bitcoin.test2"";
      // Difficulty adjustment interval is 2015 seconds, no retargets
      params.interval = 2015;
      params.targetTimespan = 2015 * 4;  // 34 minutes
      params.maxTarget = NetworkParameters.MAX_TARGET;
      params.addressHeader = 111;
      params.p2shHeader = 196;
      params.port = 17334;
      params.packetMagic = 0xfcc1b7dcL;
      params.genesisBlock = testNet2GenesisBlock;
      params.dnsSeeds = new String[] {
          ""testnet2-seed.bitcoin.petertodd.org"",
          ""testnet2-seed.bluematt.me"",
      };
      params.spendableCoinbaseDepth = 0;
      params.subsidyDecreaseBlockCount = 20160;
      params.alertSigningKey = TESTNET_SATOSHI_KEY;
      return params;
  }

  /**
   * Returns a testnet3 {@link NetworkParameters} object.
   * @return a TestNet3Params object.
   */
  static NetworkParameters testNet3() {
      NetworkParameters params = NetworkParameters.prodNet();
      params.id = ""org.bitcoin.test3"";
      // Difficulty adjustment interval is 2015 seconds,"
51,"import org.bitcoinj.core.Coin;
import org.bitcoinj.core.Monetary;

public class MonetaryTest {

    Coin coin = Coin.COIN;
    int smallestUnitExponent = coin.smallestUnitExponent;
    long satoshis = coin.satoshis;
    String toString = coin.toString();
    long value = coin.getValue();
    Coin add = Coin.add(coin, coin);
    Coin subtract = Coin.subtract(coin, coin);
    boolean signum = coin.signum() > 0;
    Coin[] divideAndRemainder = Coin.divideAndRemainder(coin, 2);
    int compareTo = coin.compareTo(coin);
    long longValue = coin.longValue();
    String toFriendlyString = coin.toFriendlyString();
    String toPlainString = coin.toPlainString();
    Coin negated = coin.negate();
    boolean equals = coin.equals(coin);
    int compareTo2 = Monetary.CENT.compareTo(Monetary.MILLICOIN);
    Coin amount = Monetary.CENT;
    boolean isZero = coin.isZero();
    Coin divide = coin.divide(2);
    long divide2 = coin.divide(2);
    Coin shiftRight = coin.shiftRight(2);
    Coin shiftLeft = coin.shiftLeft(2);
    Coin multiply = coin.multiply(2);
    boolean isGreaterThan = coin.isGreaterThan(coin);
    boolean isLessThan = coin.isLessThan(coin);
    boolean isPositive = coin.isPositive();
    boolean isNegative = coin.isNegative();
    Coin valueOf = Coin.valueOf(satoshis);
    Coin valueOf2 = Coin.valueOf(2, satoshis);
    Coin parseCoin = Coin.parseCoin(""0.00000001"");
    int hashCode = coin.hashCode();
    long satoshiMax = Coin.MAX_SATOSHIS;

}"
52,"MenuItem mMenuItem = ...;
mMenuItem.setActionView(R.layout.action_view);"
53,"import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.when;

import com.google.cloud.securitycenter.v1.NotificationMessage;
import com.google.cloud.securitycenter.v1.SecurityMarks;
import com.google.cloud.servicedirectory.v1.RegistrationServiceClient;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.assertj.core.api.Assertions;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

/**
 * Unit tests for NotificationController.
 */
@RunWith(JUnit4.class)
public class NotificationControllerTest {
  // The System Property key for user notification channels.
  private static final String PROPERTY_USER_STREAMING_CHANNEL =
      System.getenv(""PUBSUB_VERIFICATION_TOKEN"");
  // The System Property key for service account notification channels.
  private static final String PROPERTY_PROJECT_STREAMING_CHANNEL =
      System.getenv(""PUBSUB_VERIFICATION_TOKEN_SA"");
  // The value of the user property key.
  private static final String USER_STREAMING_CHANNEL = PROPERTY_USER_STREAMING_CHANNEL;
  // The value of the service account property key.
  private static final String PROJECT_STREAMING_CHANNEL = PROPERTY_PROJECT_STREAMING_CHANNEL;
  // The alert names for the NotificationMessage.
  private static final List<String> ALERT_IDS = Arrays.asList(""alertId1"", ""alertId2"");
  // The message of the NotificationMessage.
  private static final String MESSAGE = ""message"";
  // The project identifier for user notifications.
  private static final String TEST_PROJECT_ID = ""test-project-id"";
  // The project identifier for service account notifications.
  private static final String TEST_SA_PROJECT_ID = ""test-sa-project-id"";
  // The user id for user notifications.
  private static final String TEST_USER_ID = ""test-user-id"";
  // The list of known notification clients.
  private static final Map<String, NotificationClient> KNOWN_CLIENTS = new HashMap<>();
  // The verification signature for user notifications.
  private static final String TEST_SIGNATURE = ""testSignature"";
  // The encoded verification signature for user notifications.
  private static final String TEST_ENCODED_SIGNATURE = Base64.getEncoder().encodeToString(TEST_SIGNATURE.getBytes());
  // The verification signature for service account notifications.
  private static final String TEST_SA_SIGNATURE = ""test-sa-signature"";
  // The encoded verification signature for service account notifications.
  private static final String TEST_SA_ENCODED_SIGNATURE = Base64.getEncoder().encodeToString(TEST_SA_SIGNATURE.getBytes());
  // The testServerSession object to pass into the NotificationController methods.
  private ServerSession mockServerSession;
  // The mockServerMessage object to pass into the NotificationController methods.
  private ServerMessage mockServerMessage;
  // The mock serverServiceClient object to pass into the NotificationController methods.
  @Mock
  private RegistrationServiceClient mockServiceClient;
  // The user notification client to be used by the NotificationController.
  private final NotificationClient userNotificationClient =
      new NotificationClient(
          TEST_PROJECT_ID,
          USER_STREAMING_CHANNEL,
          KNOWN_CLIENTS,
          TEST_SIGNATURE,
          mockServerSession,
          mockServiceClient);
  // The service account notification client to be used by the NotificationController.
  private final NotificationClient saNotificationClient =
      new NotificationClient(
          TEST_SA_PROJECT_ID,
          PROJECT_STREAMING_CHANNEL,
          KNOWN_CLIENTS,
          TEST_SA_SIGNATURE,
          mockServerSession,
          mockServiceClient);
  // The NotificationController to be tested.
  private NotificationController notificationController;

  @Captor
  private ArgumentCaptor<NotificationMessage> notificationMessageCaptor;

  @Before
  public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    notificationController = new NotificationController(userNotificationClient, saNotificationClient);
    mockServerSession = mock(ServerSession.class);
    mockServerMessage = mock(ServerMessage.class);
    when(mockServerSession.getId()).thenReturn(MOCK_SESSION_ID);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullUser() {
    when(mockServerMessage.getDict()).thenReturn(new HashMap<>());
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullTimestamp() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullTitle() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    eventDict.put(""timestamp"", ""testTime"");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyTitle() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    eventDict.put(""timestamp"", ""testTime"");
    eventDict.put(""title"", "");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullMessage() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    eventDict.put(""timestamp"", ""testTime"");
    eventDict.put(""title"", ""testTitle"");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyMessage() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    eventDict.put(""timestamp"", ""testTime"");
    eventDict.put(""title"", ""testTitle"");
    eventDict.put(""message"", "");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullApplication() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    eventDict.put(""timestamp"", ""testTime"");
    eventDict.put(""title"", ""testTitle"");
    eventDict.put(""message"", ""testMessage"");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyApplication() {
    Map<String, Object> eventDict = new HashMap<>();
    eventDict.put(""user"", ""testUser"");
    eventDict.put(""timestamp"", ""testTime"");
    eventDict.put(""title"", ""testTitle"");
    eventDict.put(""message"", ""testMessage"");
    eventDict.put(""application"", "");
    when(mockServerMessage.getDict()).thenReturn(eventDict);
    Assertions.assertThatThrownBy(() -> {
      notificationController.handleEvent(mockServerSession, mockServerMessage);
    }).isInstanceOf(IllegalArgumentException.class);
  }

  @Test
  public void testDeletePersistentNotificationThrows"
54,"import java.time.OffsetTime;
import java.time.temporal.ChronoField;
import java.time.temporal.Temporal;

public class OffsetTimeExample {

    public static void main(String[] args) {
        OffsetTime offsetTime = OffsetTime.of(10, 15, 30, 0, ZoneOffset.ofHours(1));

        // Get seconds of minute
        double seconds = offsetTime.get(ChronoField.SECOND_OF_MINUTE);
        System.out.println(seconds); // 30.0

        // Set seconds of minute
        offsetTime = offsetTime.with(ChronoField.SECOND_OF_MINUTE, 45);
        System.out.println(offsetTime); // 10:15:45+01:00

        // Get offset hours
        int offsetHours = offsetTime.getOffset().get(ChronoField.OFFSET_SECONDS) / 3600;
        System.out.println(offsetHours); // 1

        // Set offset hours
        offsetTime = offsetTime.withOffsetSameInstant(ZoneOffset.ofHours(2));
        System.out.println(offsetTime); // 10:15:45+02:00

        // Get minutes
        int minutes = offsetTime.getMinute();
        System.out.println(minutes); // 15

        // Set minutes
        offsetTime = offsetTime.withMinute(30);
        System.out.println(offsetTime); // 10:30:45+02:00

        // Get hour
        int hour = offsetTime.getHour();
        System.out.println(hour); // 10

        // Set hour
        offsetTime = offsetTime.withHour(12);
        System.out.println(offsetTime); // 12:30:45+02:00

        // Get time as a string
        String timeString = offsetTime.toString();
        System.out.println(timeString); // 12:30:45+02:00

        // Parse a time string
        offsetTime = OffsetTime.parse(timeString);
        System.out.println(offsetTime); // 12:30:45+02:00

        // Get time as milliseconds since epoch
        long milliseconds = offsetTime.toEpochSecond() * 1000;
        System.out.println(milliseconds); // 1654858645000

        // Set time as milliseconds since epoch
        offsetTime = OffsetTime.ofEpochSecond(milliseconds / 1000, 0, ZoneOffset.ofHours(2));
        System.out.println(offsetTime); // 12:30:45+02:00
    }
}"
55,"import java.net.*;

public class DatagramPacket {
    public DatagramPacket(byte[] data, int offset, int length, ServiceID serviceID, int capacity, InetAddress address) {}

    public ServiceID getServiceID() {}

    public void setLengthOnly() {}

    public void setLength() {}

    public void setAddress() {}

    public void setData() {}

    public void setData() {}

    public SocketAddress getSocketAddress() {}

    public int getOffset() {}

    public int getLength() {}

    public InetAddress getAddress() {}

    public void setSocketAddress() {}

    public byte[] getData() {}

    public int getCapacity() {}
}"
56,"package org.spongycastle.crypto.util.store;

import java.io.File;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.OverlappingFileLockException;
import java.nio.file.StandardOpenOption;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.spongycastle.crypto.ExtendedDigest;
import org.spongycastle.crypto.params.KeyParameter;
import org.spongycastle.crypto.util.DigestFactory;
import org.spongycastle.crypto.util.StreamBlockCipher;
import org.spongycastle.crypto.util.Store;
import org.spongycastle.util.encoders.Hex;

public class MappedFileChainStore<T>
    implements Store<T>
{
    private static final boolean REMOVE_FROM_KEY_CACHE = true;
    private static final boolean DO_NOT_REMOVE_FROM_KEY_CACHE = false;

    private static final String HEADER_MAGIC = ""SC"";

    private static final int RECORD_SIZE = 16 + 32 + 4;  // hash + value + length

    private static final int FILE_PROLOGUE_BYTES = 4 + 4 + 4;  // version + header length + padding

    private static int DEFAULT_NUM_HEADERS = 1024;

    private final File file;
    private final int numHeaders;
    private final Object notFoundMarker = new Object();
    private final ReentrantLock lock = new ReentrantLock();
    private final Logger log;

    private FileLock fileLock;
    private RandomAccessFile randomAccessFile;
    private MappedByteBuffer buffer;
    private StoredBlock<T> lastChainHead;

    private LinkedHashMap<Sha256Hash, Object> notFoundCache = new LinkedHashMap<Sha256Hash, Object>()
    {
        private static final long serialVersionUID = 1L;

        @Override
        protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Object> eldest)
        {
            return size() > 1000;
        }
    };

    private LinkedHashMap<Sha256Hash, StoredBlock<T>> blockCache = new LinkedHashMap<Sha256Hash, StoredBlock<T>>()
    {
        private static final long serialVersionUID = 1L;

        @Override
        protected boolean removeEldestEntry(Map.Entry<Sha256Hash, StoredBlock<T>> eldest)
        {
            return size() > 1000;
        }
    };

    public MappedFileChainStore(File file)
    {
        this(file, DEFAULT_NUM_HEADERS);
    }

    public MappedFileChainStore(File file, int numHeaders)
    {
        this(file, numHeaders, null);
    }

    public MappedFileChainStore(File file, int numHeaders, Logger log)
    {
        this.file = file;
        this.numHeaders = numHeaders;
        this.log = log;
    }

    public T get(Sha256Hash chainHeadHash)
        throws IOException
    {
        lock.lock();
        try
        {
            StoredBlock<T> result = getChainHead();

            if (result != null)
            {
                while (!result.hash.equals(chainHeadHash))
                {
                    result = result.previous;
                    if (result == null)
                    {
                        log(""Chain head not found: "" + chainHeadHash);
                        return null;
                    }
                }
                if (notFoundCache.containsKey(result.hash))
                {
                    log(""Returning not found marker: "" + result.hash);
                    return null;
                }
                if (result.value == null)
                {
                    result = initValue(result);
                    if (result == null)
                    {
                        notFoundCache.put(result.hash, notFoundMarker);
                        if (chainHeadHash.equals(getChainHead().hash))
                        {
                            setChainHead(result);
                        }
                        log(""Returning not found marker: "" + result.hash);
                        return null;
                    }
                }
                return result.value;
            }

            log(""Returning not found marker: "" + chainHeadHash);
            return null;            
        }
        finally
        {
            lock.unlock();
        }
    }

    public void put(Sha256Hash chainHeadHash, T value)
        throws IOException
    {
        lock.lock();
        try
        {
            StoredBlock<T> newChainHead = initBlock(value);

            if (getChainHead() == null)
            {
                setChainHead(newChainHead);
                return;
            }

            while (chainHeadHash.compareTo(getChainHead().hash) != 0)
            {
                StoredBlock<T> next = initBlock(getChainHead().value);
                if (next == null)
                {
                    setChainHead(newChainHead);
                    return;
                }
                newChainHead = next;
            }

            setChainHead(newChainHead);
        }
        finally
        {
            lock.unlock();
        }
    }

    public void init(KeyParameter key)
        throws GeneralSecurityException
    {
        if (fileLock == null || !fileLock.isValid())
        {
            if (file.exists())
            {
                file.delete();
            }
            try
            {
                file.createNewFile();
                FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE);
                try
                {
                    fileLock = channel.tryLock();
                    randomAccessFile = new RandomAccessFile(file, ""rw"");

                    if (randomAccessFile.length() == 0)
                    {
                        initNewStore(key);
                    }
                    else
                    {
                        buffer = map();
                    }
                }
                finally
                {
                    if (fileLock == null || !fileLock.isValid())
                    {
                        channel.close();
                        if (file.exists())
                        {
                            file.delete();
                        }
                    }
                }
            }
            catch (OverlappingFileLockException e)
            {
                // already in use
                log(""OverlappingFileLockException"");
            }
            catch (IOException e)
            {
                log(""IOException locking"", e);
            }
        }
    }

    public void close()
        throws IOException
    {
        synchronized (lock)
        {
            if (fileLock != null && fileLock.isValid())
            {
                fileLock.release();
                fileLock = null;
            }

            if (buffer != null)
            {
                unmap();
                buffer = null;
            }

            if (randomAccessFile != null)
            {
                randomAccessFile.close();
                randomAccessFile = null;
            }
        }
    }

    private void initNewStore(KeyParameter keyParameter)
        throws IOException
    {
        ExtendedDigest digest = DigestFactory.createSHA256();
        StreamBlockCipher cipher = new StreamBlockCipher(digest);
        KeyParameter key = new KeyParameter(Hex.decode(HEADER_MAGIC + String.format(""%08x"", randomAccessFile.length())));
        cipher.init(false, key);

        byte[] zeroes = new byte[digest.getDigestSize()];

        try
        {
            randomAccessFile.write(cipher.process(zeroes));
            randomAccessFile.writeInt(numHeaders);
            randomAccessFile.writeInt(0);
            randomAccessFile.write(cipher.process(zeroes));

            unmap();
            buffer = map();

            writeHeader(cipher, keyParameter);

            // just put a bogus chain head at the start
            StoredBlock<T> initChainHead = new StoredBlock<T>(new Sha256Hash(zeroes));
            setBlock(initChainHead.hash, initChainHead);
            setChainHead(initChainHead);
        }
        finally
        {
            cipher.reset();
        }
    }

    private void log(String string)
    {
        if (log != null)
        {
            log.info((new StringBuilder()).append(file).append("" "").append(string).toString());
        }
    }

    private void log(String string, Throwable t)
    {
        if (log != null)
        {
            log.info((new StringBuilder()).append(file).append("" "").append(string).toString(), t);
        }
    }

    private MappedByteBuffer map()"
57,"public class DirectedAcyclicGraphNode<T> {

  private List<DirectedAcyclicGraphNode<T>> mParents;
  private List<DirectedAcyclicGraphNode<T>> mChildren;
  private T mPayload;

  public DirectedAcyclicGraphNode(T payload) {
    mPayload = payload;
    mParents = new ArrayList<>();
    mChildren = new ArrayList<>();
  }

  public List<DirectedAcyclicGraphNode<T>> getParents() {
    return mParents;
  }

  public List<DirectedAcyclicGraphNode<T>> getChildren() {
    return mChildren;
  }

  public void removeChild(DirectedAcyclicGraphNode<T> child) {
    mChildren.remove(child);
  }

  public void addParent(DirectedAcyclicGraphNode<T> parent) {
    mParents.add(parent);
  }

  public void addChild(DirectedAcyclicGraphNode<T> child) {
    mChildren.add(child);
  }

  public T getPayload() {
    return mPayload;
  }

  public void setPayload(T payload) {
    mPayload = payload;
  }
}"
58,"import java.text.SimpleDateFormat;
import java.util.Date;

public class Stats implements Cloneable, Comparable<Stats> {
    private String ext;
    private Date addedDate;
    private int rating;
    private int previousPlayCounter;
    private Date ratingModifDate;
    private Date lastPlayed;
    private String relativeFullPath;
    private boolean updateRatingModifDate;
    private int idPath;
    private String filename;
    private boolean deleted;
    private float BPM;
    private String relativePath;
    private int idFile;
    private String sourceName;
    private int playCounter;

    public String getFormattedRatingModifDate() {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return sdf.format(ratingModifDate);
    }

    public void setIdPath(int idPath) {
        this.idPath = idPath;
    }

    public void setAddedDate(Date addedDate) {
        this.addedDate = addedDate;
    }

    public String getSourceName() {
        return sourceName;
    }

    public boolean equalsStats(Stats other) {
        return this.rating == other.rating && this.previousPlayCounter == other.previousPlayCounter && this.lastPlayed.equals(other.lastPlayed) && this.relativeFullPath.equals(other.relativeFullPath) && this.updateRatingModifDate == other.updateRatingModifDate && this.idPath == other.idPath && this.filename.equals(other.filename) && this.deleted == other.deleted && this.BPM == other.BPM && this.relativePath.equals(other.relativePath) && this.idFile == other.idFile && this.sourceName.equals(other.sourceName) && this.playCounter == other.playCounter;
    }

    public int getIdFile() {
        return idFile;
    }

    public int compareTo(Stats other) {
        return this.rating - other.rating;
    }

    public void setFilename(String filename) {
        this.filename = filename;
    }

    public void setRelativePath(String relativePath) {
        this.relativePath = relativePath;
    }

    public int getPreviousPlayCounter() {
        return previousPlayCounter;
    }

    public boolean isDeleted() {
        return deleted;
    }

    public int hashCode() {
        return this.rating + this.previousPlayCounter + this.lastPlayed.hashCode() + this.relativeFullPath.hashCode() + (this.updateRatingModifDate ? 1 : 0) + this.idPath + this.filename.hashCode() + (this.deleted ? 1 : 0) + Float.floatToIntBits(this.BPM) + this.relativePath.hashCode() + this.idFile + this.sourceName.hashCode() + this.playCounter;
    }

    public void setPlayCounter(int playCounter) {
        this.playCounter = playCounter;
    }

    public String getLastPlayedLocalTime() {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return sdf.format(lastPlayed);
    }

    public void setBPM(float BPM) {
        this.BPM = BPM;
    }

    public String getRelativeFullPath() {
        return relativeFullPath;
    }

    public String getAddedDateLocalTime() {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return sdf.format(addedDate);
    }

    public float getBPM() {
        return BPM;
    }

    public void setIdFile(int idFile) {
        this.idFile = idFile;
    }

    public Date getAddedDate() {
        return addedDate;
    }

    public String getExt() {
        return ext;
    }

    public Date getRatingModifDate() {
        return ratingModifDate;
    }

    public void setLastPlayed(Date lastPlayed) {
        this.lastPlayed = lastPlayed;
    }

    public void setRelativeFullPath(String relativeFullPath) {
        this.relativeFullPath = relativeFullPath;
    }

    public void setPath(String path) {
        this.filename = path.substring(path.lastIndexOf(""/"") + 1);
        this.relativeFullPath = path.substring(path.indexOf(""Music/"") + 6);
        this.relativePath = path.substring(path.indexOf(""Music/"") + 6, path.lastIndexOf(""/"") + 1);
    }

    public void setSourceName(String sourceName) {
        this.sourceName = sourceName;
    }

    public String getFilename() {
        return filename;
    }

    public String getFormattedLastPlayed() {
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        return sdf.format(lastPlayed);
    }

    public Date getLastPlayed() {
        return lastPlayed;
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Stats)) return false;
        Stats stats = (Stats) o;
        return this.rating == stats.rating && this.previousPlayCounter == stats.previousPlayCounter && this.lastPlayed.equals(stats.lastPlayed) && this.relativeFullPath.equals(stats.relativeFullPath) && this.updateRatingModifDate == stats.updateRatingModifDate && this.idPath == stats.idPath && this.filename.equals(stats.filename) && this.deleted == stats.deleted && this.BPM == stats.BPM && this.relativePath.equals(stats.relativePath) && this.idFile == stats.idFile && this.sourceName.equals(stats.sourceName) && this.playCounter == stats.playCounter;
    }

    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    public String toString() {
        return ""Stats{ext='"" + ext + '\' + "", addedDate="" + addedDate + "", rating="" + rating + "", previousPlayCounter="" + previousPlayCounter + "", ratingModifDate="" + ratingModifDate + "", lastPlayed="" + lastPlayed + "", relativeFullPath='"" + relativeFullPath + '\' + "", updateRatingModifDate="" + updateRatingModifDate + "", idPath="" + idPath + "", filename='"" + filename + '\' + "", deleted="" + deleted + "", BPM="" + BPM + "", relativePath='"" + relativePath + '\' + "", idFile="" + idFile + "", sourceName='"" + sourceName + '\' + "", playCounter="" + playCounter + '}';
    }

    public void setUpdateRatingModifDate(boolean updateRatingModifDate) {
        this.updateRatingModifDate = updateRatingModifDate;
    }

    public int getIdPath() {
        return idPath;
    }

    public String getRelativePath() {
        return relativePath;
    }

    public void setRating(int rating) {
        this.rating = rating;
    }

    public int getPlayCounter() {
        return playCounter;
    }

    public int getRating() {
        return rating;
    }
}"
59,"import java.util.ArrayList;
import java.util.List;

class DirectedAcyclicGraphNode<T> {
  private List<DirectedAcyclicGraphNode<T>> mParents;
  private List<DirectedAcyclicGraphNode<T>> mChildren;
  private T mPayload;

  public DirectedAcyclicGraphNode(T payload) {
    this(payload, new ArrayList<DirectedAcyclicGraphNode<T>>(), new ArrayList<DirectedAcyclicGraphNode<T>>());
  }

  private DirectedAcyclicGraphNode(T payload, List<DirectedAcyclicGraphNode<T>> parents,
      List<DirectedAcyclicGraphNode<T>> children) {
    mParents = parents;
    mChildren = children;
    mPayload = payload;
  }

  public List<DirectedAcyclicGraphNode<T>> getParents() {
    return mParents;
  }

  public T getPayload() {
    return mPayload;
  }

  public void removeChild(DirectedAcyclicGraphNode<T> child) {
    mChildren.remove(child);
  }

  public void addParent(DirectedAcyclicGraphNode<T> parent) {
    if (!mParents.contains(parent)) {
      mParents.add(parent);
    }
  }

  public void addChild(DirectedAcyclicGraphNode<T> child) {
    if (!mChildren.contains(child)) {
      mChildren.add(child);
    }
  }
}"
60,"int itemPosition = mOrientationProvider.getScrolledHeaderPosition(mDimensionCalculator, mAdapter);
    if (itemPosition == -1) {
      return null;
    }
    if (!hasNewHeader(itemPosition)) {
      // If the current header is entirely obscured by another header, stop early.
      if (itemIsObscuredByHeader(itemPosition, mDimensionCalculator)) {
        return null;
      }
      int listLeft = getListLeft();
      int listTop = getListTop();
      Rect headerBounds = getHeaderBounds(itemPosition, mAdapter, mDimensionCalculator);
      Rect defaultHeaderOffset = getDefaultHeaderOffset();

      int dx = listLeft - (headerBounds.left - defaultHeaderOffset.left);
      int dy = listTop - (headerBounds.top - defaultHeaderOffset.top);
      translateHeaderWithNextHeader(itemPosition, dx, dy);
      return headerBounds;
    }
    return null;"
61,"import java.util.Date;
import java.util.List;

public class TestRunDetailsDTO {
    private Long testId;
    private Long runId;
    private String feedId;
    private Date fetcherStartTimeStamp;
    private Date fetcherEndTimeStamp;
    private OutcomeType outcome;
    private RunStatusType runStatus;
    private String errorMsg;
    private List<TestResultDetailsDTO> regTestResultDetailsLst;
    private Date createTimeStamp;
    private Date lastModifiedTimeStamp;
    private String createdBy;

    public Long getTestId() {
        return testId;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public Long getRunId() {
        return runId;
    }

    public void setRunId(Long runId) {
        this.runId = runId;
    }

    public String getFeedId() {
        return feedId;
    }

    public void setFeedId(String feedId) {
        this.feedId = feedId;
    }

    public Date getFetcherStartTimeStamp() {
        return fetcherStartTimeStamp;
    }

    public void setFetcherStartTimeStamp(Date fetcherStartTimeStamp) {
        this.fetcherStartTimeStamp = fetcherStartTimeStamp;
    }

    public Date getFetcherEndTimeStamp() {
        return fetcherEndTimeStamp;
    }

    public void setFetcherEndTimeStamp(Date fetcherEndTimeStamp) {
        this.fetcherEndTimeStamp = fetcherEndTimeStamp;
    }

    public OutcomeType getOutcome() {
        return outcome;
    }

    public void setOutcome(OutcomeType outcome) {
        this.outcome = outcome;
    }

    public RunStatusType getRunStatus() {
        return runStatus;
    }

    public void setRunStatus(RunStatusType runStatus) {
        this.runStatus = runStatus;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public List<TestResultDetailsDTO> getRegTestResultDetailsLst() {
        return regTestResultDetailsLst;
    }

    public void setRegTestResultDetailsLst(List<TestResultDetailsDTO> regTestResultDetailsLst) {
        this.regTestResultDetailsLst = regTestResultDetailsLst;
    }

    public Date getCreateTimeStamp() {
        return createTimeStamp;
    }

    public void setCreateTimeStamp(Date createTimeStamp) {
        this.createTimeStamp = createTimeStamp;
    }

    public Date getLastModifiedTimeStamp() {
        return lastModifiedTimeStamp;
    }

    public void setLastModifiedTimeStamp(Date lastModifiedTimeStamp) {
        this.lastModifiedTimeStamp = lastModifiedTimeStamp;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    @Override
    public String toString() {
        return ""TestRunDetailsDTO [testId="" + testId + "", runId="" + runId + "", feedId="" + feedId + "", fetcherStartTimeStamp="" + fetcherStartTimeStamp + "", fetcherEndTimeStamp="" + fetcherEndTimeStamp + "", outcome="" + outcome + "", runStatus="" + runStatus + "", errorMsg="" + errorMsg + "", regTestResultDetailsLst="" + regTestResultDetailsLst + "", createTimeStamp="" + createTimeStamp + "", lastModifiedTimeStamp="" + lastModifiedTimeStamp + "", createdBy="" + createdBy + ""]"";
    }
}"
62,"import java.math.BigDecimal;
import java.util.List;
import java.util.Timestamp;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

@Entity
public class RegPCLTestResultEntity {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private long testId;

    @Temporal(TemporalType.TIMESTAMP)
    private Timestamp lastModifiedTimeStamp;

    @Temporal(TemporalType.TIMESTAMP)
    private Timestamp fetcherStartTimestamp;

    @Temporal(TemporalType.TIMESTAMP)
    private Timestamp createTimeStamp;

    private static final long serialVersionUID = 1L;
    private BigDecimal batchId;
    private String errorMsg;
    @Enumerated(EnumType.STRING)
    private OutcomeType outcomeType;
    private String createdBy;
    private BigDecimal feedId;
    private BigDecimal runId;
    @Temporal(TemporalType.TIMESTAMP)
    private Timestamp fetcherEndTimeStamp;
    @ElementCollection
    private List<RegPCLTestResultDetailsEntity> regPclTestResultDetails;
    @Enumerated(EnumType.STRING)
    private RunStatusType runStatus;

    public void setLastModifiedTimeStamp(Timestamp lastModifiedTimeStamp) {
        this.lastModifiedTimeStamp = lastModifiedTimeStamp;
    }

    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }

    public void setFetcherStartTimestamp(Timestamp fetcherStartTimestamp) {
        this.fetcherStartTimestamp = fetcherStartTimestamp;
    }

    public OutcomeType getOutcomeType() {
        return outcomeType;
    }

    public void updateLastModifiedTimeStamp(Timestamp newLastModifiedTimeStamp) {
        this.lastModifiedTimeStamp = newLastModifiedTimeStamp;
    }

    public void updateCreateTimeStamp(Timestamp newCreateTimeStamp) {
        this.createTimeStamp = newCreateTimeStamp;
    }

    public BigDecimal getRunId() {
        return runId;
    }

    public void setBatchId(BigDecimal batchId) {
        this.batchId = batchId;
    }

    public List<RegPCLTestResultDetailsEntity> getRegPclTestResultDetails() {
        return regPclTestResultDetails;
    }

    public void setTestId(BigDecimal testId) {
        this.testId = testId;
    }

    public RegPCLTestResultDetailsEntity removeRegPclTestResultDetail(RegPCLTestResultDetailsEntity regPclTestResultDetails) {
        regPclTestResultDetails.remove(regPclTestResultDetails);
        return regPclTestResultDetails;
    }

    public void setRegPclTestResultDetails(List<RegPCLTestResultDetailsEntity> regPclTestResultDetails) {
        this.regPclTestResultDetails = regPclTestResultDetails;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public RunStatusType getRunStatus() {
        return runStatus;
    }

    public RegPCLTestResultDetailsEntity addRegPclTestResultDetail(RegPCLTestResultDetailsEntity regPclTestResultDetails) {
        regPclTestResultDetails.add(regPclTestResultDetails);
        return regPclTestResultDetails;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setRunStatus(RunStatusType runStatus) {
        this.runStatus = runStatus;
    }

    public Timestamp getFetcherEndTimeStamp() {
        return fetcherEndTimeStamp;
    }

    public Timestamp getLastModifiedTimeStamp() {
        return lastModifiedTimeStamp;
    }

    public BigDecimal getFeedId() {
        return feedId;
    }

    public void setRunId(BigDecimal runId) {
        this.runId = runId;
    }

    public Timestamp getFetcherStartTimestamp() {
        return fetcherStartTimestamp;
    }

    public void setFetcherEndTimeStamp(Timestamp fetcherEndTimeStamp) {
        this.fetcherEndTimeStamp = fetcherEndTimeStamp;
    }

    public void setCreateTimeStamp(Timestamp createTimeStamp) {
        this.createTimeStamp = createTimeStamp;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public Timestamp getCreateTimeStamp() {
        return createTimeStamp;
    }

    public BigDecimal getBatchId() {
        return batchId;
    }

    public void setOutcomeType(OutcomeType outcomeType) {
        this.outcomeType = outcomeType;
    }

    public String getCreatedBy() {
        return createdBy;
    }
}"
63,"import static org.junit.Assert.assertEquals;

import java.time.ZonedDateTime;
import org.junit.Test;

public class TimeOnlyTest {

  @Test
  public void testParseTimeWithOneDecimal() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07.1"");
    assertEquals(10, time.getHour());
    assertEquals(15, time.getMinute());
    assertEquals(7, time.getSecond());
    assertEquals(100_000_000, time.getNano());
  }

  @Test
  public void testSetNegativeMinutes() {
    ZonedDateTime time = TimeOnly.setMinutes(ZonedDateTime.now(), -25);
    assertEquals(-25, time.getMinute());
  }

  @Test
  public void testFormatTimeWithOneDecimal() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07.1"");
    assertEquals(""10:15:07.1"", time.format(TimeOnly.TIME_FORMAT));
  }

  @Test
  public void testSetMinutes() {
    ZonedDateTime time = TimeOnly.setMinutes(ZonedDateTime.now(), 25);
    assertEquals(25, time.getMinute());
  }

  @Test
  public void testParseTimeWithoutDecimals() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07"");
    assertEquals(10, time.getHour());
    assertEquals(15, time.getMinute());
    assertEquals(7, time.getSecond());
    assertEquals(0, time.getNano());
  }

  @Test
  public void testGetMinutes() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07"");
    assertEquals(15, time.getMinute());
  }

  @Test
  public void testParseTimeWithDecimals() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07.123"");
    assertEquals(10, time.getHour());
    assertEquals(15, time.getMinute());
    assertEquals(7, time.getSecond());
    assertEquals(123_000_000, time.getNano());
  }

  @Test
  public void testSetInvalidSeconds() {
    ZonedDateTime time = TimeOnly.setSeconds(ZonedDateTime.now(), 61);
    assertEquals(0, time.getSecond());
    assertEquals(1, time.getMinute());
  }

  @Test
  public void testSetNegativeHour() {
    ZonedDateTime time = TimeOnly.setHour(ZonedDateTime.now(), -2);
    assertEquals(22, time.getHour());
  }

  @Test
  public void testToDate() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07"");
    assertEquals(""1970-01-01"", time.toLocalDate().toString());
  }

  @Test
  public void testGetSeconds() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07"");
    assertEquals(7, time.getSecond());
  }

  @Test
  public void testSetHour() {
    ZonedDateTime time = TimeOnly.setHour(ZonedDateTime.now(), 15);
    assertEquals(15, time.getHour());
  }

  @Test
  public void testGetHour() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07"");
    assertEquals(10, time.getHour());
  }

  @Test
  public void testSetSeconds() {
    ZonedDateTime time = TimeOnly.setSeconds(ZonedDateTime.now(), 25);
    assertEquals(25, time.getSecond());
  }

  @Test
  public void testSetTime() {
    ZonedDateTime time = TimeOnly.setTime(ZonedDateTime.now(), ""10:15:07"");
    assertEquals(10, time.getHour());
    assertEquals(15, time.getMinute());
    assertEquals(7, time.getSecond());
  }

  @Test
  public void testGetMilliseconds() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07.123"");
    assertEquals(123, time.getMillisecond());
  }

  @Test
  public void testSetInvalidHour() {
    ZonedDateTime time = TimeOnly.setHour(ZonedDateTime.now(), 61);
    assertEquals(1, time.getHour());
  }

  @Test
  public void testSetNegativeSeconds() {
    ZonedDateTime time = TimeOnly.setSeconds(ZonedDateTime.now(), -2);
    assertEquals(58, time.getSecond());
  }

  @Test
  public void setUp() {
    // No operation
  }

  @Test
  public void testSetInvalidMinutes() {
    ZonedDateTime time = TimeOnly.setMinutes(ZonedDateTime.now(), 61);
    assertEquals(1, time.getHour());
    assertEquals(1, time.getMinute());
  }

  @Test
  public void testFormatTimeNoDecimals() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07"");
    assertEquals(""10:15:07"", time.format(TimeOnly.TIME_FORMAT_NO_DECIMALS));
  }

  @Test
  public void testFormatTimeWithDecimals() {
    ZonedDateTime time = TimeOnly.parseTime(""10:15:07.123"");
    assertEquals(""10:15:07.123"", time.format(TimeOnly.TIME_FORMAT_WITH_DECIMALS));
  }

  @Test
  public void testEquals() {
    ZonedDateTime time1 = TimeOnly.parseTime(""10:15:07"");
    ZonedDateTime time2 = TimeOnly.parseTime(""10:15:07"");
    assertEquals(time1, time2);
  }
}"
64,"import java.math.BigDecimal;
import java.sql.Timestamp;

public class Feed {

    private Timestamp endDate;
    private String feedConfigId;
    private long resultCode;
    private String resultMessage;
    private BigDecimal fileCount;
    private Timestamp maxReceiptDate;
    private BigDecimal downloadSize;
    private BigDecimal feedId;
    private String configInfo;
    private long runId;
    private byte[] errors;
    private String runStatus;
    private Timestamp startDate;

    public Timestamp getEndDate() {
        return endDate;
    }

    public void setEndDate(Timestamp endDate) {
        this.endDate = endDate;
    }

    public String getFeedConfigId() {
        return feedConfigId;
    }

    public void setFeedConfigId(String feedConfigId) {
        this.feedConfigId = feedConfigId;
    }

    public long getResultCode() {
        return resultCode;
    }

    public void setResultCode(long resultCode) {
        this.resultCode = resultCode;
    }

    public String getResultMessage() {
        return resultMessage;
    }

    public void setResultMessage(String resultMessage) {
        this.resultMessage = resultMessage;
    }

    public BigDecimal getFileCount() {
        return fileCount;
    }

    public void setFileCount(BigDecimal fileCount) {
        this.fileCount = fileCount;
    }

    public Timestamp getMaxReceiptDate() {
        return maxReceiptDate;
    }

    public void setMaxReceiptDate(Timestamp maxReceiptDate) {
        this.maxReceiptDate = maxReceiptDate;
    }

    public BigDecimal getDownloadSize() {
        return downloadSize;
    }

    public void setDownloadSize(BigDecimal downloadSize) {
        this.downloadSize = downloadSize;
    }

    public BigDecimal getFeedId() {
        return feedId;
    }

    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }

    public String getConfigInfo() {
        return configInfo;
    }

    public void setConfigInfo(String configInfo) {
        this.configInfo = configInfo;
    }

    public long getRunId() {
        return runId;
    }

    public void setRunId(long runId) {
        this.runId = runId;
    }

    public byte[] getErrors() {
        return errors;
    }

    public void setErrors(byte[] errors) {
        this.errors = errors;
    }

    public String getRunStatus() {
        return runStatus;
    }

    public void setRunStatus(String runStatus) {
        this.runStatus = runStatus;
    }

    public Timestamp getStartDate() {
        return startDate;
    }

    public void setStartDate(Timestamp startDate) {
        this.startDate = startDate;
    }

}"
65,"import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import javax.imageio.IIOImage;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;
import javax.imageio.plugins.jpeg.JPEGImageWriteParam;
import javax.imageio.stream.ImageOutputStream;
import org.apache.commons.io.FileUtils;

public class WriteImageWithCompression {

  public static void main(String[] args) throws IOException {
    // Define the input image
    BufferedImage inputImage = ImageIO.read(new File(""input.jpg""));

    // Define the output image file
    File outputFile = new File(""output.jpg"");

    // Define the desired image format
    String imageFormat = ""jpg"";

    // Define the desired write compression quality
    float writeCompressionQuality = 0.7f;

    // Define the desired write compression type
    String writeCompressionType = JPEGImageWriteParam.MODE_EXPLICIT;

    // Define the desired write compression mode
    int writeCompressionMode = ImageWriteParam.MODE_EXPLICIT;

    // Create a new JPEG image writer
    ImageWriter imageWriter = ImageIO.getImageWritersByFormatName(imageFormat).next();

    // Set the write compression quality
    JPEGImageWriteParam jpegParams = (JPEGImageWriteParam) imageWriter.getDefaultWriteParam();
    jpegParams.setCompressionQuality(writeCompressionQuality);

    // Set the write compression type
    jpegParams.setCompressionType(writeCompressionType);

    // Set the write compression mode
    jpegParams.setCompressionMode(writeCompressionMode);

    // Get the image write parameters
    ImageWriteParam imageWriteParams = imageWriter.getDefaultWriteParam();

    // Set the image write parameters
    imageWriteParams.setCompressionQuality(writeCompressionQuality);
    imageWriteParams.setCompressionType(writeCompressionType);
    imageWriteParams.setCompressionMode(writeCompressionMode);

    // Open an image output stream
    try (ImageOutputStream imageOutputStream = ImageIO.createImageOutputStream(outputFile)) {
      // Write the image to the output stream
      imageWriter.setOutput(imageOutputStream);
      imageWriter.write(null, new IIOImage(inputImage, null, null), imageWriteParams);

      // Close the image writer
      imageWriter.dispose();
    }
  }
}"
66,"RangeSet<C> enclosesAll(Iterable<Range<C>> other) {
    checkNotNull(other);
    if (other.isEmpty()) {
      return immutableCopy();
    }
    for (Range<C> range : other) {
      if (!encloses(range)) {
        return ImmutableRangeSet.of();
      }
    }
    return immutableCopy();
  }"
67,
68,"import java.nio.ByteBuffer;
import java.nio.ByteBufferAllocator;

public class BufferWrapper {

    private ByteBuffer buffer;
    private ByteBufferAllocator allocator;
    private int mode;

    public static final int OUTPUT_MODE = 0;
    public static final int INPUT_MODE = 1;

    public BufferWrapper(ByteBuffer buffer, ByteBufferAllocator allocator) {
        this.buffer = buffer;
        this.allocator = allocator;
        this.mode = OUTPUT_MODE;
    }

    public void expandCapacity() {
        if (buffer.capacity() == buffer.limit()) {
            ByteBuffer newBuffer = allocator.allocate(buffer.capacity() * 2);
            buffer.flip();
            newBuffer.put(buffer);
            buffer = newBuffer;
        }
    }

    public void setOutputMode() {
        mode = OUTPUT_MODE;
    }

    public void expand() {
        expandCapacity();
        buffer.limit(buffer.capacity());
    }

    public void setInputMode() {
        mode = INPUT_MODE;
    }

    public int length() {
        return buffer.remaining();
    }

    public int available() {
        return buffer.remaining();
    }

    public void clear() {
        buffer.clear();
    }

    @Override
    public String toString() {
        return buffer.toString();
    }

    public int getMode() {
        return mode;
    }

    public void ensureCapacity(int capacity) {
        if (buffer.capacity() < capacity) {
            ByteBuffer newBuffer = allocator.allocate(capacity);
            buffer.flip();
            newBuffer.put(buffer);
            buffer = newBuffer;
        }
    }

    public int capacity() {
        return buffer.capacity();
    }
}"
69,"import java.io.IOException;
import java.nio.ByteBuffer;

import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.classification.InterfaceStability;
import org.apache.hadoop.hdfs.server.namenode.FSEditLogOp;
import org.apache.hadoop.hdfs.server.namenode.FSEditLogOpCodes;
import org.apache.hadoop.hdfs.server.namenode.LogFileInputStream;
import org.apache.hadoop.hdfs.server.namenode.LogNameSpaceManager;
import org.apache.hadoop.hdfs.server.namenode.NamespaceFile;

/**
 * Write a setString record to the log.
 */
@InterfaceAudience.Private
@InterfaceStability.Evolving
public class SetString implements FSEditLogOp {
  public final static FSEditLogOpCodes OP_CODE = FSEditLogOpCodes.SET_STRING;
  private String name;
  private String value;

  public SetString() {
  }

  public SetString(String name, String value) {
    this.name = name;
    this.value = value;
  }

  @Override
  public void write(NamespaceFile file, LogNameSpaceManager lsm) throws IOException {
    super.write(file, lsm);
    file.writeString(name);
    file.writeString(value);
  }

  @Override
  public void readFields(LogFileInputStream in, LogNameSpaceManager lsm) throws IOException {
    super.readFields(in, lsm);
    name = in.readString();
    value = in.readString();
  }

  @Override
  public long computeChecksum() {
    return super.computeChecksum()
        + name.getBytes().length
        + value.getBytes().length;
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return ""SETSTRING "" + name + "" = "" + value;
  }
}"
70,"import java.util.List;
import java.util.Stack;
import java.util.logging.Logger;

public class DataFlowGraph {
    private List<DataFlowNode> dataFlow;
    private Stack<StackObject> continueBreakReturnStack;
    private Logger LOGGER;
    private DataFlowHandler dataFlowHandler;
    private Stack<StackObject> braceStack;

    public DataFlowGraph(List<DataFlowNode> dataFlow, Stack<StackObject> continueBreakReturnStack, Logger LOGGER,
            DataFlowHandler dataFlowHandler, Stack<StackObject> braceStack) {
        this.dataFlow = dataFlow;
        this.continueBreakReturnStack = continueBreakReturnStack;
        this.LOGGER = LOGGER;
        this.dataFlowHandler = dataFlowHandler;
        this.braceStack = braceStack;
    }

    public List<StackObject> getContinueBreakReturnStack() {
        return continueBreakReturnStack;
    }

    public DataFlowNode createStartNode() {
        return dataFlowHandler.createStartNode();
    }

    public DataFlowNode createEndNode() {
        return dataFlowHandler.createEndNode();
    }

    public DataFlowNode getFirst() {
        return dataFlow.get(0);
    }

    public List<StackObject> getBraceStack() {
        return braceStack;
    }

    public String dump() {
        return dataFlowHandler.dump(dataFlow);
    }

    public DataFlowNode getLast() {
        return dataFlow.get(dataFlow.size() - 1);
    }

    public void pushOnStack(StackObject stackObject) {
        continueBreakReturnStack.push(stackObject);
    }
}"
71,"public static void set() {
        UserModel.set(null);
    }"
72,"import java.util.List;

public class SamlHandlerConfigurationDto {

    private List<String> selectedAudiences;
    private List<String> selectedClaims;
    private List<String> selectedRecipients;
    private boolean addAudienceToList;
    private boolean addClaimToList;
    private String attributeConsumingServiceIndex;
    private String assertionConsumerUrl;
    private String certificateAlias;
    private boolean enableAssertionSigning;
    private boolean enableAudiences;
    private boolean enableClaims;
    private boolean enableRecipients;
    private boolean enableSingleLogout;
    private boolean enableSignatureValidation;
    private String idPInitSSOEnabled;
    private String issuer;
    private String singleLogoutUrl;

    public List<String> getSelectedAudiences() {
        return selectedAudiences;
    }

    public void setSelectedAudiences(List<String> selectedAudiences) {
        this.selectedAudiences = selectedAudiences;
    }

    public List<String> getSelectedClaims() {
        return selectedClaims;
    }

    public void setSelectedClaims(List<String> selectedClaims) {
        this.selectedClaims = selectedClaims;
    }

    public List<String> getSelectedRecipients() {
        return selectedRecipients;
    }

    public void setSelectedRecipients(List<String> selectedRecipients) {
        this.selectedRecipients = selectedRecipients;
    }

    public boolean isAddAudienceToList() {
        return addAudienceToList;
    }

    public void setAddAudienceToList(boolean addAudienceToList) {
        this.addAudienceToList = addAudienceToList;
    }

    public boolean isAddClaimToList() {
        return addClaimToList;
    }

    public void setAddClaimToList(boolean addClaimToList) {
        this.addClaimToList = addClaimToList;
    }

    public String getAttributeConsumingServiceIndex() {
        return attributeConsumingServiceIndex;
    }

    public void setAttributeConsumingServiceIndex(String attributeConsumingServiceIndex) {
        this.attributeConsumingServiceIndex = attributeConsumingServiceIndex;
    }

    public String getAssertionConsumerUrl() {
        return assertionConsumerUrl;
    }

    public void setAssertionConsumerUrl(String assertionConsumerUrl) {
        this.assertionConsumerUrl = assertionConsumerUrl;
    }

    public String getCertificateAlias() {
        return certificateAlias;
    }

    public void setCertificateAlias(String certificateAlias) {
        this.certificateAlias = certificateAlias;
    }

    public boolean isEnableAssertionSigning() {
        return enableAssertionSigning;
    }

    public void setEnableAssertionSigning(boolean enableAssertionSigning) {
        this.enableAssertionSigning = enableAssertionSigning;
    }

    public boolean isEnableAudiences() {
        return enableAudiences;
    }

    public void setEnableAudiences(boolean enableAudiences) {
        this.enableAudiences = enableAudiences;
    }

    public boolean isEnableClaims() {
        return enableClaims;
    }

    public void setEnableClaims(boolean enableClaims) {
        this.enableClaims = enableClaims;
    }

    public boolean isEnableRecipients() {
        return enableRecipients;
    }

    public void setEnableRecipients(boolean enableRecipients) {
        this.enableRecipients = enableRecipients;
    }

    public boolean isEnableSingleLogout() {
        return enableSingleLogout;
    }

    public void setEnableSingleLogout(boolean enableSingleLogout) {
        this.enableSingleLogout = enableSingleLogout;
    }

    public boolean isEnableSignatureValidation() {
        return enableSignatureValidation;
    }

    public void setEnableSignatureValidation(boolean enableSignatureValidation) {
        this.enableSignatureValidation = enableSignatureValidation;
    }

    public String getIdPInitSSOEnabled() {
        return idPInitSSOEnabled;
    }

    public void setIdPInitSSOEnabled(String idPInitSSOEnabled) {
        this.idPInitSSOEnabled = idPInitSSOEnabled;
    }

    public String getIssuer() {
        return issuer;
    }

    public void setIssuer(String issuer) {
        this.issuer = issuer;
    }

    public String getSingleLogoutUrl() {
        return singleLogoutUrl;
    }

    public void setSingleLogoutUrl(String singleLogoutUrl) {
        this.singleLogoutUrl = singleLogoutUrl;
    }

    public String[] getSelectedAudiencesArray() {
        return selectedAudiences == null ? null : selectedAudiences.toArray(new String[0]);
    }

    public String[] getSelectedClaimsAttay() {
        return selectedClaims == null ? null : selectedClaims.toArray(new String[0]);
    }

    public String[] getSelectedRecipientsArray() {
        return selectedRecipients == null ? null : selectedRecipients.toArray(new String[0]);
    }

    public void removeAudienceFromList(String s) {
        selectedAudiences.remove(s);
    }

    public void removeClaimFromList(String s) {
        selectedClaims.remove(s);
    }

    public void removeRecipientFromList(String s) {
        selectedRecipients.remove(s);
    }

    public void clearBean() {
        selectedAudiences.clear();
        selectedClaims.clear();
        selectedRecipients.clear();
    }
}"
73,"import java.io.File;
import java.io.IOException;
import java.util.Date;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import com.google.common.io.Files;
import com.google.common.io.LineReader;

@RunWith(JUnit4.class)
public class FileUtilsTest {
  private static final String CONTENTS = ""LINE 1\nLINE 2\nLINE 3\nLINE 4\n"";
  private File folder;
  private File childFolder;
  private File childFile;
  private Date testDate;

  @Before
  public void setUp() throws IOException {
    folder = Files.createTempDir();
    childFolder = FileUtils.createTempDirInDir(folder);
    childFile = FileUtils.createTempFileInDir(folder, ""childFile"", null);
    testDate = new Date();
    Files.write(CONTENTS, childFile, FileUtils.UTF_8);
  }

  @After
  public void tearDown() {
    FileUtils.deleteRecursively(folder);
  }

  @Test
  public void deleteFile() throws IOException {
    assertTrue(childFile.exists());
    FileUtils.deleteFile(childFile);
    assertFalse(childFile.exists());
  }

  @Test(expected = IllegalArgumentException.class)
  public void deleteFile_ThrowsIfDir() throws IOException {
    assertFalse(childFolder.exists());
    try {
      FileUtils.deleteFile(childFolder);
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains(""is not a file""));
      throw e;
    }
  }

  @Test(expected = SecurityException.class)
  public void deleteFile_ThrowsIfStickyBit() throws IOException {
    childFile.setExecutable(true);
    childFile.setWritable(true);
    childFile.setReadable(true);
    assertTrue(FileUtils.setLocalDirStickyBit(folder));
    try {
      FileUtils.deleteFile(childFile);
    } catch (SecurityException e) {
      assertTrue(e.getMessage().contains(""Permission denied""));
      throw e;
    } finally {
      assertTrue(FileUtils.setLocalDirStickyBit(folder, false));
    }
  }

  @Test
  public void getLocalFileMode() {
    childFile.setExecutable(true);
    childFile.setWritable(true);
    childFile.setReadable(true);
    assertTrue(FileUtils.getLocalFileMode(childFile) == FileUtils.EXEC_READ_WRITE);
  }

  @Test(expected = IllegalArgumentException.class)
  public void changeNonExistentFile() {
    File nonExistentFile = new File(folder, ""nonExistentFile"");
    assertFalse(nonExistentFile.exists());
    try {
      FileUtils.makeFileWritable(nonExistentFile);
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains(""does not exist""));
      throw e;
    }
  }

  @Test(expected = IllegalArgumentException.class)
  public void moveNonExistentFile() {
    File nonExistentFile = new File(folder, ""nonExistentFile"");
    assertFalse(nonExistentFile.exists());
    try {
      FileUtils.moveFile(nonExistentFile, childFolder);
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains(""does not exist""));
      throw e;
    }
  }

  @Test
  public void moveFile() throws IOException {
    assertFalse(new File(childFolder, childFile.getName()).exists());
    FileUtils.moveFile(childFile, childFolder);
    assertFalse(childFile.exists());
    assertTrue(new File(childFolder, childFile.getName()).exists());
  }

  @Test
  public void createFile() throws IOException {
    File newFile = FileUtils.createTempFileInDir(folder, ""newFile"", null);
    assertTrue(newFile.exists());
    Assert.assertEquals(0L, newFile.length());
  }

  @Test(expected = IllegalArgumentException.class)
  public void createStorageDirPath_NullDir() {
    try {
      FileUtils.createStorageDirPath(null);
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains(""directory cannot be null""));
      throw e;
    }
  }

  @Test
  public void createStorageDirPath() {
    File path = FileUtils.createStorageDirPath(folder);
    assertTrue(path.exists());
    assertTrue(path.isDirectory());
    Assert.assertEquals("", path.getName());
    assertTrue(FileUtils.deleteRecursively(path));
  }

  @Test(expected = IllegalArgumentException.class)
  public void changeLocalDirPermissionTests_NullDir() {
    try {
      FileUtils.setLocalDirStickyBit(null);
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains(""directory cannot be null""));
      throw e;
    }
  }

  @Test
  public void changeLocalDirPermissionTests_SetsSticky() {
    assertTrue(FileUtils.setLocalDirStickyBit(folder));
    assertTrue(FileUtils.getLocalFileMode(folder) == FileUtils.STICKY_DIR);
  }

  @Test
  public void changeLocalDirPermissionTests_UnsetSticky() {
    FileUtils.setLocalDirStickyBit(folder);
    assertTrue(FileUtils.getLocalFileMode(folder) == FileUtils.STICKY_DIR);
    assertTrue(FileUtils.setLocalDirStickyBit(folder, false));
    assertTrue(FileUtils.getLocalFileMode(folder) == FileUtils.READ_ONLY_DIR);
  }

  @Test
  public void concurrentCreateStorageDirPath() throws InterruptedException {
    final int numThreads = 100;
    final Object lock = new Object();
    final File[] paths = new File[numThreads];
    Thread[] threads = new Thread[numThreads];

    for (int i = 0; i < threads.length; i++) {
      final int threadIndex = i;
      threads[i] = new Thread(new Runnable() {
        @Override
        public void run() {
          synchronized (lock) {
            paths[threadIndex] = FileUtils.createStorageDirPath(folder);
          }
        }
      });
    }

    for (Thread thread : threads) {
      thread.start();
    }
    for (Thread thread : threads) {
      thread.join();
    }

    for (File path : paths) {
      Assert.assertEquals("", path.getName());
      assertTrue(path.exists());
      assertTrue(path.isDirectory());
      assertTrue(FileUtils.deleteRecursively(path));
    }
  }

  @Test
  public void createDir() {
    File newDir = FileUtils.createTempDirInDir(folder);
    assertTrue(newDir.exists());
    assertTrue(newDir.isDirectory());
    assertTrue(FileUtils.deleteRecursively(newDir));
  }

  @Test
  public void createBlockPath() {
    List<File> wholePath = Lists.newArrayList();
    File p = new File(folder, ""a"");
    wholePath.add(p);
    for (int i = 1; i < 10; i++) {
      p = new File(p, Integer.toString(i));
      wholePath.add(p);
    }
    Assert.assertEquals(Joiner.on(""/"").join(wholePath),
        FileUtils.createBlockPath(wholePath).toString());
  }

  @Test
  public void changeLocalFilePermission() throws IOException {
    assertTrue(childFile.canRead());
    assertTrue(childFile.canWrite());
    FileUtils.makeFileReadOnly(childFile);
    assertFalse(childFile.canWrite());
    assertTrue(childFile.canRead());
    FileUtils.makeFileWritable(childFile);
    assertTrue(childFile.canWrite());
    assertTrue(childFile.canRead());
  }

  @Test
  public void deletePathRecursively() throws IOException {
    File file = new File(folder, ""file.txt"");
    Files.write(CONTENTS, file, FileUtils.UTF_8);
    File subdir = new File(folder, ""subdir"");
    subdir.mkdir();
    File nestedFile = new File(subdir, ""nestedFile.txt"");
    Files.write(CONTENTS, nestedFile, FileUtils.UTF_8);
    File otherNestedFile = new File(subdir, ""otherNestedFile.txt"");
    Files.write(CONTENTS, otherNestedFile, FileUtils.UTF_8);"
74,"import java.util.Map;
import java.util.Set;

public class OperationStatisticsCollector {

    private final Map<OperationSignature, Map<String, OperationStats>> operations;
    private final Map<FieldSignature, Set<String>> fields;
    private final Map<String, ClassStats> nestedClasses;

    public OperationStatisticsCollector(
            Map<OperationSignature, Map<String, OperationStats>> operations,
            Map<FieldSignature, Set<String>> fields,
            Map<String, ClassStats> nestedClasses) {
        this.operations = operations;
        this.fields = fields;
        this.nestedClasses = nestedClasses;
    }

    public boolean containsOperation(String name, OperationSignature signature) {
        Map<String, OperationStats> methods = operations.get(signature);
        return methods != null && methods.containsKey(name);
    }

    public double compute(String name, OperationSignature signature) {
        Map<String, OperationStats> methods = operations.get(signature);
        if (methods == null) {
            return 0.0;
        }
        OperationStats stats = methods.get(name);
        if (stats == null) {
            return 0.0;
        }
        return stats.compute();
    }

    public void addOperation(String typeName, String name, OperationSignature signature) {
        Map<String, OperationStats> methods = operations.get(signature);
        if (methods == null) {
            methods = new HashMap<>();
            operations.put(signature, methods);
        }
        methods.put(name, new OperationStats(typeName));
    }

    public void addField(FieldSignature signature, String typeName) {
        Set<String> fieldNames = fields.get(signature);
        if (fieldNames == null) {
            fieldNames = new HashSet<>();
            fields.put(signature, fieldNames);
        }
        fieldNames.add(typeName);
    }

    public ClassStats getNestedClassStats(String name) {
        return nestedClasses.get(name);
    }
}"
75,"import com.google.gerrit.entities.AccountGroup;
import com.google.gerrit.entities.GroupReference;
import com.google.gerrit.entities.NotifyConfig;
import com.google.gerrit.entities.Project;
import com.google.gerrit.entities.StoredSettings;
import com.google.gerrit.entities.Team;
import com.google.gerrit.exceptions.NoSuchGroupException;
import com.google.gerrit.exceptions.NoSuchProjectException;
import com.google.gerrit.metrics.Counter1;
import com.google.gerrit.server.account.GroupBackend;
import com.google.gerrit.server.account.Realm;
import com.google.gerrit.server.account.UseLegacyRealm;
import com.google.gerrit.server.config.AllUsersName;
import com.google.gerrit.server.config.ConfigResource;
import com.google.gerrit.server.config.GerritInstanceId;
import com.google.gerrit.server.config.PluginConfigFactory;
import com.google.gerrit.server.config.ProjectOwnerGroupsProvider;
import com.google.gerrit.server.config.TrackingFooters;
import com.google.gerrit.server.extensions.events.GitReferenceUpdated;
import com.google.gerrit.server.group.db.GroupsUpdate;
import com.google.gerrit.server.group.db.InternalGroupUpdate;
import com.google.gerrit.server.group.db.ReloadGroupsOrigin;
import com.google.gerrit.server.git.MetaDataUpdate;
import com.google.gerrit.server.group.GroupJson;
import com.google.gerrit.server.group.GroupResource;
import com.google.gerrit.server.group.GroupsCollection;
import com.google.gerrit.server.group.SystemGroupBackend;
import com.google.gerrit.server.index.account.AccountIndexCollection;
import com.google.gerrit.server.mail.receive.MailReceiver;
import com.google.gerrit.server.notedb.ReviewerStateInternal;
import com.google.gerrit.server.permissions.DefaultPermissionBackend;
import com.google.gerrit.server.permissions.PermissionBackend;
import com.google.gerrit.server.permissions.PermissionBackendCollection;
import com.google.gerrit.server.project.ProjectCache;
import com.google.gerrit.server.project.ProjectState;
import com.google.gerrit.server.project.ProjectsCollection;
import com.google.gerrit.server.project.ProjectState.RefFilter;
import com.google.gerrit.server.schemads.SchemaCreator;
import com.google.gerrit.server.schemads.SchemaCreatorManager;
import com.google.gerrit.server.securestore.SecureStore;
import com.google.gerrit.server.securestore.SecureStoreProvider;
import com.google.gerrit.server.ssh.SshInfo;
import com.google.gerrit.server.util.ManualRequestContext;
import com.google.gerrit.server.util.time.TimeUtil;
import com.google.gerrit.sshd.ServerCommand;
import com.google.gerrit.sshd.SshScope;
import com.google.gerrit.util.cli.CmdLineParser;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Scopes;
import com.google.inject.Singleton;
import com.google.inject.TypeLiteral;
import com.google.inject.assistedinject.FactoryModuleBuilder;
import com.google.inject.multibindings.Multibinder;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.apache.log4j.Logger;

public class SshModule extends AbstractModule {
  private final boolean deleteRepositoryRole;
  private final List<String> getAllUsernames;
  private final List<UserModel> getAllUsers;
  private final UserModel getUserModel;
  private final boolean updateUserModel;
  private final boolean updateUserModel;
  private final TeamModel getTeamModel;
  private final boolean updateTeamModel;
  private final boolean updateTeamModel;
  private final boolean isInternalAccount;
  private final List<String> getTeamNamesForRepositoryRole;
  private final boolean deleteTeam;
  private final List<String> getUsernamesForRepositoryRole;
  private final boolean deleteTeamModel;
  private final boolean deleteUser;
  private final void setup;
  private final boolean renameRepositoryRole;
  private final List<String> getAllTeamNames;
  private final boolean updateTeamModels;

  public SshModule(
      boolean deleteRepositoryRole,
      List<String> getAllUsernames,
      List<UserModel> getAllUsers,
      UserModel getUserModel,
      boolean updateUserModel,
      boolean updateUserModel,
      TeamModel getTeamModel,
      boolean updateTeamModel,
      boolean updateTeamModel,
      boolean isInternalAccount,
      List<String> getTeamNamesForRepositoryRole,
      boolean deleteTeam,
      List<String> getUsernamesForRepositoryRole,
      boolean deleteTeamModel,
      UserManager start,
      void setUserService,
      IUserService createUserService,
      List<TeamModel> getAllTeams,
      String getCookie,
      boolean deleteUserModel,
      UserManager stop,
      boolean deleteUser,
      void setup,
      boolean renameRepositoryRole,
      List<String> getAllTeamNames,
      boolean updateTeamModels) {
    this.deleteRepositoryRole = deleteRepositoryRole;
    this.getAllUsernames = getAllUsernames;
    this.getAllUsers = getAllUsers;
    this.getUserModel = getUserModel;
    this.updateUserModel = updateUserModel;
    this.updateUserModel = updateUserModel;
    this.getTeamModel = getTeamModel;
    this.updateTeamModel = updateTeamModel;
    this.updateTeamModel = updateTeamModel;
    this.isInternalAccount = isInternalAccount;
    this.getTeamNamesForRepositoryRole = getTeamNamesForRepositoryRole;
    this.deleteTeam = deleteTeam;
    this.getUsernamesForRepositoryRole = getUsernamesForRepositoryRole;
    this.deleteTeamModel = deleteTeamModel;
    this.deleteUser = deleteUser;
    this.setup = setup;
    this.renameRepositoryRole = renameRepositoryRole;
    this.getAllTeamNames = getAllTeamNames;
    this.updateTeamModels = updateTeamModels;
  }

  @Override
  public void configure() {
    bind(SshScope.class).in(Scopes.SINGLETON);
    bind(PermissionBackend.class).to(DefaultPermissionBackend.class).in(Scopes.SINGLETON);
    bind(PermissionBackendCollection.class).in(Scopes.SINGLETON);
    bind(TrackingFooters.class).toInstance(TrackingFooters.DISABLED);
    bind(TimeUtil.SystemClock.class).to(TimeUtil.StandardTimeClock.class);

    install(
        new FactoryModuleBuilder()
            .implement(ServerCommand.Factory.class, SshServerCommand.Factory.class)
            .build(ServerCommand.AssistedFactory.class));
    install(
        new FactoryModuleBuilder()
            .implement(CmdLineParser.Factory.class, SshCmdLineParser.Factory.class)
            .build(CmdLineParser.AssistedFactory.class));

    bind(SshInfo.class).in(Scopes.SINGLETON);
    bind(SshCreateExtension.class).in(Scopes.SINGLETON);
    bind(SshDaemon.class).in(Scopes.SINGLETON);
    bind(SshDaemonImpl.class).in(Scopes.SINGLETON);

    bind(SecureStore.class)
        .toProvider(SecureStoreProvider.class)
        .in(Scopes.SINGLETON);

    bind(SchemaCreatorManager.class).in(Scopes.SINGLETON);
    bind(SchemaCreator.class).to(SchemaCreatorManager.class);

    bind(ProjectOwnerGroupsProvider.class).in(Scopes.SINGLETON);

    bind(GroupBackend.class).to(SystemGroupBackend.class).in(Scopes.SINGLETON);
    bind(GroupsCollection.class).to(SystemGroupBackend.class).in(Scopes.SINGLETON);

    bind(new TypeLiteral<Collection<ReloadGroupsOrigin>>() {})
        .toInstance(Collections.singleton(ReloadGroupsOrigin.COMMAND_LINE));

    Multibinder.newSetBinder(binder(), ReloadGroupsOrigin.class);

    bind(PluginConfigFactory.class).in(Scopes.SINGLETON);
    bind(GroupsUpdate.Factory.class).in(Scopes.SINGLETON);
    bind(InternalGroupUpdate.Factory.class).in(Scopes.SINGLETON);
    bind(AccountIndexCollection.class"
76,"import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class GenericservletExampleLogWithFilterNameFilter implements Filter {
    private FilterConfig filterConfig;

    @Override
    public void init(FilterConfig filterConfig) {
        this.filterConfig = filterConfig;
        try {
            // Get file from CLASSPATH_PREFIX
            String key = filterConfig.getInitParameter(""file"");
            URL url = this.getClass().getClassLoader().getResource(key);
            // Load file
            loadResource(url);
        } catch (IOException e) {
            filterConfig.getServletContext().log(filterConfig.getFilterName(), e);
        }
    }

    private void loadResource(URL url) throws IOException {
        if (url == null) {
            throw new IOException(""file not found"");
        }
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)
            throws IOException, ServletException {
        try {
            filterChain.doFilter(servletRequest, servletResponse);
        } catch (IOException e) {
            filterConfig.getServletContext().log(filterConfig.getFilterName(), e);
            throw e;
        } catch (ServletException e) {
            filterConfig.getServletContext().log(filterConfig.getFilterName(), e);
            throw e;
        }
    }

    @Override
    public void destroy() {
    }
}"
77,"Response response = new Response();
    if (LOG.isInfoEnabled()) {
      LOG.info(
          String.format(placeHolder, _call.getMethodDescriptor().getFullName(), _call.getRequest()));
    }
    // Send an empty response.
    return response;"
78,"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;

public class Log {
    private boolean consoleMode;
    private org.apache.log4j.Logger logger;
    private int maxValue;
    private boolean showProgress;
    private ProgressMonitor progressMonitor;
    private StringBuffer log;
    private String currentMessage;
    private List<String> debugMessages;
    private TreeSet<String> warnings;
    private int curValue;
    private HashMap<String,Integer> warningCounts;

    public void setConsoleModeAndParseShowProgress(boolean consoleMode, String showProgress) {
        setConsoleMode(consoleMode);
        setShowProgress(showProgress);
    }

    public void setShowProgress(String showProgress) {
        this.showProgress = Boolean.parseBoolean(showProgress);
    }

    public void setCurrentMessage(String currentMessage) {
        this.currentMessage = currentMessage;
    }

    public int getMaxValue() {
        return maxValue;
    }

    public String getLog() {
        return log.toString();
    }

    public void logWarning(String warning) {
        warnings.add(warning);
        String key = warning.substring(0, warning.indexOf(' ')); // get the warning type from the warning message
        Integer count = warningCounts.get(key);
        if (count == null) count = 0;
        count++;
        warningCounts.put(key, count);
    }

    public ArrayList<String> getWarnings() {
        ArrayList<String> list = new ArrayList<String>();
        list.addAll(warnings);
        return list;
    }

    public void logDebug(String debugMessage) {
        debugMessages.add(debugMessage);
    }

    public ArrayList<String> getMessages() {
        ArrayList<String> list = new ArrayList<String>();
        list.addAll(debugMessages);
        return list;
    }

    public boolean isConsoleMode() {
        return consoleMode;
    }

    public List<String> getDebugMessages() {
        return debugMessages;
    }

    public void setMaxValue(int maxValue) {
        this.maxValue = maxValue;
    }

    public void incrementCurValue() {
        curValue++;
    }

    public boolean isRunningOnServer() {
        return true;
    }

    public String getCurrentMessage() {
        return currentMessage;
    }

    public void setConsoleMode(boolean consoleMode) {
        this.consoleMode = consoleMode;
    }

    public int getCurValue() {
        return curValue;
    }

    public boolean isShowProgress() {
        return showProgress;
    }

    public double getPercentComplete() {
        return (double) curValue / maxValue;
    }

    // constructor
    public Log(boolean consoleMode, org.apache.log4j.Logger logger) {
        this.consoleMode = consoleMode;
        this.logger = logger;
        maxValue = -1;
        showProgress = false;
        progressMonitor = null;
        log = new StringBuffer();
        currentMessage = "";
        debugMessages = new ArrayList<String>();
        warnings = new TreeSet<String>();
        curValue = 0;
        warningCounts = new HashMap<String,Integer>();
    }
}"
79,"public synchronized void addDownload(FileMapper fileMapper, String escapedJson, Logger log) {
  if (fileMapper.m_downloadId == null)
    return; // already deleted

  String id = normalizeId(fileMapper);
  if (id == null)
    return; // invalid torrent

  if (!addComplete(escapedJson, id, log))
    return; // failed to add to libtorrent

  if (fileMapper.m_downloadedLast == null)
    return; // already paused

  if (!m_torrentVarMap.add(id, escapedJson))
    log.warning(""Failed to update m_torrentVarMap"");
}"
80,
81,
82,"import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;

public class JpegWriter {

    private String imageFormat;
    private float writeCompressionQuality;
    private String writeCompressionType;
    private int writeCompressionMode;

    public static final String DEFAULT_IMAGE_FORMAT = ""jpeg"";

    public void setWriteCompressionMode(int writeCompressionMode) {
        this.writeCompressionMode = writeCompressionMode;
    }

    public void setWriteCompressionType(String writeCompressionType) {
        this.writeCompressionType = writeCompressionType;
    }

    public void setWriteCompressionQuality(float writeCompressionQuality) {
        this.writeCompressionQuality = writeCompressionQuality;
    }

    public void write(BufferedImage bufferedImage, String filePath) throws IOException {
        write(bufferedImage, filePath, imageFormat, writeCompressionMode);
    }

    public void write(BufferedImage bufferedImage, String filePath, String imageFormat) throws IOException {
        write(bufferedImage, filePath, imageFormat, writeCompressionQuality);
    }

    public void write(BufferedImage bufferedImage, String filePath, String imageFormat, float writeCompressionQuality) throws IOException {
        write(bufferedImage, filePath, imageFormat, writeCompressionQuality, writeCompressionType);
    }

    public void write(BufferedImage bufferedImage, String filePath, String imageFormat, float writeCompressionQuality, String writeCompressionType)
            throws IOException {
        ImageWriter imageWriter = lookupImageWriterForFormat(imageFormat);

        ImageWriteParam imageWriteParam = imageWriter.getDefaultWriteParam();
        imageWriteParam.setCompressionMode(writeCompressionMode);
        imageWriteParam.setCompressionQuality(writeCompressionQuality);
        imageWriteParam.setCompressionType(writeCompressionType);

        File file = new File(filePath);
        ImageIO.write(bufferedImage, imageFormat, file, imageWriteParam);
    }

    public void write(Image image, String filePath) throws IOException {
        write(image, filePath, imageFormat, writeCompressionMode);
    }

    public void write(Image image, String filePath, String imageFormat) throws IOException {
        write(image, filePath, imageFormat, writeCompressionQuality);
    }

    public void write(Image image, String filePath, String imageFormat, float writeCompressionQuality) throws IOException {
        write(image, filePath, imageFormat, writeCompressionQuality, writeCompressionType);
    }

    public void write(Image image, String filePath, String imageFormat, float writeCompressionQuality, String writeCompressionType)
            throws IOException {
        BufferedImage bufferedImage = new BufferedImage(image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_INT_RGB);
        bufferedImage.getGraphics().drawImage(image, 0, 0, null);
        write(bufferedImage, filePath, imageFormat, writeCompressionQuality, writeCompressionType);
    }

    public ImageWriteParam getImageWriteParameters() {
        ImageWriter imageWriter = lookupImageWriterForFormat(imageFormat);
        return imageWriter.getDefaultWriteParam();
    }

    private ImageWriter lookupImageWriterForFormat(String imageFormat) {
        Iterator<ImageWriter> imageWriters = ImageIO.getImageWritersByFormatName(imageFormat);
        if (imageWriters.hasNext()) {
            return imageWriters.next();
        } else {
            throw new IllegalArgumentException(""Unsupported image format: "" + imageFormat);
        }
    }
}"
83,"import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class OMAlogics {

    public static final String OMA_REDIRECT_LINK = ""omaredirect.do"";
    public static final String SITE_PARAM = ""path"";
    public static final String removePath = ""/"";



    public static String createOmaLink(String site, LinkedHashMap<String, String> params) throws MalformedURLException {
        String queryString = createQueryString(params);
        return createOmaLink(site, queryString);
    }



    public static String createQueryString(LinkedHashMap<String, String> params) {

        List<String> keyList = getKeyList(params);
        StringBuilder query = new StringBuilder();
        query.append('?');
        for (String key : keyList) {
            query.append(encode(key));
            query.append('=');
            String value = params.get(key);
            if (value != null) {
                query.append(encode(value));
            }
            query.append('&');
        }
        query.deleteCharAt(query.length() - 1);
        return query.toString();
    }

    public static HashMap<String, String> getParameterMap(String query) {
        HashMap<String, String> map = new HashMap<String, String>();
        String[] pairs = query.split(""&"");
        for (String pair : pairs) {
            String[] keyValue = pair.split(""="");
            map.put(keyValue[0], keyValue[1]);
        }
        return map;
    }

    public static ArrayList<String> getKeyList(HashMap<String, String> map) {
        ArrayList<String> keyList = new ArrayList<String>();
        for (String key : map.keySet()) {
            keyList.add(key);
        }
        return keyList;
    }

    public static String encode(String s) {
        try {
            return URLEncoder.encode(s, ""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(""UTF-8 is not supported?"", e);
        }
    }

    public static String createOmaLink(String site, String queryString) throws MalformedURLException {
        return conditionallyPrependHttp(new URL(site + removePath)) + queryString;
    }

    public static String conditionallyPrependHttp(URL url) throws MalformedURLException {
        String s = url.toString();
        if (!s.startsWith(""http://"") && !s.startsWith(""https://"")) {
            return ""http://"" + s;
        }
        return s;
    }

    public static String getDelimiter() {
        return ""&"";
    }
}"
84,"private static void setThreadingParametersForPort(String port, EngineConfig callingEngineConfig, ThreadPool tPool, Bus bus) {
  Bus busOfServerEngine = initBusOfServerEngine(port, bus);
  JettyHTTPServerEngine jettyHTTPServerEngine = retrieveJettyHTTPServerEngine(port, busOfServerEngine);
  if (jettyHTTPServerEngine != null) {
    setThreadingParametersForPort(port, callingEngineConfig, jettyHTTPServerEngine, tPool);
  } else {
    LOGGER.info(""Unable to retrieve JettyHTTPServerEngine for port "" + port + "" to set threading parameters during runtime reconfiguration."");
    LOGGER.info(""Setting the fall back threading parameters instead "" + fallbackThreadingParameters.getThreadParameters());
    setThreadingParametersForPort(port, callingEngineConfig, fallbackThreadingParameters, tPool);
  }
}"
85,
86,"import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMap.Builder;
import fr.jmini.emq.common.elasticsearch.bean.ELEvaluator;
import fr.jmini.emq.common.elasticsearch.functions.Functions;
import org.elasticsearch.script.CompiledScript;
import org.elasticsearch.script.ScriptContext;
import org.elasticsearch.script.ScriptService;
import org.elasticsearch.script.ScriptType;

import java.util.Map;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

public class MyELEvaluator {

  private final ELEvaluator current;
  private final ScriptService scriptService;
  private final Map<String, Object> vars;

  public MyELEvaluator(
      final ELEvaluator current,
      final ScriptService scriptService,
      final Map<String, Object> vars) {
    checkState(
        current.getCurrentContext().getScriptContext().equals(ScriptContext.Standard.CHECK),
        ""context must be check"");
    this.current = current;
    this.scriptService = scriptService;
    this.vars = checkNotNull(vars);
    Functions.addFunction(current, scriptService, VarsFunction.class);
  }

  public void setVariables(final Map<String, Object> vars) {
    if (!vars.isEmpty()) {
      checkState(
          current.getCurrentContext().getScriptContext().equals(ScriptContext.Standard.CHECK),
          ""context must be check"");
      final Builder<String, Object> builder = ImmutableMap.builder();
      builder.putAll(this.vars);
      builder.putAll(vars);
      current.getCurrentContext().getVars().put(""vars"", builder.build());
    }
  }

  public void resetContext() {
    current.resetCurrentContext();
  }

  public <T> T evaluate<T>(final String script) {
    return evaluate(ScriptType.INLINE, script);
  }

  public <T> T evaluate<T>(final ScriptType scriptType, String script) {
    final CompiledScript compiledScript = current.getCurrentContext().compile(scriptType, script);

    return current.getCurrentContext().run(compiledScript, vars, current.getCurrentContext().getScriptContext());
  }

  public static class VarsFunction implements Functions.Function {

    @Override
    public String getName() {
      return ""vars"";
    }

    @Override
    public Object resolve(final Context context, final Map<String, Object> args) {
      checkNotNull(context);
      return context.getVariable(""vars"");
    }
  }
}"
87,"import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.UTXO;
import org.bitcoinj.core.UTXOId;
import org.bitcoinj.script.Script;
import org.bitcoinj.script.ScriptBuilder;

import java.math.BigInteger;

public class UTXOBuilder {

  public static UTXO utxo(long index, BigInteger value, byte[] scriptBytes, long serialVersionUID, int height, Sha256Hash hash) {
    UTXO utxo = new UTXO();
    utxo.setHash(hash);
    utxo.setOutputIndex(index);
    UTXOId id = new UTXOId(hash, index);
    utxo.setScript(ScriptBuilder.createOutputScript(Script.ScriptType.P2PKH, value));
    utxo.setId(id);
    utxo.setHeight(height);
    utxo.setValue(value);
    utxo.setSerialVersionUID(serialVersionUID);
    return utxo;
  }
}"
88,"public class Player {

    float xStartPos, yStartPos, zStartPos;
    float xPos, yPos, zPos;
    float walkbiasangle = 0, walkbias = 0;
    float rotAngle = 0;
    float heading = 0;
    float MOVE_FORWARD_SPEED = 0.2f;
    float MOVE_BACKWARD_SPEED = 0.1f;
    float STRAFE_SPEED = 0.15f;
    float ROTATE_SPEED = 0.03f;

    FloatBuffer lightPosition = Buffers.newDirectFloatBuffer(4);
    FloatBuffer whiteLight = Buffers.newDirectFloatBuffer(4);
    FloatBuffer lModelAmbient = Buffers.newDirectFloatBuffer(4);
    int BULLET_INTERVAL = 10;
    long bulletTime = 0;
    int MAX_BULLETS = 20;
    boolean[] monstersLiving = new boolean[MAX_MONSTERS];
    Monster[] monsters = new Monster[MAX_MONSTERS];
    ArrayList<Bullet> bullets = new ArrayList<>();
    Level level;

    public Player(String filename) {
        level = Level.LoadFromFile(filename);

        //Set up lighting variables
        whiteLight.put(new float[]{1.0f, 1.0f, 1.0f, 1.0f}).flip();
        lModelAmbient.put(new float[]{0.5f, 0.5f, 0.5f, 1.0f}).flip();
        lightPosition.put(new float[]{0, 0, 0, 1}).flip();

        GL11.glLightfv(GL11.GL_LIGHT1, GL11.GL_POSITION, lightPosition);
        GL11.glLightfv(GL11.GL_LIGHT1, GL11.GL_AMBIENT, lModelAmbient);
        GL11.glLightfv(GL11.GL_LIGHT1, GL11.GL_DIFFUSE, whiteLight);
    }

    public void restart() {
        xPos = xStartPos;
        yPos = yStartPos;
        zPos = zStartPos;
        heading = 0;
        rotAngle = 0;
        walkbiasangle = 0;
        walkbias = 0;
        bullets.clear();
        level.reload();
    }

    public void start() {
    }

    public void update() {
        //Update the player's position
        xPos += (float) (Math.sin(heading) * MOVE_FORWARD_SPEED);
        yPos += (float) (Math.cos(heading) * MOVE_FORWARD_SPEED);

        //Keep the player within the level
        if (xPos < 0) xPos = 0;
        if (xPos > level.getWidth()) xPos = level.getWidth();
        if (yPos < 0) yPos = 0;
        if (yPos > level.getHeight()) yPos = level.getHeight();

        //Update the player's rotation
        rotAngle += (float) (Math.sin(heading) * ROTATE_SPEED);
        heading += (float) (Math.cos(heading) * ROTATE_SPEED);

        //Update the player's walk bias
        walkbiasangle += 0.1;
        walkbias = (float) (Math.sin(walkbiasangle));

        //Update the player's bullets
        for (int i = 0; i < bullets.size(); i++) {
            bullets.get(i).update();
        }

        //Check if the player has collided with any monsters
        for (int i = 0; i < MAX_MONSTERS; i++) {
            if (monstersLiving[i] && monsters[i].collidesWith(this)) {
                restart();
            }
        }

        //Check if the player has finished the level
        if (xPos == level.getGoalX() && yPos == level.getGoalY()) {
            isFinished = true;
        }
    }

    public void render() {
        //Draw the player's body
        GL11.glPushMatrix();
        GL11.glTranslatef(xPos, yPos, zPos);
        GL11.glRotatef(rotAngle * 57.2957795f, 0, 0, 1);
        GL11.glRotatef(walkbiasangle * 10, 1, 0, 0);
        GL11.glTranslatef(0, walkbias, 0);

        //Draw the player's head
        GL11.glPushMatrix();
        GL11.glTranslatef(0, 0.5f, 0);
        GL11.glScalef(0.5f, 0.5f, 0.5f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        //Draw the player's body
        GL11.glPushMatrix();
        GL11.glTranslatef(0, -0.5f, 0);
        GL11.glScalef(0.5f, 1.0f, 0.5f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        //Draw the player's legs
        GL11.glPushMatrix();
        GL11.glTranslatef(-0.25f, -1.0f, 0);
        GL11.glScalef(0.5f, 1.0f, 0.5f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        GL11.glPushMatrix();
        GL11.glTranslatef(0.25f, -1.0f, 0);
        GL11.glScalef(0.5f, 1.0f, 0.5f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        //Draw the player's arms
        GL11.glPushMatrix();
        GL11.glTranslatef(-0.5f, -0.5f, 0);
        GL11.glScalef(0.5f, 1.0f, 0.5f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        GL11.glPushMatrix();
        GL11.glTranslatef(0.5f, -0.5f, 0);
        GL11.glScalef(0.5f, 1.0f, 0.5f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        //Draw the player's gun
        GL11.glPushMatrix();
        GL11.glTranslatef(0, -0.5f, 0.5f);
        GL11.glScalef(0.25f, 0.25f, 0.25f);
        glut.glutSolidCube(1.0f);
        GL11.glPopMatrix();

        //Draw the player's bullets
        for (int i = 0; i < bullets.size(); i++) {
            bullets.get(i).render();
        }

        GL11.glPopMatrix();
    }

    public void turnRight() {
        heading -= 0.1f;
    }

    public void turnLeft() {
        heading += 0.1f;
    }

    public void walkForwards() {
        xPos += (float) (Math.sin(heading) * MOVE_FORWARD_SPEED);
        yPos += (float) (Math.cos(heading) * MOVE_FORWARD_SPEED);
    }

    public void walkBackwards() {
        xPos -= (float) (Math.sin(heading) * MOVE_BACKWARD_SPEED);
        yPos -= (float) (Math.cos(heading) * MOVE_BACKWARD_SPEED);
    }

    public void strafeLeft() {
        xPos += (float) (Math.cos(heading) * STRAFE_SPEED);
        yPos -= (float) (Math.sin(heading) * STRAFE_SPEED);
    }

    public void strafeRight() {
        xPos -= (float) (Math.cos(heading) * STRAFE_SPEED);
        yPos += (float) (Math.sin(heading) * STRAFE_SPEED);
    }

    public void fire() {
        if (System.currentTimeMillis() - bulletTime > BULLET_INTERVAL) {
            bullets.add(new Bullet(xPos, yPos, heading));
            bulletTime = System.currentTimeMillis();
        }
    }

    public boolean isFinished() {
        return xPos == level.getGoalX() && yPos == level.getGoalY();
    }

    public static void main(String[] args) {
        Player player = new"
89,"import com.google.api.client.util.Key;
import java.util.List;

public class GetOfferDetailsResponse {
    @Key
    public Return Return;

    public static class Return {
        @Key
        public DetailOfferData DetailOfferData;
    }

    public static class DetailOfferData {
        @Key
        public List<SourceGeos> SourceGeos;
        @Key
        public Seo Seo;
        @Key
        public Merchant Merchant;
        @Key
        public List<TargetGeos> TargetGeos;
        @Key
        public List<OfferMedia> OfferMedia;
        @Key
        public FulfillmentPartner FulfillmentPartner;
        @Key
        public List<Products> Products;
        @Key
        public List<RedemptionAddresses> RedemptionAddresses;
    }
    public static class SourceGeos {
        @Key
        public List<Geo> Geo;
    }

    public static class Seo {
        @Key
        public String SchemaOrgOfferUrl;
        @Key
        public String SchemaOrgMerchantUrl;
        @Key
        public String GoogleMerchantUrl;
    }

    public static class Merchant {
        @Key
        public List<Addresses> Addresses;
    }

    public static class Addresses {
    }

    public static class TargetGeos {
        @Key
        public List<Geo> Geo;
    }

    public static class Geo {
        @Key
        public String Country;
        @Key
        public String Region;
        @Key
        public String City;
    }

    public static class OfferMedia {
        @Key
        public List<OfferImage> OfferImage;
    }

    public static class OfferImage {
        @Key
        public List<Entry> Entry;
    }

    public static class Entry {
        @Key
        public Value Value;
    }

    public static class Value {
        @Key
        public List<Item> Item;
    }

    public static class Item {
        @Key
        public String Key;
        @Key
        public String Value;
    }

    public static class FulfillmentPartner {
    }

    public static class Products {
        @Key
        public List<Product> Product;
    }
    public static class Product {}

    public static class RedemptionAddresses {
        @Key
        public List<RedemptionAddress> RedemptionAddress; 
    }

    public static class RedemptionAddress {}

}"
90,"import com.google.api.client.util.Base64;
import com.google.api.gax.rpc.ApiException;
import com.google.cloud.pubsublite.AdminClient;
import com.google.cloud.pubsublite.AdminClientSettings;
import com.google.cloud.pubsublite.CloudRegion;
import com.google.cloud.pubsublite.CloudRegionOrZone;
import com.google.cloud.pubsublite.CloudZone;
import com.google.cloud.pubsublite.ProjectNumber;
import com.google.cloud.pubsublite.ReservationPath;
import com.google.cloud.pubsublite.ReservationPathOrName;
import com.google.cloud.pubsublite.SubscriptionName;
import com.google.cloud.pubsublite.SubscriptionPath;
import com.google.cloud.pubsublite.TopicName;
import com.google.cloud.pubsublite.TopicPath;
import com.google.cloud.pubsublite.proto.DeliveryConfig;
import com.google.cloud.pubsublite.proto.Subscription;
import com.google.cloud.pubsublite.proto.Subscription.DeliveryRequirement;
import com.google.protobuf.ByteString;
import com.google.pubsub.v1.SubscriptionName as V1SubscriptionName;
import com.google.pubsub.v1.TopicName as V1TopicName;
import java.util.concurrent.ExecutionException;

public class SubscribeWithDeliveryConfigExample {

  public static void main(String... args) throws Exception {
    // TODO(developer): Replace these variables before running the sample.
    String cloudRegion = ""your-cloud-region"";
    char zoneId = 'b';
    long projectNumber = Long.parseLong(""123456789"");
    String subscriptionId = ""your-subscription-id"";
    String topicId = ""your-topic-id"";
    subscribeWithDeliveryConfigExample(cloudRegion, zoneId, projectNumber, subscriptionId, topicId);
  }

  public static void subscribeWithDeliveryConfigExample(
      String cloudRegion, char zoneId, long projectNumber, String subscriptionId, String topicId)
      throws ApiException, ExecutionException, InterruptedException {
    CloudRegionOrZone location;
    if (zoneId != 0) {
      location = CloudRegionOrZone.of(CloudRegion.of(cloudRegion), CloudZone.of(zoneId));
    } else {
      location = CloudRegionOrZone.of(CloudRegion.of(cloudRegion));
    }

    TopicPath topicPath =
        TopicPath.newBuilder()
            .setProject(ProjectNumber.of(projectNumber))
            .setLocation(location)
            .setName(TopicName.of(topicId))
            .build();

    SubscriptionPath subscriptionPath =
        SubscriptionPath.newBuilder()
            .setLocation(location)
            .setName(SubscriptionName.of(subscriptionId))
            .build();

    SubscriptionName v1SubscriptionName =
        V1SubscriptionName.of(projectNumber, cloudRegion, zoneId, subscriptionId);
    V1TopicName v1TopicName = V1TopicName.of(projectNumber, cloudRegion, zoneId, topicId);

    AdminClientSettings adminClientSettings =
        AdminClientSettings.newBuilder()
            .setRegion(CloudRegion.of(cloudRegion))
            .setTransportChannelProvider(
                AdminClientSettings.defaultGrpcTransportProviderBuilder()
                    .setMaxInboundMessageSize(10 * 1024 * 1024) // 10 MB
                    .build())
            .build();

    try (AdminClient adminClient = AdminClient.create(adminClientSettings)) {
      // Create a subscription with automatic acknowledgment after 1 second.
      Subscription subscription =
          adminClient
              .createSubscription(
                  subscriptionPath,
                  v1SubscriptionName,
                  topicPath,
                  v1TopicName,
                  DeliveryConfig.newBuilder()
                      .setDeliveryRequirement(DeliveryRequirement.DELIVER_IMMEDIATELY)
                      .setAckDeadlineSeconds(1)
                      .build())
              .get();

      System.out.println(""Subscription created: "" + subscription.getName());
      System.out.println(""Delivery requirement: "" + subscription.getDeliveryConfig().getDeliveryRequirement());
      System.out.println(""ACK deadline: "" + subscription.getDeliveryConfig().getAckDeadlineSeconds());
    }
  }
}"
91,"public void bindAndStart(
        EventHandlerFactory eventHandlerFactory,
        NioServer server,
        Wallet wallet,
        TransactionBroadcaster broadcaster,
        ProtobufParser.Listener<Protos.TwoWayChannelMessage> protobufHandlerListener,
        ProtobufParser<Protos.TwoWayChannelMessage> socketProtobufHandler,
        int timeoutSeconds,
        PaymentChannelServer paymentChannelManager,
        PaymentChannelCloseException.CloseReason closeReason,
        Coin minAcceptedChannelSize,
        ServerConnectionEventHandler eventHandler) {
        server.addHandlerFactory(eventHandlerFactory);
        server.setProtobufHandlerListener(protobufHandlerListener);
        server.setSocketProtobufHandler(socketProtobufHandler);
        server.setTimeoutSeconds(timeoutSeconds);
        server.setPaymentChannelManager(paymentChannelManager);
        server.setCloseReason(closeReason);
        server.setMinAcceptedChannelSize(minAcceptedChannelSize);
        server.setEventHandler(eventHandler);
        server.bindAndStart(wallet, broadcaster);
    }"
92,
93,"import javax.xml.bind.JAXBElement;
import com.google.api.gax.rpc.AlreadyExistsException;
import com.google.api.gax.rpc.NotFoundException;
import com.google.cloud.certificatemanager.v1.Access;
import com.google.cloud.certificatemanager.v1.Auth;
import com.google.cloud.certificatemanager.v1.CertificateChainInfo;
import com.google.cloud.certificatemanager.v1.CertificateCredentials;
import com.google.cloud.certificatemanager.v1.CertificateInfo;
import com.google.cloud.certificatemanager.v1.CheckServiceAccessRequest;
import com.google.cloud.certificatemanager.v1.CheckServiceAccessResponse;
import com.google.cloud.certificatemanager.v1.CertificateManagerClient;
import com.google.cloud.certificatemanager.v1.CreateCertificateRequest;
import com.google.cloud.certificatemanager.v1.CreateCertificateRequest.CertificateId;
import com.google.cloud.certificatemanager.v1.CreateCertificateResponse;
import com.google.cloud.certificatemanager.v1.DeleteCertificateRequest;
import com.google.cloud.certificatemanager.v1.GetCertificateRequest;
import com.google.cloud.certificatemanager.v1.GetCertificateResponse;
import com.google.cloud.certificatemanager.v1.ListCertificatesRequest;
import com.google.cloud.certificatemanager.v1.ListCertificatesResponse;
import com.google.cloud.certificatemanager.v1.LocationName;
import com.google.cloud.certificatemanager.v1.PageToken;
import com.google.cloud.certificatemanager.v1.PasswordCredentials;
import com.google.cloud.certificatemanager.v1.RegistrationRequest;
import com.google.cloud.certificatemanager.v1.RegistrationResponse;
import com.google.cloud.certificatemanager.v1.Role;
import com.google.cloud.certificatemanager.v1.RoleList;
import com.google.cloud.certificatemanager.v1.SignCertificateRequest;
import com.google.cloud.certificatemanager.v1.SignCertificateResponse;
import com.google.cloud.certificatemanager.v1.SubjectAltNames;
import com.google.cloud.certificatemanager.v1.UpdateCertificateRequest;
import com.google.cloud.certificatemanager.v1.UpdateCertificateRequest.UpdateMask;
import com.google.cloud.certificatemanager.v1.User;
import com.google.cloud.certificatemanager.v1.UserValidation;
import com.google.cloud.certificatemanager.v1.ValidateTokenRequest;
import com.google.cloud.certificatemanager.v1.ValidateTokenResponse;
import java.io.IOException;
import java.time.Duration;
import java.util.concurrent. ExecutionException;
import java.util.concurrent.TimeoutException;
import javax.xml.namespace.QName;

public class Certificates {

  public static void createCertificate() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""my-project"";
    String location = ""us-east1"";
    String domain = ""www.example.com"";
    createCertificate(projectId, location, domain);
  }

  // Create an SSL certificate.
  public static void createCertificate(String projectId, String location, String domain) {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (CertificateManagerClient certificateManagerClient = CertificateManagerClient.create()) {
      // Set the fully qualified path for the project
      LocationName parent = LocationName.of(projectId, location);

      // Construct CertificateId
      CertificateId certificateId = CertificateId.of(projectId, location, domain);

      InitializeCertificateRequest.Builder initializeCertificateRequestBuilder =
          InitializeCertificateRequest.newBuilder();
      initializeCertificateRequestBuilder.getCertificateBuilder().setCommonName(domain);

      // Setting Subject Alternative Name (SAN) for the certificate.
      SubjectAltNames subjectAltNames =
          SubjectAltNames.newBuilder().addDnsNames(domain).addDnsNames(""*.example.com"").build();
      initializeCertificateRequestBuilder
          .getCertificateBuilder()
          .getSubjectAltNamesBuilder()
          .addAllDnsNames(subjectAltNames.getDnsNamesList());

      // Instantiates a client
      CreateCertificateRequest certificateRequest =
          CreateCertificateRequest.newBuilder()
              .setParent(parent.toString())
              .setCertificateId(certificateId.toString())
              .setCertificate(initializeCertificateRequestBuilder.build())
              .build();

      CreateCertificateResponse response =
          certificateManagerClient.createCertificateAsync(certificateRequest).get();

      System.out.println(""Certificate successfully created. Operation Details: "" + response);
    } catch (IOException | InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
    }
  }

  public static void listCertificates() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""my-project"";
    String location = ""us-east1"";
    listCertificates(projectId, location);
  }

  // List the certificates in a location.
  public static void listCertificates(String projectId, String location) {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (CertificateManagerClient certificateManagerClient = CertificateManagerClient.create()) {
      // Set the fully qualified path for the location.
      LocationName parent = LocationName.of(projectId, location);

      // List the certificates in the project
      for (Certificate certificate :
          certificateManagerClient.listCertificates(parent.toString()).iterateAll()) {
        System.out.println(String.format(""Certificate: %s\n"", certificate.getDisplayName()));
        System.out.println(
            String.format(
                ""\tCommon Name: %s, Lifetime: %s, Status: %s"",
                certificate.getCommonName(), certificate.getLifetime(), certificate.getStatus()));
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void getCertificate() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""my-project"";
    String location = ""us-east1"";
    String domain = ""www.example.com"";
    getCertificate(projectId, location, domain);
  }

  // Get the certificate present for the given certificate id.
  public static void getCertificate(String projectId, String location, String domain) {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (CertificateManagerClient certificateManagerClient = CertificateManagerClient.create()) {
      // Set the fully qualified path for the certificate.
      CertificateName certificateName = CertificateName.of(projectId, location, domain);

      // Get the certificate
      GetCertificateResponse certificate =
          certificateManagerClient.getCertificate(certificateName.toString());

      System.out.println(
          String.format(
              ""Certificate: %s\n"",
              certificate.getCertificate().getDisplayName().toString()));
      System.out.println(
          String.format(
              ""\tCommon Name: %s, Lifetime: %s, Status: %s"",
              certificate.getCertificate().getCommonName(),
              certificate.getCertificate().getLifetime(),
              certificate.getCertificate().getStatus()));

    } catch (NotFoundException e) {
      System.out.println(
          String.format(
              ""Certificate with name %s not found in location %s."", domain, location));
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void deleteCertificate() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""my-project"";
    String location = ""us-east1"";
    String domain = ""www.example.com"";
    deleteCertificate(projectId, location, domain);
  }

  // Delete the certificate present at the given certificate id.
  public static void deleteCertificate(String projectId, String location, String domain) {
    // Initialize client that will be used to send requests. This client only needs to"
94,"import java.util.Objects;
public class DataValidationError {
    private Long expectedDataUnitId;
    private Long seqNo;
    private Long dataSetId;
    private Long dataUnitId;
    private String expectedValue;
    private String actualValue;
    private Long expectedDataSetId;
    private String errorCode;
    private Long testId;
    private String failedAttributeName;
    private String srcFileName;
    private String errorMsg;

    public DataValidationError() {
    }

    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }

    public String getExpectedValue() {
        return expectedValue;
    }

    public Long getExpectedDataSetId() {
        return expectedDataSetId;
    }

    public void setExpectedDataSetId(Long expectedDataSetId) {
        this.expectedDataSetId = expectedDataSetId;
    }

    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }

    public Long getDataSetId() {
        return dataSetId;
    }

    public void setSrcFileName(String srcFileName) {
        this.srcFileName = srcFileName;
    }

    public Long getExpectedDataUnitId() {
        return expectedDataUnitId;
    }

    public void setExpectedDataUnitId(Long expectedDataUnitId) {
        this.expectedDataUnitId = expectedDataUnitId;
    }

    public String getSrcFileName() {
        return srcFileName;
    }

    public Long getSeqNo() {
        return seqNo;
    }

    public String getFailedAttributeName() {
        return failedAttributeName;
    }

    public void setTestId(Long testId) {
        this.testId = testId;
    }

    public Long getTestId() {
        return testId;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getActualValue() {
        return actualValue;
    }

    public Long getDataUnitId() {
        return dataUnitId;
    }

    public void setSeqNo(Long seqNo) {
        this.seqNo = seqNo;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public void setDataUnitId(Long dataUnitId) {
        this.dataUnitId = dataUnitId;
    }

    public void setDataSetId(Long dataSetId) {
        this.dataSetId = dataSetId;
    }

    @Override
    public String toString() {
        return ""DataValidationError{"" +
                ""expectedDataUnitId="" + expectedDataUnitId +
                "", seqNo="" + seqNo +
                "", dataSetId="" + dataSetId +
                "", dataUnitId="" + dataUnitId +
                "", expectedValue='"" + expectedValue + '\' +
                "", actualValue='"" + actualValue + '\' +
                "", expectedDataSetId="" + expectedDataSetId +
                "", errorCode='"" + errorCode + '\' +
                "", testId="" + testId +
                "", failedAttributeName='"" + failedAttributeName + '\' +
                "", srcFileName='"" + srcFileName + '\' +
                "", errorMsg='"" + errorMsg + '\' +
                '}';
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DataValidationError that = (DataValidationError) o;
        return Objects.equals(expectedDataUnitId, that.expectedDataUnitId) &&
                Objects.equals(seqNo, that.seqNo) &&
                Objects.equals(dataSetId, that.dataSetId) &&
                Objects.equals(dataUnitId, that.dataUnitId) &&
                Objects.equals(expectedValue, that.expectedValue) &&
                Objects.equals(actualValue, that.actualValue) &&
                Objects.equals(expectedDataSetId, that.expectedDataSetId) &&
                Objects.equals(errorCode, that.errorCode) &&
                Objects.equals(testId, that.testId) &&
                Objects.equals(failedAttributeName, that.failedAttributeName) &&
                Objects.equals(srcFileName, that.srcFileName) &&
                Objects.equals(errorMsg, that.errorMsg);
    }

    @Override
    public int hashCode() {
        return Objects.hash(expectedDataUnitId, seqNo, dataSetId, dataUnitId, expectedValue, actualValue, expectedDataSetId, errorCode, testId, failedAttributeName, srcFileName, errorMsg);
    }
}"
95,"import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.admin.directory.Directory;
import com.google.api.services.admin.directory.DirectoryScopes;
import com.google.api.services.admin.directory.model.Groups;
import com.google.api.services.admin.directory.model.Member;
import com.google.api.services.admin.directory.model.User;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.Collections;

/* Class to demonstrate use-case of Admin Directory Groups API */
public class GroupsForAUser {

  /* Scopes required by this API call. If modifying these scopes, delete your previously saved tokens/ folder. */
  static final String[] SCOPES = {DirectoryScopes.ADMIN_DIRECTORY_GROUP_MEMBER_READONLY,
      DirectoryScopes.ADMIN_DIRECTORY_GROUP_READONLY};

  /**
   * Retrieve list of groups for a user.
   *
   * @param userKey - Email address of the user for which groups (or memberships)
   *     needs to be retrieved.
   */
  public static void listGroupForAUser(String userKey) throws IOException, GeneralSecurityException {
        /* Load pre-authorized credentials from the environment.
        TODO(developer) - See https://developers.google.com/identity for
        guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(Collections.singleton(DirectoryScopes.ADMIN_DIRECTORY_GROUP_MEMBER_READONLY));
    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Directory service =
        new Directory.Builder(HTTP_TRANSPORT,
            GsonFactory.getDefaultInstance(),
            new HttpCredentialsAdapter(credentials))
            .setApplicationName(""Directory Groups API Snippets"")
            .build();

    try {
      // Fetch user details.
      User user = service.users().get(""admin@example.com"").setUserKey(userKey).execute();

      // Create query string.
      StringBuilder query = new StringBuilder(""email="");
      if (user.getPrimaryEmail() != null) {
        query.append(user.getPrimaryEmail());
      } else if (user.getEmail() != null) {
        query.append(user.getEmail());
      } else {
        System.out.println(""No email found for this user to check group membership."");
        return;
      }

      // Retrieve groups where the user is a member.
      Groups groups = service.groups().list().setUserKey(userKey).setQuery(query.toString())
          .setFields(""nextPageToken, groups(email, id)"").execute();
      System.out.println(""List of groups where the user is a member:"");
      System.out.println(groups.toPrettyString());

    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 404) {
        System.out.printf(""Group with email %s not found.\n"", userKey);
      } else {
        System.err.println(""Unexpected error: "" + e.getMessage());
      }
    }
  }

  /**
   * Retrieve list of group members.
   *
   * @param groupKey - Email address of the group for which members are to be retrieved.
   */
  public static void listGroupMembers(String groupKey) throws IOException, GeneralSecurityException {
        /* Load pre-authorized credentials from the environment.
        TODO(developer) - See https://developers.google.com/identity for
        guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(Collections.singleton(DirectoryScopes.ADMIN_DIRECTORY_GROUP_MEMBER_READONLY));
    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Directory service =
        new Directory.Builder(HTTP_TRANSPORT,
            GsonFactory.getDefaultInstance(),
            new HttpCredentialsAdapter(credentials))
            .setApplicationName(""Directory Groups API Snippets"")
            .build();

    try {
      // Create query string.
      StringBuilder query = new StringBuilder(""group="");
      if (groupKey.indexOf('@') < 0) {
        query.append(""email:"");
      }
      query.append(groupKey);

      // Retrieve group details.
      Groups groups = service.groups().list().setQuery(query.toString()).setFields(
          ""nextPageToken, groups(email, id)"").execute();
      Groups.GroupsIterator groupIterator = groups.getGroups().iterator();
      if (groupIterator.hasNext()) {
        Groups.Group group = groupIterator.next();

        // Retrieve group members.
        Members members = service.members().list(group.getId())
            .setFields(""nextPageToken, members(id, email)"").execute();
        System.out.println(""List of members in the group:"");
        System.out.println(members.toPrettyString());

      }
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 404) {
        System.out.printf(""Member with email %s not found.\n"", groupKey);
      } else {
        System.err.println(""Unexpected error: "" + e.getMessage());
      }
    }
  }

  /**
   * Retrieve list of members for a user.
   *
   * @param userKey - Email address of the user for which members are to be retrieved.
   */
  public static void listUserMembers(String userKey) throws IOException, GeneralSecurityException {
        /* Load pre-authorized credentials from the environment.
        TODO(developer) - See https://developers.google.com/identity for
        guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(Collections.singleton(DirectoryScopes.ADMIN_DIRECTORY_GROUP_MEMBER_READONLY));
    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Directory service =
        new Directory.Builder(HTTP_TRANSPORT,
            GsonFactory.getDefaultInstance(),
            new HttpCredentialsAdapter(credentials))
            .setApplicationName(""Directory Groups API Snippets"")
            .build();
    User.Members members;
    try {
      // Fetch user details.
      User user = service.users().get(""admin@example.com"").setUserKey(userKey).execute();

      // Create query string.
      StringBuilder query = new StringBuilder(""email="");
      if (user.getPrimaryEmail() != null) {
        query.append(user.getPrimaryEmail());
      } else if (user.getEmail() != null) {
        query.append(user.getEmail());
      } else {
        System.out.println(""No email found for this user to check group membership."");
        return;
      }

      // Retrieve groups where the user is a member.
      members = service.members().list(""admin@example.com"").setUserKey(userKey)
          .setQuery(query.toString())
          .setFields(""nextPageToken, members(id, email)"").execute();

      // Retrieve members for the user.
      System.out.println(""List of members where the user is a member:"");
      System.out.println(members.toPrettyString());

    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 404) {
        System.out.printf(""User with email %s not found.\n"", userKey);
      } else {
        System.err.println(""Unexpected error: "" + e.getMessage());
      }
    }
  }
}"
96,"import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.cloud.pubsublite.CloudRegion;
import com.google.cloud.pubsublite.CloudZone;
import com.google.cloud.pubsublite.ProjectNumber;
import com.google.cloud.pubsublite.TopicName;
import com.google.cloud.pubsublite.TopicPath;
import com.google.cloud.pubsublite.cloudpubsub.Publisher;
import com.google.cloud.pubsublite.cloudpubsub.PublisherSettings;
import com.google.cloud.pubsublite.cloudpubsub.TopicPathConverter;
import com.google.cloud.pubsublite.proto.CloudRegionOrZone;
import com.google.cloud.pubsublite.proto.CloudRegionOrZone.CloudRegionOrZoneCase;
import com.google.cloud.pubsublite.proto.CloudRegionOrZone.CloudZoneOrRegion;
import com.google.cloud.pubsublite.proto.TopicPathOrUnknown;
import com.google.cloud.pubsublite.proto.TopicPathOrUnknown.TopicPathOrUnknownCase;
import com.google.cloud.pubsublite.proto.TopicPathOrUnknown.TopicOrUnknown;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.pubsublite.spark.util.PublisherUtil;
import java.util.concurrent.TimeUnit;

public class ShutdownExample {
  private static final Logger logger = LoggerFactory.getLogger(ShutdownExample.class);

  public static void main(String... args) throws Exception {

    // TODO(developer): Replace these variables before running the sample.
    long projectNumber = Long.parseLong(""123456789"");
    String cloudRegion = ""your-cloud-region"";
    char zoneId = 'a';
    String topicId = ""your-topic-id"";
    // Ensure the topic exists. Create the topic using gcloud:
    //   gcloud pubsub topics create --project=PROJECT_ID --location=region/zone TOPIC_ID

    TopicPath topicPath =
        TopicPath.newBuilder()
            .setProject(ProjectNumber.of(projectNumber))
            .setZone(CloudZone.of(CloudRegion.of(cloudRegion), zoneId))
            .setName(TopicName.of(topicId))
            .build();

    TopicPathConverter topicPathConverter = TopicPathConverter.create(topicPath);
    TopicPathOrUnknown topicPathOrUnknown =
        TopicPathOrUnknown.newBuilder()
            .setTopicPath(topicPathConverter.getTopicPathOrUnknown())
            .build();
    CloudRegionOrZone cloudRegionOrZone =
        CloudRegionOrZone.newBuilder()
            .setCloudRegionOrZoneCase(CloudRegionOrZoneCase.CLOUD_ZONE)
            .setCloudZoneOrRegion(
                CloudZoneOrRegion.newBuilder()
                    .setZone(
                        CloudRegionOrZone.CloudZone.newBuilder()
                            .setRegion(cloudRegion)
                            .setZone(String.valueOf(zoneId))
                            .build())
                    .build())
            .build();

    PublisherSettings publisherSettings =
        PublisherSettings.newBuilder()
            .setParallelism(1)
            .setTopicPath(topicPathOrUnknown)
            .setCloudRegionOrZone(cloudRegionOrZone)
            .build();

    TopicOrUnknown topicOrUnknown =
        TopicOrUnknown.newBuilder()
            .setTopic(topicPathConverter.toProto())
            .setUnknown(PublisherUtil.getUnknownTopicOrUnknown(topicPathConverter.getTopicPath()))
            .build();

    Publisher publisher = Publisher.create(publisherSettings);

    Thread.UncaughtExceptionHandler handler =
        (thread, ex) ->
            logger.error(""An exception occurred in the Publisher thread."", ex);

    publisher
        .getOrCreateTopicCallable()
        .call()
        .handle(
            (result, throwable) -> {
              if (throwable != null) {
                logger.error(
                    ""Failed to create topic: "" + topicId, throwable);
              } else {
                logger.info(""Created topic: "" + topicId);
              }
              return null;
            })
        .get();

    publisher.startAsync().awaitRunning();
    publisher
        .publishCallable()
        .call()
        .thenRunAsync(
            () -> {
              try {
                // Publish messages here.
                Thread.sleep(TimeUnit.SECONDS.toMillis(10));
              } catch (InterruptedException e) {
                logger.error(""Interrupted while publishing. Shutdown initiated."", e);
                shutdownPublisher(publisher);
                return;
              }
              shutdownPublisher(publisher);
            },
            MoreExecutors.directExecutor())
        .get();
  }

  private static void shutdownPublisher(Publisher publisher) {
    logger.info(""Shutting down the Publisher."");
    publisher.stopAsync().awaitTerminated();
    logger.info(""Publisher was shut down."");
  }
}"
97,"import androidx.media.MediaMetadataEditorCompat;
import android.util.Log;
import android.support.v4.media.session.PlaybackStateCompat;

MediaMetadataEditorCompat metadataEditorCompat = new MediaMetadataEditorCompat.Builder()
        .putBitmap(MediaMetadataEditorCompat.METADATA_KEY_ARTWORK, /* Bitmap */ null)
        .build();

metadataEditorCompat.apply();

metadataEditorCompat.clear();

MediaMetadataEditorCompat editorCompat = new MediaMetadataEditorCompat();
editorCompat.putLong(MediaMetadataEditorCompat.METADATA_KEY_ARTWORK, 0L);
editorCompat.editMetadata(mActualMetadataEditor, mActualRemoteControlClient);

mActualMetadataEditor.setPlaybackState(PlaybackStateCompat.STATE_PLAYING);
mActualMetadataEditor.setTransportControlFlags(PlaybackStateCompat.FLAG_PLAY_PAUSE);

if (mActualRemoteControlClient != null) {
    mActualRemoteControlClient.removeFromMediaRouter();
    mActualRemoteControlClient.addToMediaRouter();
}"
98,"import android.util.Log;

import com.parrot.arsdk.arcontroller.ARCONTROLLER_DEVICE_STATE_ENUM;
import com.parrot.arsdk.arcontroller.ARControllerCodec;
import com.parrot.arsdk.arcontroller.ARControllerException;
import com.parrot.arsdk.arcontroller.ARControllerState;
import com.parrot.arsdk.arcontroller.ARFeatureARDrone3;
import com.parrot.arsdk.arcontroller.ARFeatureCommon;
import com.parrot.arsdk.arcontroller.ARFeatureSkyCtrl;
import com.parrot.arsdk.arcontroller.ARFrame;
import com.parrot.arsdk.arcontroller.command.ARCommand;
import com.parrot.arsdk.arcontroller.command.ARCommandJSONDeserializer;
import com.parrot.arsdk.arcontroller.command.ARControllerCommand;
import com.parrot.arsdk.arcontroller.command.ARDrone3PilotingCommand;
import com.parrot.arsdk.arcontroller.command.ARFeatureARDrone3PilotingCommand;
import com.parrot.arsdk.arcontroller.command.ARFeatureSkyCtrlCommand;
import com.parrot.arsdk.arcontroller.configuration.ARConfiguration;
import com.parrot.arsdk.arcontroller.configuration.ARConfigurationDecoder;
import com.parrot.arsdk.arcontroller.configuration.ARControllerConfiguration;
import com.parrot.arsdk.arcontroller.configuration.ARFeatureARDrone3Configuration;
import com.parrot.arsdk.arcontroller.configuration.ARFeatureARDrone3PilotingConfiguration;
import com.parrot.arsdk.arcontroller.configuration.ARFeatureSkyCtrlConfiguration;
import com.parrot.arsdk.arcontroller.decoder.ARControllerDecoder;
import com.parrot.arsdk.arcontroller.decoder.ARFrameDecoder;
import com.parrot.arsdk.arcontroller.stream.ARStreamReader;
import com.parrot.arsdk.arsal.ARSALPrint;
import com.parrot.arsdk.arsal.ARSALThread;

public class JavaDrone extends ARSALThread implements ARStreamReader.ARStreamReaderListener, ARControllerListener
{
    private static final String TAG = JavaDrone.class.getSimpleName();

    /**
     * {@link ARControllerListener} interface implementation
     *
     * @see ARControllerListener
     */
    public interface ARControllerListener
    {
        /**
         * Called when the controller state changes
         *
         * @param state   the new state
         * @param reason  the reason for the change
         */
        void onControllerStateChanged(ARCONTROLLER_DEVICE_STATE_ENUM state, ARCONTROLLER_DEVICE_STATE_REASON_ENUM reason);

        /**
         * Called when the battery level changes
         *
         * @param batteryLevel the battery level
         */
        void onBatteryLevelChanged(int batteryLevel);

        /**
         * Called when an error message occurs
         *
         * @param errorMessage the error message
         */
        void onErrorMessage(String errorMessage);

        /**
         * Called when a configuration is received
         *
         * @param config the configuration received
         */
        void onReceivedConfiguration(ARControllerConfiguration config);

        /**
         * Called when ARFrames are received
         *
         * @param frame the frame received
         */
        void onFrameReceived(ARFrame frame);
    }

    private GeneralMotorCon ourInstance = null;


    /**
     * Absolute control mode
     */
    private static final int ABSOLUTE_CONTROL_MODE = 0;

    /**
     * Relative control mode
     */
    private static final int RELATIVE_CONTROL_MODE = 1;

    /**
     * Control mode. Defaults to absolute control mode.
     */
    private int controlMode = ABSOLUTE_CONTROL_MODE;

    /**
     * A flag to indicate that the drone is connected
     */
    private boolean isConnected = false;

    /**
     * A flag to indicate that the drone is landed
     */
    private boolean isLanded = true;

    /**
     * A flag to indicate that the drone is flying
     */
    private boolean isFlying = false;

    /**
     * A flag to indicate that the thread is stopped
     */
    private boolean isStopped;

    /**
     * The ARDrone
     */
    private ARDrone drone;

    /**
     * The command manager
     */
    private CommandManager cmd;

    /**
     * The ARController
     */
    private ARControllerCodec arController;

    /**
     * The ARController state
     */
    private ARControllerState controllerState;

    /**
     * The battery level
     */
    private int batLvl = 0;

    /**
     * The spin speed
     */
    private int spinSpeed = 40;

    /**
     * The spin90 speed
     */
    private int spin90Speed = 60;

    /**
     * The spin time
     */
    private int spinTime = 300;

    /**
     * The spin90 time
     */
    private int spin90Time = 900;

    /**
     * The hover time
     */
    private int hoverTime = 500;

    /**
     * The forward speed
     */
    private int speed = 100;

    /**
     * The thread timer
     */
    private long threadTimer = 0;

    public void run()
    {
        super.run();
        while (!isStopped)
        {
            try
            {
                // Get the data from the drone
                ARFrame frame = arController.getFrame(0);

                if(frame.isValid() && ARControllerState.ARCONTROLLER_DEVICE_STATE_RUNNING == controllerState.getState())
                {
                    // Update the UI
                    ourInstance.updateGUI();
                }

                Thread.sleep(20);
            }
            catch (Exception ignored)
            {
            }
        }
    }

    public void stop()
    {
        isStopped = true;
    }

    public void setDrone(ARDrone drone)
    {
        this.drone = drone;
    }

    public void takeoff()
    {
        cmd.takeoff();
    }

    public void land()
    {
        cmd.land();
    }

    public void forward()
    {
        cmd.forward(speed);
    }

    public void backward()
    {
        cmd.backward(speed);
    }

    public void right()
    {
        cmd.right(spinSpeed);
    }

    public void left()
    {
        cmd.left(spinSpeed);
    }

    public void raiseAltitude()
    {
        cmd.raiseAltitude();
    }

    public void lowerAltitude()
    {
        cmd.lowerAltitude();
    }

    public void spinLeft()
    {
        cmd.spinLeft(spinSpeed);
    }

    public void spinRight()
    {
        cmd.spinRight(spinSpeed);
    }

    public void spin90Left()
    {
        cmd.spinLeft(spin90Speed);
        waitFor(spin90Time);
        cmd.flatTrim();
    }

    public void spin90Right()
    {
        cmd.spinRight(spin90Speed);
        waitFor(spin90Time);
        cmd.flatTrim();
    }

    public void onStop()
    {
        try
        {
            arController.dispose();
        }
        catch (Exception e)
        {
            Log.e(TAG, ""Error while stopping: "" + e.getMessage());
        }
    }

    public void waitFor(int time)
    {
        long start = threadTimer;

        while(threadTimer - start < time)
        {
            try
            {
                Thread.sleep(10);
            }
            catch (InterruptedException e)
            {
                Log.d(TAG, e.getMessage());
            }
        }
    }

    public void onControllerStateChanged(ARCONTROLLER_DEVICE_STATE_ENUM state, ARCONTROLLER_DEVICE_STATE_REASON_ENUM reason)
    {
        switch (state)
        {
            case ARCONTROLLER_DEVICE_STATE_RUNNING:
                isFlying = true;
                isLanded = false;
                isConnected = true;
                break;
            case ARCONTROLLER_DEVICE_STATE_STOPPED:
                isFlying = false;
                isLanded = true;
                isConnected = false;
                break;
            case ARCONTROLLER_DEVICE_STATE_INIT:
            case ARCONTROLLER_DEVICE_STATE_DISCONNECTING:
            case ARCONTROLLER_DEVICE_STATE_CONNECTING:
            case ARCONTROLLER_DEVICE_STATE_UNKNOWN:
            default:
                isFlying = false;
                isLanded = false;
                isConnected = false;"
99,"import com.google.cloud.scheduler.v1.GroupConfiguration;
import java.util.Map;

public class BuildGroupConfigurationSnippets {

  static GroupConfiguration buildConfiguration() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    GroupConfiguration.Builder groupConfig =
        GroupConfiguration.newBuilder()
            .setProject(projectId)
            .setLocation(locationId)
            .setMetadata(Map.of(""1"", ""abc"", ""2"", ""def""));
    return groupConfig.build();
  }

  static GroupConfiguration buildConfigurationMetadata() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    GroupConfiguration.Builder groupConfig =
        GroupConfiguration.newBuilder()
            .setProject(projectId)
            .setLocation(locationId)
            .setMetadata(Map.of(""1"", ""abc"", ""2"", ""def"", ""3"", ""ghi""));
    return groupConfig.build();
  }

  static GroupConfiguration buildConfigurationMaxEntities() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    GroupConfiguration.Builder groupConfig =
        GroupConfiguration.newBuilder()
            .setProject(projectId)
            .setLocation(locationId)
            .setMaxEntities(2);
    return groupConfig.build();
  }

  static GroupConfiguration buildConfigurationMinEntities() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    GroupConfiguration.Builder groupConfig =
        GroupConfiguration.newBuilder()
            .setProject(projectId)
            .setLocation(locationId)
            .setMinEntities(3);
    return groupConfig.build();
  }

  static GroupConfiguration buildConfigurationName() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    String name = ""sample-group-configuration"";
    GroupConfiguration.Builder groupConfig =
        GroupConfiguration.newBuilder()
            .setProject(projectId)
            .setLocation(locationId)
            .setName(name);
    return groupConfig.build();
  }

  static GroupConfiguration buildConfigurationCooldown() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    long cooldown = 15;
    GroupConfiguration.Builder groupConfig =
        GroupConfiguration.newBuilder()
            .setProject(projectId)
            .setLocation(locationId)
            .setCooldown(cooldown);
    return groupConfig.build();
  }

  static GroupConfiguration buildConfigurationFromGroupConfiguration() {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""your-project-id"";
    String locationId = ""us-central1"";
    // Build a GroupConfiguration object.
    GroupConfiguration groupConfig = buildConfiguration();
    // Convert GroupConfiguration object into a builder.
    GroupConfiguration.Builder groupConfigBuilder = groupConfig.toBuilder();
    // Build a new GroupConfiguration object with a different project and location.
    GroupConfiguration changedConfig =
        groupConfigBuilder.setProject(projectId).setLocation(locationId).build();
    return changedConfig;
  }
}"
100,"import net.sf.marineapi.nmea.parser.RMCParser;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class RMCParserTest {

    private RMCParser rmc;

    @Before
    public void setUp() {
        rmc = new RMCParser();
    }

    @Test
    public void testConstructor() {
        assertNotNull(rmc);
    }

    @Test
    public void testGetTime() {
        rmc.setTime(123456789);
        assertEquals(123456789, rmc.getTime());
    }

    @Test
    public void testSetTime() {
        rmc.setTime(123456789);
        assertEquals(123456789, rmc.getTime());
    }

    @Test
    public void testGetDate() {
        rmc.setDate(123456);
        assertEquals(123456, rmc.getDate());
    }

    @Test
    public void testSetDate() {
        rmc.setDate(123456);
        assertEquals(123456, rmc.getDate());
    }

    @Test
    public void testGetYear() {
        rmc.setYear(2000);
        assertEquals(2000, rmc.getYear());
    }

    @Test
    public void testSetYear() {
        rmc.setYear(2000);
        assertEquals(2000, rmc.getYear());
    }

    @Test
    public void testGetMonth() {
        rmc.setMonth(1);
        assertEquals(1, rmc.getMonth());
    }

    @Test
    public void testSetMonth() {
        rmc.setMonth(1);
        assertEquals(1, rmc.getMonth());
    }

    @Test
    public void testGetDay() {
        rmc.setDay(1);
        assertEquals(1, rmc.getDay());
    }

    @Test
    public void testSetDay() {
        rmc.setDay(1);
        assertEquals(1, rmc.getDay());
    }

    @Test
    public void testGetSpeed() {
        rmc.setSpeed(12.34);
        assertEquals(12.34, rmc.getSpeed(), 0.001);
    }

    @Test
    public void testSetSpeed() {
        rmc.setSpeed(12.34);
        assertEquals(12.34, rmc.getSpeed(), 0.001);
    }

    @Test
    public void testGetCourse() {
        rmc.setCourse(123.45);
        assertEquals(123.45, rmc.getCourse(), 0.001);
    }

    @Test
    public void testSetCourse() {
        rmc.setCourse(123.45);
        assertEquals(123.45, rmc.getCourse(), 0.001);
    }

    @Test
    public void testGetDataStatus() {
        rmc.setDataStatus('A');
        assertEquals('A', rmc.getDataStatus());
    }

    @Test
    public void testSetDataStatus() {
        rmc.setDataStatus('A');
        assertEquals('A', rmc.getDataStatus());
    }

    @Test
    public void testGetPosition() {
        rmc.setPosition(""-122.41942,-37.82719"");
        assertEquals(""-122.41942,-37.82719"", rmc.getPosition());
    }

    @Test
    public void testSetPosition() {
        rmc.setPosition(""-122.41942,-37.82719"");
        assertEquals(""-122.41942,-37.82719"", rmc.getPosition());
    }

    @Test
    public void testGetMagneticVariation() {
        rmc.setMagneticVariation(12.34);
        assertEquals(12.34, rmc.getMagneticVariation(), 0.001);
    }

    @Test
    public void testSetMagneticVariation() {
        rmc.setMagneticVariation(12.34);
        assertEquals(12.34, rmc.getMagneticVariation(), 0.001);
    }

    @Test
    public void testGetFaaMode() {
        rmc.setFaaMode('A');
        assertEquals('A', rmc.getFaaMode());
    }

    @Test
    public void testSetFaaMode() {
        rmc.setFaaMode('A');
        assertEquals('A', rmc.getFaaMode());
    }

    @Test
    public void testSetFaaModeWhenOmitted() {
        assertEquals('N', rmc.getFaaMode());
    }

    @Test
    public void testSetDirectionOfVariationWithInvalidDirection() {
        rmc.setDirectionOfVariation('X', 12.34);
        assertEquals(12.34, rmc.getMagneticVariation(), 0.001);
        assertEquals('W', rmc.getDirectionOfVariation());
    }

    @Test
    public void testGetCorrectedCourse() {
        rmc.setCourse(123.45);
        rmc.setMagneticVariation(12.34);
        rmc.setDirectionOfVariation('W');
        assertEquals(111.11, rmc.getCorrectedCourse(), 0.001);
    }

    @Test
    public void testSetDirectionOfVariation() {
        rmc.setDirectionOfVariation('E', 12.34);
        assertEquals(12.34, rmc.getMagneticVariation(), 0.001);
        assertEquals('E', rmc.getDirectionOfVariation());
    }

    @Test
    public void testGetDirectionOfVariation() {
        rmc.setDirectionOfVariation('E', 12.34);
        assertEquals('E', rmc.getDirectionOfVariation());
    }

}"
101,"import com.google.common.base.Strings;
import java.util.HashSet;
import java.util.Set;
import org.apache.commons.lang3.StringEscapeUtils;
import org.owasp.html.PolicyFactory;
import org.owasp.html.Sanitizers;

class JavascriptCleanup {

  private static PolicyFactory policyFactory = Sanitizers.FORMATTING.and(Sanitizers.LINKS);

  private static final Set<String> IGNORED_INPUTS = new HashSet<>();
  static {
    IGNORED_INPUTS.add(""javascript"");
  }

  static String getCleanerInput(String input) {
    if (Strings.isNullOrEmpty(input)) {
      return null;
    }
    // Assume default policy is acceptable for internal uses.
    return policyFactory.relaxed().sanitize(input);
  }

  static String getCleanInput(String input) {
    if (input == null) {
      return null;
    }
    for (String ignored : IGNORED_INPUTS) {
      if (input.contains(ignored)) {
        return null;
      }
    }

    input = StringEscapeUtils.escapeHtml4(input);

    return input;
  }
}"
102,"import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for WsseType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name=""WsseType"">
 *   &lt;complexContent>
 *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
 *       &lt;attribute name=""identifier"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
 *       &lt;attribute name=""wsseValueType"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
 *       &lt;attribute name=""useKeyIdentifier"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
 *       &lt;attribute name=""useDirectReference"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
 *       &lt;attribute name=""wsse11TokenType"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = ""WsseType"")
public class WsseType {

    @XmlAttribute(name = ""identifier"")
    protected String identifier;
    @XmlAttribute(name = ""wsseValueType"")
    protected String wsseValueType;
    @XmlAttribute(name = ""useKeyIdentifier"")
    protected Boolean useKeyIdentifier;
    @XmlAttribute(name = ""useDirectReference"")
    protected Boolean useDirectReference;
    @XmlAttribute(name = ""wsse11TokenType"")
    protected String wsse11TokenType;

    /**
     * Gets the value of the identifier property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getIdentifier() {
        return identifier;
    }

    /**
     * Sets the value of the identifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setIdentifier(String value) {
        this.identifier = value;
    }

    /**
     * Gets the value of the wsseValueType property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getWsseValueType() {
        return wsseValueType;
    }

    /**
     * Sets the value of the wsseValueType property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setWsseValueType(String value) {
        this.wsseValueType = value;
    }

    /**
     * Gets the value of the useKeyIdentifier property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseKeyIdentifier() {
        return useKeyIdentifier;
    }

    /**
     * Sets the value of the useKeyIdentifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseKeyIdentifier(Boolean value) {
        this.useKeyIdentifier = value;
    }

    /**
     * Gets the value of the useDirectReference property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseDirectReference() {
        return useDirectReference;
    }

    /**
     * Sets the value of the useDirectReference property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseDirectReference(Boolean value) {
        this.useDirectReference = value;
    }

    /**
     * Gets the value of the wsse11TokenType property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getWsse11TokenType() {
        return wsse11TokenType;
    }

    /**
     * Sets the value of the wsse11TokenType property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setWsse11TokenType(String value) {
        this.wsse11TokenType = value;
    }

}"
103,"import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.PrimaryKey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import com.google.gson.internal.$Gson$Types;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Entity(tableName = ""tweets"")
public class Tweet {

    @PrimaryKey
    @NonNull
    @ColumnInfo(name = ""id"")
    @Expose
    private String id;

    @ColumnInfo(name = ""user_id"")
    @Expose
    private String userId;

    @ColumnInfo(name = ""text"")
    @Expose
    private String text;

    @ColumnInfo(name = ""user_name"")
    @Expose
    private String userName;

    @ColumnInfo(name = ""screen_name"")
    @Expose
    private String screenName;

    @ColumnInfo(name = ""image"")
    @Expose
    private String image;

    @ColumnInfo(name = ""lat"")
    @Expose
    private double lat;

    @ColumnInfo(name = ""lng"")
    @Expose
    private double lng;

    @ColumnInfo(name = ""place_name"")
    @Expose
    private String placeName;

    @ColumnInfo(name = ""extras"")
    @Expose
    private Map<String, String> extras;

    @ColumnInfo(name = ""created_at"")
    @Expose
    private Date createdAt;

    @ColumnInfo(name = ""loc_radius"")
    @Expose
    private int locRadius;

    public Tweet() {
        this.id = UUID.randomUUID().toString();
    }

    @NonNull
    public String getId() {
        return id;
    }

    public void setId(@NonNull String id) {
        this.id = id;
    }

    @Nullable
    public String getUserId() {
        return userId;
    }

    public void setUserId(@Nullable String userId) {
        this.userId = userId;
    }

    @Nullable
    public String getText() {
        return text;
    }

    public void setText(@Nullable String text) {
        this.text = text;
    }

    @Nullable
    public String getUserName() {
        return userName;
    }

    public void setUserName(@Nullable String userName) {
        this.userName = userName;
    }

    @Nullable
    public String getScreenName() {
        return screenName;
    }

    public void setScreenName(@Nullable String screenName) {
        this.screenName = screenName;
    }

    @Nullable
    public String getImage() {
        return image;
    }

    public void setImage(@Nullable String image) {
        this.image = image;
    }

    public double getLat() {
        return lat;
    }

    public void setLat(double lat) {
        this.lat = lat;
    }

    public double getLng() {
        return lng;
    }

    public void setLng(double lng) {
        this.lng = lng;
    }

    @Nullable
    public String getPlaceName() {
        return placeName;
    }

    public void setPlaceName(@Nullable String placeName) {
        this.placeName = placeName;
    }

    @Nullable
    public Map<String, String> getExtras() {
        return extras;
    }

    public void setExtras(@Nullable Map<String, String> extras) {
        this.extras = extras;
    }

    @Nullable
    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(@Nullable Date createdAt) {
        this.createdAt = createdAt;
    }

    public int getLocRadius() {
        return locRadius;
    }

    public void setLocRadius(int locRadius) {
        this.locRadius = locRadius;
    }

    public static class Builder {

        private double lat;
        private String idStr;
        private String screen_name;
        private String place_name;
        private String image;
        private String user_name;
        private double lng;
        private Date created_at;
        private int loc_radius;
        private String user_id;
        private String text;
        private ArrayList<String> extras = new ArrayList<String>();

        public Builder setIDstr(String idStr) {
            this.idStr = idStr;
            return this;
        }

        public Builder setPlaceName(String place_name) {
            this.place_name = place_name;
            return this;
        }

        public Builder addText(String text) {
            this.extras.add(""text"");
            return this;
        }

        public Builder addField(String name) {
            this.extras.add(name);
            return this;
        }

        public void insert() {
            Tweet tweet = new Tweet();
            tweet.setId(idStr);
            tweet.setPlaceName(place_name);
            tweet.setText(text);
            tweet.setExtras(convertExtras(extras));

            //todo persist to DB
            this.extras.clear();
        }

        public Builder setCoordinateRadius(int loc_radius) {
            this.loc_radius = loc_radius;
            return this;
        }

        public Builder setAuthor(String user_name) {
            this.user_name = user_name;
            return this;
        }

        public Builder builder() {
            return this;
        }

        public Builder setCoordinate(double lat, double lng) {
            this.lat = lat;
            this.lng = lng;
            return this;
        }

        public Builder setCreatedTime(Date created_at) {
            this.created_at = created_at;
            return this;
        }

        public void persist() {
            insert();
        }

        public String buildFieldJSON(String name, String field) {
            return ""\"" + name + ""\"": \"" + field + ""\"";
        }

        public Builder setImage(String image) {
            this.image = image;
            return this;
        }

        private Map<String, String> convertExtras(ArrayList<String> ex) {
            Gson gson = new GsonBuilder().create();

            Type listType = new TypeToken<List<String>>() {
            }.getType();
            String json = gson.toJson(ex, listType);

            return gson.fromJson(json, Map.class);
        }
    }
}"
104,"import com.google.cloud.datacatalog.v1.DataCatalogClient;
import com.google.cloud.datacatalog.v1.ListResourcesRequest;
import com.google.cloud.datacatalog.v1.LocationName;
import com.google.cloud.datacatalog.v1.Resource;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

// Sample to get resources
public class AllResources {

  private static final Logger LOG = Logger.getLogger(AllResources.class.getName());

  public static void main(String[] args) throws Exception {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""MY_PROJECT_ID"";
    LocationName locationName = LocationName.of(projectId, ""MY_LOCATION"");
    allResources(locationName);
  }

  public static void allResources(LocationName locationName) {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (DataCatalogClient client = DataCatalogClient.create()) {
      ListResourcesRequest request =
          ListResourcesRequest.newBuilder().setParent(locationName.toString()).build();
      Iterator<Resource> resources = client.listResources(request).iterateAll();

      // Iterate over all resources.
      new HashMap();
      Map<Object, Object> bag = new HashMap<>();
      while (resources.hasNext()) {
        Resource resource = resources.next();
        String name = resource.getName();
        String type = resource.getType();
        LOG.log(Level.INFO, ""Resource {0} has type {1}"", new Object[] {name, type});
        LOG.log(Level.INFO, ""Lineage: {0}"", resource.getLineage());
        LOG.log(Level.INFO, ""Schemas: {0}"", resource.getSchema());
        // Uncomment below to print all properties
        // LOG.log(Level.INFO, ""Properties: {0}"", resource.getPropertiesMap());
        loadProperties(resource.getPropertiesMap(), bag);
        Collections.<String, String>emptyMap();
        setResources(Collections.emptyMap(), bag);
      }
    } catch (IOException e) {
      LOG.log(Level.SEVERE, ""DataCatalogClient.listResources threw an IOException"", e);
    }
  }

  // The following properties are directly within the properties of the resource (not nested).
  // They are expected to be String values.
  private static final List<String> DIRECT_PROPERTIES =
      List.of(
          ""auth_enabled"",
          ""description"",
          ""display_name"",
          ""gcs_fileset_spec_file_patterns"",
          ""gcs_fileset_spec_sample_gcs_file_names"",
          ""gcs_fileset_spec_file_size_bytes"",
          ""hbase_table_spec_column_families"",
          ""hbase_table_spec_rowkey_column_spec_columns"",
          ""hive_metastore_database_spec_database_size_bytes"",
          ""hive_metastore_database_spec_table_count"",
          ""hive_metastore_partition_spec_partition_count"",
          ""hive_metastore_table_spec_column_count"",
          ""hive_metastore_table_spec_data_size_bytes"",
          ""hive_metastore_table_spec_row_count"",
          ""hostname"",
          ""ip_address"",
          ""language"",
          ""location"",
          ""os_build"",
          ""os_name"",
          ""os_version"",
          ""project_id"",
          ""schema_spec_columns"",
          ""update_time"",
          ""version"",
          ""zone"");

  // The properties are within nested properties of the form,
  // properties.{nested_property}.{property}.
  // They are expected to be List<String> values.
  private static final List<String> NESTED_PROPERTIES =
      List.of(""labels"", ""policy_tags"", ""usage"");

  // The properties are within nested properties of the form,
  // properties.{nested_property}.{nested_property}.{property}.
  private static final List<String> DOUBLY_NESTED_PROPERTIES =
      List.of(""bigquery_dataset_spec"", ""bigquery_table_spec"");

  // Private method to recursively load properties from a Resource object.
  private static void loadProperties(
      Map<String, String> properties, Map<Object, Object> bag) {
    // Load the map with the direct properties
    DIRECT_PROPERTIES.forEach(property -> bag.put(property, properties.get(property)));

    // Now check for properties within a nested properties map
    if (properties.containsKey(""nested_properties"")) {
      Map<String, String> nestedProperties = properties.get(""nested_properties"");
      NESTED_PROPERTIES.forEach(property -> bag.put(property, getNestedProperty(property, bag)));
    }

    // Now check for properties within a doubly nested properties map
    if (properties.containsKey(""doubly_nested_properties"")) {
      Map<String, String> doublyNestedProperties = properties.get(""doubly_nested_properties"");
      DOUBLY_NESTED_PROPERTIES.forEach(property -> bag.put(property, getDoublyNestedProperty(
          property, bag)));
    }
  }

  // Private method to recursively get a nested property of a Resource object.
  private static String getNestedProperty(String property, Map<Object, Object> bag) {
    return (String) bag.get(""nested_properties."" + property);
  }

  // Private method to recursively get a doubly nested property of a Resource object.
  private static String getDoublyNestedProperty(String property, Map<Object, Object> bag) {
    return (String) bag.get(""doubly_nested_properties."" + property);
  }

  /**
   * Java Serialization is a language-specific mechanism by which an object can be serialized into a
   * sequence of bytes. A class implements the Serializable interface to indicate it is serializable.
   * As of version 1.4 of the Java platform the object can also implement {@link
   * java.io.Externalizable} and override methods like writeExternal and readExternal to specify
   * a custom serialization mechanism. DataCatalog's Resource is serializable. However, since we
   * have implemented {@link java.io.Externalizable} we need to implement {@link #readExternal} and
   * {@link #writeExternal}. In these methods, we need to manually serialize and deserialize each
   * member field in the object.
   */
  public static class ResourceContainer implements Externalizable, Serializable {

    private Resource resource;

    /**
     * Default constructor is needed by the serialization/deserialization process. It should always
     * remain present, and generally it should avoid initializing non-transient fields. In this case,
     * we don't need to initialize any non-transient fields of our own, so just calling super() is
     * enough.
     */
    public ResourceContainer() {
      super();
    }

    // Constructor for when a Resource is being set on a ResourceContainer object.
    public ResourceContainer(Resource resource) throws IOException {
      this.resource = resource;
    }

    // No-op get method for data consistency.
    Resource get() {
      return resource;
    }

    // No-op set method for data consistency.
    void set(Resource resource) {
      this.resource = resource;
    }

    /**
     * The writeExternal method writes the state of this object to the stream for persistence. This
     * method first performs the default serialization to save the non-transient fields of the object.
     * Then it saves the transient fields, one by one.
     *
     * @param oos - output stream to write the object to.
     */
    @Override
    public void writeExternal(ObjectOutput oos) throws IOException {
      oos.writeObject(resource.getName());
      oos.writeObject(resource.getDescription());
      oos.writeObject(resource.getType());
      oos.writeObject(resource.getLinkedResource());
      oos.writeObject(resource.getPropertiesMap());
      oos.writeObject(resource.getLabelsMap());
      oos.writeObject(resource.getSchema());
      oos.writeObject(resource.getDisplayNamesList());
      oos.writeObject(resource.getDataplexSpecsList());
      oos.writeObject(resource.getLinkedResource());
      oos.writeObject(resource.getLineage().getProducersList());
      oos.writeObject"
105,"import static java.util.Arrays.asList;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class SettingsTest {

    @Mock Properties properties;
    @Mock Logger logger;

    private Settings settings;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        settings = new Settings(properties, logger);
    }

    @Test
    public void should_return_false_when_no_overrides_are_present() {
        assertFalse(settings.hasOverride(""foo""));
    }

    @Test
    public void should_override_a_property() {
        settings.overrideSetting(""foo"", ""bar"");
        when(properties.get(""foo"")).thenReturn(""bar"");
        assertEquals(""bar"", settings.getString(""foo""));
    }

    @Test
    public void should_override_a_property_from_map() {
        Map<String, String> overrides = mock(Map.class);
        when(overrides.get(""foo"")).thenReturn(""bar"");
        settings.overrideSettings(overrides);
        when(properties.get(""foo"")).thenReturn(""bar"");
        assertEquals(""bar"", settings.getString(""foo""));
    }

    @Test
    public void should_remove_overrides() {
        settings.overrideSetting(""foo"", ""bar"");
        settings.removeSetting(""foo"");
        assertNull(settings.getString(""foo""));
    }

    @Test
    public void should_not_save_properties_unless_overrides_are_present() {
        settings.saveSettings();
        verify(properties, never()).store(any(), any());
    }

    @Test
    public void should_save_properties_when_overrides_are_present() {
        settings.overrideSetting(""foo"", ""bar"");
        settings.saveSettings();
        verify(properties).store(any(), any());
    }

    @Test
    public void should_merges_overrides() {
        settings.overrideSetting(""foo"", ""bar"");
        settings.merge(asList(""a"", ""b"", ""c""));
        assertEquals(asList(""a"", ""b"", ""c"", ""foo""), settings.getAllKeys());
    }

    @Test
    public void should_remove_overrides() {
        settings.overrideSetting(""foo"", ""bar"");
        settings.removeSettings(asList(""foo""));
        assertNull(settings.getString(""foo""));
    }

    @Test
    public void should_reload_properties() {
        settings.overrideSetting(""foo"", ""bar"");
        settings.reload();
        assertNull(settings.getString(""foo""));
    }

    @Test
    public void should_return_null_for_unknown_property() {
        assertNull(settings.getString(""foo""));
    }

    @Test
    public void should_return_integer_property() {
        when(properties.getProperty(""foo"", ""3"")).thenReturn(""4"");
        assertEquals(4, settings.getInteger(""foo"", 3));
    }

    @Test
    public void should_return_string_property() {
        when(properties.getProperty(""foo"")).thenReturn(""bar"");
        assertEquals(""bar"", settings.getString(""foo""));
    }

    @Test
    public void should_return_empty_map_for_unknown_settings() {
        assertTrue(settings.getMap(""foo"").isEmpty());
    }

    @Test
    public void should_return_list_of_strings() {
        when(properties.getProperty(""foo"")).thenReturn(""one,two,three"");
        assertEquals(asList(""one"", ""two"", ""three""), settings.getStrings(""foo""));
    }

    @Test
    public void should_return_filesize_in_bytes() {
        assertEquals(1024, settings.getFilesize(""foo"", 1024));
    }

    @Test
    public void should_log_settings_changes() {
        when(properties.getProperty(""foo"")).thenReturn(""bar"");
        settings.getString(""foo"");
        verify(logger).debug(""Reading setting foo=bar"");
    }

    @Test(expected = IllegalArgumentException.class)
    public void should_throw_on_getting_unknown_required_property() {
        settings.getRequiredString(""foo"");
    }

    @Test
    public void should_return_long_property() {
        when(properties.getProperty(""foo"")).thenReturn(""42"");
        assertEquals(42L, settings.getLong(""foo"", 0L));
    }

    @Test
    public void should_return_char_property() {
        when(properties.getProperty(""foo"")).thenReturn(""a"");
        assertEquals('a', settings.getChar(""foo"", 'z'));
    }

    @Test
    public void should_return_required_string_property() {
        when(properties.getProperty(""foo"")).thenReturn(""bar"");
        assertEquals(""bar"", settings.getRequiredString(""foo""));
    }

    @Test
    public void should_return_all_keys() {
        when(properties.stringPropertyNames()).thenReturn(new java.util.HashSet<String>(asList(""foo"", ""bar"")));
        assertEquals(asList(""foo"", ""bar""), settings.getAllKeys());
    }

    @Test
    public void should_return_boolean_property() {
        when(properties.getProperty(""foo"")).thenReturn(""true"");
        assertTrue(settings.getBoolean(""foo"", false));
    }

    @Test
    public void should_return_list_of_integers() {
        when(properties.getProperty(""foo"")).thenReturn(""1,2,3"");
        assertEquals(asList(1, 2, 3), settings.getIntegers(""foo""));
    }

}"
106,"import java.util.Map;

public class ResourceTypeHandlerFinder {

    private final Map<String, ResourceTypeHandler> types;

    public ResourceTypeHandlerFinder(Map<String, ResourceTypeHandler> types) {
        this.types = types;
    }

    public ResourceTypeHandler valueOf(String name) {
        return types.get(name);
    }
}"
107,"import org.junit.Before;
import org.junit.Test;

import static org.mockito.Mockito.*;

public class DelegateTest {

    private NodeDelegator delegator;
    private NodeVisitor visitor;

    @Before
    public void setUp() {
        visitor = mock(NodeVisitor.class);
        delegator = new NodeDelegator(visitor);
    }

    @Test
    public void shouldCallUnhandledWhenCalledWithNullParameter() {
        delegator.handle(null);
        verify(visitor).unhandled();
    }

    @Test
    public void shouldCallTestDocumentTypeWhenNodeIsDocumentType() {
        delegator.handle(new DocumentTypeNode());
        verify(visitor).testDocumentType();
    }

    @Test
    public void shouldCallTestCommentWhenNode isComment() {
        delegator.handle(new CommentNode());
        verify(visitor).testComment();
    }

    @Test
    public void shouldCallTestNodeWhenNodeIsNode() {
        delegator.handle(new Node());
        verify(visitor).testNode();
    }

    @Test
    public void shouldCallTestElementWhenNodeIsElement() {
        delegator.handle(new ElementNode());
        verify(visitor).testElement();
    }

    @Test
    public void shouldCallTestEntityWhenNodeIsEntity() {
        delegator.handle(new EntityNode());
        verify(visitor).testEntity();
    }

    @Test
    public void shouldCallNoMoreNodesWhenNodeIsNull() {
        delegator.handle(null);
        verify(visitor).noMoreNodes();
    }

    @Test
    public void shouldCallTestAttributeWhenNodeIsAttribute() {
        delegator.handle(new AttributeNode());
        verify(visitor).testAttribute();
    }

    @Test
    public void shouldCallTestTextWhenNodeIsText() {
        delegator.handle(new TextNode());
        verify(visitor).testText();
    }

    @Test
    public void shouldCallTestEntityReferenceWhenNodeIsEntityReference() {
        delegator.handle(new EntityReferenceNode());
        verify(visitor).testEntityReference();
    }

    @Test
    public void shouldCallTestCDATASectionWhenNodeIsCDATASection() {
        delegator.handle(new CDATASectionNode());
        verify(visitor).testCDATASection();
    }

    @Test
    public void shouldCallTestProcessingInstructionWhenNodeIsProcessingInstruction() {
        delegator.handle(new ProcessingInstructionNode());
        verify(visitor).testProcessingInstruction();
    }
}"
108,"import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

public class RpcMetrics {
    private static AtomicInteger active = new AtomicInteger(0);
    private static AtomicLong total = new AtomicLong(0);
    private static AtomicLong failed = new AtomicLong(0);
    private static AtomicLong totalElapsed = new AtomicLong(0);
    private static AtomicLong failedElapsed = new AtomicLong(0);
    private static AtomicLong maxElapsed = new AtomicLong(0);
    private static AtomicLong failedMaxElapsed = new AtomicLong(0);
    private static AtomicLong succeededMaxElapsed = new AtomicLong(0);
    private static ConcurrentMap<String, RpcStatus> serviceStatistics = new ConcurrentHashMap<>();
    private static ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> methodStatistics = new ConcurrentHashMap<>();
    private static ConcurrentMap<String, Object> values = new ConcurrentHashMap<>();

    public static void beginCount() {
        active.incrementAndGet();
    }

    public static void endCount() {
        active.decrementAndGet();
    }

    public static int getActive() {
        return active.get();
    }

    public static long getTotal() {
        return total.get();
    }

    public static long getTotalElapsed() {
        return totalElapsed.get();
    }

    public static long getFailed() {
        return failed.get();
    }

    public static long getFailedElapsed() {
        return failedElapsed.get();
    }

    public static long getFailedMaxElapsed() {
        return failedMaxElapsed.get();
    }

    public static long getSucceeded() {
        return total.get() - failed.get();
    }

    public static long getSucceededElapsed() {
        return totalElapsed.get() - failedElapsed.get();
    }

    public static long getSucceededAverageElapsed() {
        return totalElapsed.get() == 0 ? 0 : totalElapsed.get() / total.get();
    }

    public static long getAverageTps() {
        return active.get() > 0 ? total.get() / active.get() : 0;
    }

    public static long getMaxElapsed() {
        return maxElapsed.get();
    }

    public static long getSucceededMaxElapsed() {
        return succeededMaxElapsed.get();
    }

    public static Object get(String key) {
        return values.get(key);
    }

    public static void set(String key, Object value) {
        values.put(key, value);
    }

    public static RpcStatus getStatus(String service, String method) {
        return methodStatistics.getOrDefault(service, Collections.emptyMap()).getOrDefault(method, null);
    }

    public static void removeStatus(String service, String method) {
        methodStatistics.getOrDefault(service, Collections.emptyMap()).remove(method);
    }

    protected static void addStatus(RpcStatus status) {
        total.incrementAndGet();
        totalElapsed.addAndGet(status.getElapsed());
        if (status.isFailed()) {
            failed.incrementAndGet();
            failedElapsed.addAndGet(status.getElapsed());
            if (status.getElapsed() > failedMaxElapsed.get()) {
                failedMaxElapsed.set(status.getElapsed());
            }
        } else {
            if (status.getElapsed() > succeededMaxElapsed.get()) {
                succeededMaxElapsed.set(status.getElapsed());
            }
        }
        if (status.getElapsed() > maxElapsed.get()) {
            maxElapsed.set(status.getElapsed());
        }
        serviceStatistics.put(status.getService(), status);
        ConcurrentMap<String, RpcStatus> serviceMethodStatus = methodStatistics.get(status.getService());
        if (serviceMethodStatus == null) {
            serviceMethodStatus = new ConcurrentHashMap<>();
            methodStatistics.put(status.getService(), serviceMethodStatus);
        }
        serviceMethodStatus.put(status.getMethod(), status);
    }
}"
109,
110,
111,"import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.cloud.storage.Blob;
import com.google.cloud.storage.BlobId;
import com.google.cloud.storage.Storage;
import com.google.cloud.storage.StorageException;
import com.google.cloud.storage.StorageOptions;

public class DownloadBlob {
  public static void downloadBlob(
      String projectId, String bucketName, String objectName, String destFilePath)
      throws IOException {
    // The ID of your GCP project
    // String projectId = ""your-project-id"";

    // The ID of your GCS bucket
    // String bucketName = ""your-unique-bucket-name"";

    // The ID of your GCS object
    // String objectName = ""your-object-name"";

    // The path to which the file should be downloaded
    // String destFilePath = ""/local/path/to/file.txt"";

    Storage storage = StorageOptions.newBuilder().setProjectId(projectId).build().getService();
    Blob blob = storage.get(BlobId.of(bucketName, objectName));
    ArrayList<String> parentList =
        new ArrayList<>(Arrays.asList(destFilePath.split(""/"")));
    parentList.remove(parentList.size() - 1);
    String parentPath = String.join(""/"", parentList);
    if (!java.nio.file.Files.exists(java.nio.file.Paths.get(parentPath))) {
      java.nio.file.Files.createDirectories(java.nio.file.Paths.get(parentPath));
    }
    blob.downloadTo(java.nio.file.Paths.get(destFilePath));

    System.out.println(
        ""Downloaded object ""
            + objectName
            + "" from bucket name ""
            + bucketName
            + "" to ""
            + destFilePath);
  }
}"
112,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Sha256Hash {

  private static final byte[] ZERO_HASH = toBytes(new byte[32]);
  private final byte[] bytes;

  private Sha256Hash(byte[] bytes) {
    this.bytes = bytes;
  }

  public static Sha256Hash createDouble(Sha256Hash left, Sha256Hash right) {
    byte[] buf = new byte[64];
    System.arraycopy(left.getBytes(), 0, buf, 0, 32);
    System.arraycopy(right.bytes, 0, buf, 32, 32);
    return new Sha256Hash(sha256(buf));
  }

  public static Sha256Hash create(byte[] bytes) {
    return new Sha256Hash(sha256(bytes));
  }

  public static boolean equals(Sha256Hash a, Sha256Hash b) {
    return a == b
        || (a != null
            && b != null
            && a.bytes.length == b.bytes.length
            && MessageDigest.isEqual(a.bytes, b.bytes));
  }

  public static Sha256Hash hashFileContents(String fileName) {
    try {
      MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
      java.io.FileInputStream fis = new java.io.FileInputStream(fileName);
      byte[] ba = new byte[8192];
      int read = fis.read(ba);
      while (-1 != read) {
        digest.update(ba, 0, read);
        read = fis.read(ba);
      }
      fis.close();
      return new Sha256Hash(digest.digest());
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public BigInteger toBigInteger() {
    return new BigInteger(1, bytes);
  }

  @Override
  public String toString() {
    return toHex(bytes);
  }

  public Sha256Hash duplicate() {
    return new Sha256Hash(bytes);
  }

  public int compareTo(Sha256Hash other) {
    return Lexicographic.compare(bytes, other.bytes);
  }

  public byte[] getBytes() {
    return bytes;
  }

  private static byte[] toBytes(BigInteger n) {
    byte[] bytes = new byte[32];
    byte[] src = n.toByteArray();
    System.arraycopy(src, 0, bytes, 32 - src.length, src.length);
    return bytes;
  }

  private static String toHex(byte[] bytes) {
    StringBuilder sb = new StringBuilder(bytes.length * 2);
    for (int i = 0; i < bytes.length; i++) {
      int b = bytes[i] & 0xFF;
      if (b < 0x10) sb.append(""0"");
      sb.append(Integer.toHexString(b));
    }
    return sb.toString();
  }

  private static byte[] sha256(byte[] bytes) {
    try {
      MessageDigest sha256 = MessageDigest.getInstance(""SHA-256"");
      sha256.update(bytes, 0, bytes.length);
      return sha256.digest();
    } catch (NoSuchAlgorithmException e) {
      throw new RuntimeException(e);
    }
  }

}"
113,"import java.lang.reflect.ConstantPoolHandle;

public class ConstantPoolHandleTest {

    public static void main(String[] args) {
        ConstantPoolHandle constantPoolHandle = ConstantPoolHandle.of(0, 0);
        System.out.println(constantPoolHandle.getTag());
        System.out.println(constantPoolHandle.hashCode());
        System.out.println(constantPoolHandle.equals(constantPoolHandle));
        System.out.println(constantPoolHandle.getValue());
    }
}"
114,"import com.google.common.primitives.Ints;
import org.bitcoinj.core.Block;
import org.bitcoinj.core.Context;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.StoredBlock;
import org.bitcoinj.core.Transaction;
import org.bitcoinj.core.Utils;
import org.bitcoinj.params.MainNetParams;
import org.bitcoinj.script.Script;
import org.bitcoinj.store.BlockStoreException;
import org.bitcoinj.utils.MonetaryFormat;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.util.Arrays;

/**
 * <p>A block header is the ""control structure"" of a block. Block headers are stored in a chain of
 * {@link Block} objects, and are used to verify individual blocks and the entire blockchain.</p>
 *
 * <p>Block headers include the following information:</p>
 *
 * <ol>
 *     <li>version: A number that identifies the version of the block header, eg 1, 2 or 3.</li>
 *     <li>previous block: A reference to the previous block on the blockchain as a {@link Sha256Hash},
 *     which is used to link blocks together.</li>
 *     <li>merkle root: A hash of all the contents of the block held in a merkle tree, which is a
 *     hierarchical data structure used to represent large amounts of data efficiently.</li>
 *     <li>timestamp: A UNIX timestamp recording the time the block was found, represented as milliseconds
 *     since 1970-01-01T00:00:00Z.</li>
 *     <li>difficulty target: A value used in the Bitcoin mining process to determine how difficult it is to
 *     mine a block.</li>
 *     <li>nonce: A random 32-bit number (in most cases) used in the Bitcoin mining process to find a
 *     number that, when hashed with the rest of the block, is lower than the target difficulty.</li>
 * </ol>
 *
 * <p>Each block also features a Merkle tree of all the transactions in the block, and a field to record the number of
 * transactions in the block. The Merkle tree construction can be slow, especially for large blocks. Blocks
 * therefore allow the construction to be skipped: if this flag is set the {@link #transactions} field
 * will be null and you must compute them yourself. However, even if this is set, you can get around doing
 * the actual computation by using {@link #getHashOfMerkleRoot()} which will return the Merkle
 * root without needing to calculate the whole tree.</p>
 *
 * <p>Block headers are an essential part of the Bitcoin distributed ledger, and form the core of the blockchain
 * technology that underlies crypto-currencies like Bitcoin.</p>
 *
 * <p>Instances of this class are not safe for use by multiple threads.</p>
 */
public class StoredBlock implements Serializable {
    public static final byte[] EMPTY_BYTES = new byte[0];
    private static final int COMPACT_SERIALIZED_SIZE = 80;
    private static final long serialVersionUID = -7992198302959340348L;
    // TODO: consider making a BLOCK_HEADER_SIZE (eg 80) and move the constant into Block
    private static final int CHAIN_WORK_BYTES = 32;

    private Header header;
    private byte[] compactEncoding;

    // The building blocks for the header. Only stored if serializing this block to a compact
    // representation
    private byte[] versionBytes;
    private byte[] prevBlockHashBytes;
    private byte[] merkleRootHashBytes;
    private byte[] timeBytes;
    private byte[] difficultyTargetBytes;
    private byte[] nonceBytes;

    /**
     * Constructs a new block header by deserializing the passed-in array.
     * @param compactEncoding the compact encoding of the block header
     * @param length the length of the array to deserialize
     * @throws BlockStoreException if the serialization format is unknown or invalid
     */
    public StoredBlock(final byte[] compactEncoding, int length) throws BlockStoreException {
        this.compactEncoding = compactEncoding;
        if (length != compactEncoding.length) {
            throw new BlockStoreException(String.format(""Incorrect compact block length: %d vs %d"", length, compactEncoding.length));
        }
        // Parse as little-endian.
        try {
            final ByteBuffer buffer = ByteBuffer.wrap(compactEncoding, 0, length).order(ByteOrder.LITTLE_ENDIAN);
            versionBytes = new byte[4];
            buffer.get(versionBytes, 0, 4);
            prevBlockHashBytes = new byte[32];
            buffer.get(prevBlockHashBytes, 0, 32);
            merkleRootHashBytes = new byte[32];
            buffer.get(merkleRootHashBytes, 0, 32);
            timeBytes = new byte[4];
            buffer.get(timeBytes, 0, 4);
            difficultyTargetBytes = new byte[4];
            buffer.get(difficultyTargetBytes, 0, 4);
            nonceBytes = new byte[4];
            buffer.get(nonceBytes, 0, 4);
        } catch (BufferUnderflowException e) {
            throw new BlockStoreException(""Could not parse compact block"", e);
        }
    }

    /** Constructs a block header with the given attributes. */
    public StoredBlock(Block header) {
        this.header = header;
    }

    /** The version of the block header, usually 1, 2 or 3. */
    public int getVersion() {
        return Utils.readBytesToInt(versionBytes, 0);
    }

    /** The hash of the previous block header in the block chain, as a {@link Sha256Hash}. */
    public Sha256Hash getPrevBlockHash() {
        return Sha256Hash.wrap(prevBlockHashBytes);
    }

    /** The merkle root for this block. */
    public Sha256Hash getMerkleRoot() {
        return Sha256Hash.wrap(merkleRootHashBytes);
    }

    /**
     * Return the merkle tree as a hash of hashes. Not to be confused with getMerkleRoot()
     * which is a hash of the leaf-most nodes in the merkle tree.
     */
    public Sha256Hash getHashOfMerkleRoot() {
        return new Sha256Hash(header.getHashOfMerkleRoot());
    }

    /**
     * The time at which the block was found. This is represented as a UNIX timestamp
     * as milliseconds since 1970-01-01T00:00:00Z.
     */
    public long getTimeSeconds() {
        return Utils.readBytesToLong(timeBytes, 0);
    }

    /**
     * The difficulty target as it was at the time the block was found. This is used
     * in the Bitcoin mining process.
     */
    public BigInteger getDifficultyTarget() {
        return Utils.readBytesToBigInteger(difficultyTargetBytes, 0);
    }

    /** The nonce used to mine the block. */
    public long getNonce() {
        return Utils.readBytesToLong(nonceBytes, 0);
    }

    /** The height in the block chain, if known. This is not computed by default. */
    public int getHeight() {
        return header.getHeight();
    }

    /**
     * The chain work for this block and its descendents, if known.
     * If the chain work was not computed before, recomputes and caches it.
     *
     * @throws BlockStoreException if the chain height is unknown
     */
    public BigInteger getChainWork() throws BlockStoreException {
        if (header.getChainWork() == null)
            throw new BlockStoreException(""Chain work unknown for block "" + header.getHashAsString());
        return header.getChainWork();
    }

    /**
     * The total amount of work represented by this header and all its parents. Not to be
     * confused with the difficulty target, which is a value used in Bitcoin mining.
     *
     * @param height the height of this block in the chain
     * @return the total amount of work represented by this header and all its parents
     */
    public BigInteger getChainWork(int height) {
        return header.getChainWork(height);
    }

    /**
     * The serialized"
115,"import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = ""FCKeditorConfig"", value = ""/FCKeditorConfig"")
public class FCKeditorConfigServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String toolbarSet = request.getParameter(""toolbarSet"");
        String instanceName = request.getParameter(""instanceName"");
        String height = request.getParameter(""height"");
        String basePath = request.getParameter(""basePath"");
        FCKeditorConfig config = new FCKeditorConfig();
        String value = request.getParameter(""value"");
        String width = request.getParameter(""width"");
        String createHtml = request.getParameter(""createHtml"");
        config.setInstanceName(instanceName);
        config.setValue(value);
        config.escapeXml();
        config.createInputForVariable();
        config.toString();
        config.setToolbarSet(toolbarSet);
        config.setBasePath(basePath);
        config.setWidth(width);
        config.setHeight(height);
        config.setConfig(config);
    }
}"
116,"import java.util.List;

public class RefactorEdition {
    private List<Edition> editions;

    public List<Edition> getEditions() {
        return editions;
    }

    public void setEditions(List<Edition> editions) {
        this.editions = editions;
    }

    public Difference getAdditionDifference() {
        return null;
    }

    public void setAdditionDifference(Difference additionDifference) {
    }

    public Difference getDeletionDifference() {
        return null;
    }

    public void setDeletionDifference(Difference deletionDifference) {
    }
}"
117,"package net.sourceforge.plantuml.activitydiagram3.ftile;

class FtileShapeLoader {

	public String toString() {
		// TODO Auto-generated method stub
		return null;
	}

	/**
	 * @return The maximum number of notations that can be added to an FTileShape
	 */
	public static int maxNotations() {
		// TODO Auto-generated method stub
		return 0;
	}

}"
118,"void pop_transfer() {
    if (real_stack.empty()) {
        throw new RuntimeException(""Real stack is empty"");
    }
    int next = real_stack.pop();
    vstack.push(new Symbol(next));
}"
119,"import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertThrows;

@RunWith(JUnit4.class)
public class ListenableFuture_GetUninterruptibly_Test {

  private CountDownLatch countDownLatch;
  private ListenableFuture<?> future;

  @Before
  public void setUp() throws Exception {
    countDownLatch = new CountDownLatch(1);
    future = ListenableFutures.create();
  }

  @After
  public void tearDown() {
    assertTrue(future.isDone());
  }

  @Test
  public void getUninterruptibly_isDone_returnsResult() throws Exception {
    future.addCallback(
        new FutureCallback<Object>() {
          @Override
          public void onSuccess(Object result) {
            countDownLatch.countDown();
          }

          @Override
          public void onFailure(Throwable t) {
            fail(t.toString());
          }
        });

    future.set(new Object());
    countDownLatch.await(4, TimeUnit.SECONDS);

    assertThat(future.getUninterruptibly()).isEqualTo(new Object());
  }

  @Test
  public void getUninterruptibly_isNotDone_returnsResult() throws Exception {
    future.addCallback(
        new FutureCallback<Object>() {
          @Override
          public void onSuccess(Object result) {
            countDownLatch.countDown();
          }

          @Override
          public void onFailure(Throwable t) {
            fail(t.toString());
          }
        });

    new Thread() {
      @Override
      public void run() {
        try {
          Thread.sleep(500);
          future.set(new Object());
          countDownLatch.countDown();
        } catch (InterruptedException e) {
          fail(e.toString());
        }
      }
    }.start();

    assertThat(future.getUninterruptibly()).isEqualTo(new Object());
  }

  @Test
  public void getUninterruptibly_isNotDone_timesOut() throws Exception {
    TimeoutException exception =
        assertThrows(TimeoutException.class, () -> future.getUninterruptibly(500, TimeUnit.MILLISECONDS));
    assertThat(exception).hasMessageThat().isEqualTo(""getUninterruptibly timed out"");
  }

  @Test
  public void getUninterruptibly_setException() throws Exception {
    future.addCallback(
        new FutureCallback<Object>() {
          @Override
          public void onSuccess(Object result) {
            fail(""Should throw"");
          }

          @Override
          public void onFailure(Throwable t) {
            countDownLatch.countDown();
          }
        });

    future.setException(new Exception());
    countDownLatch.await();

    Exception actual = assertThrows(Exception.class, () -> future.getUninterruptibly());
    assertThat(actual).isEqualTo(new Exception());
  }
}"
120,"import java.util.ArrayList;

public class GisticRecord {

    private int internalId;
    private boolean amplified;
    private boolean deleted;
    private int gisticID;
    private int peakStart;
    private ArrayList<CanonicalGene> genes_in_ROI;
    private String cytoband;
    private int NO_SUCH_GISTIC;
    private int cancerStudyId;
    private int chromosome;
    private int peakEnd;
    private double qValue;

    public void setPeakEnd(int peakEnd) {
        this.peakEnd = peakEnd;
    }

    public void setAmp(boolean amp) {
        this.amplified = amp;
    }

    public String getCytoband() {
        return cytoband;
    }

    public void setPeakStart(int peakStart) {
        this.peakStart = peakStart;
    }

    public int getPeakStart() {
        return peakStart;
    }

    public void setqValue(double qValue) {
        this.qValue = qValue;
    }

    public boolean getAmp() {
        return amplified;
    }

    public int getInternalId() {
        return internalId;
    }

    public void setGenes_in_ROI(ArrayList<CanonicalGene> genes_in_ROI) {
        this.genes_in_ROI = genes_in_ROI;
    }

    public int peakSize() {
        return peakEnd - peakStart + 1;
    }

    public int getCancerStudyId() {
        return cancerStudyId;
    }

    public int getChromosome() {
        return chromosome;
    }

    public int getPeakEnd() {
        return peakEnd;
    }

    public void addGene(CanonicalGene gene) {
        genes_in_ROI.add(gene);
    }

    public void setCancerStudyId(int cancerStudyId) {
        this.cancerStudyId = cancerStudyId;
    }

    public double getqValue() {
        return qValue;
    }

    @Override
    public String toString() {
        return ""GisticRecord{"" +
                ""internalId="" + internalId +
                "", amplified="" + amplified +
                "", deleted="" + deleted +
                "", gisticID="" + gisticID +
                "", peakStart="" + peakStart +
                "", genes_in_ROI="" + genes_in_ROI +
                "", cytoband='"" + cytoband + '\' +
                "", NO_SUCH_GISTIC="" + NO_SUCH_GISTIC +
                "", cancerStudyId="" + cancerStudyId +
                "", chromosome="" + chromosome +
                "", peakEnd="" + peakEnd +
                "", qValue="" + qValue +
                '}';
    }

    public ArrayList<CanonicalGene> getGenes_in_ROI() {
        return genes_in_ROI;
    }

    public void setCytoband(String cytoband) {
        this.cytoband = cytoband;
    }

    public void setChromosome(int chromosome) {
        this.chromosome = chromosome;
    }
}"
121,"import java.util.Map;
import java.util.ConcurrentHashMap;
import java.util.function.LongBinaryOperator;
import java.util.function.LongUnaryOperator;

class AtomicLongMap<K> {

    private final ConcurrentHashMap<K, Long> map;

    public AtomicLongMap() {
        map = new ConcurrentHashMap<>();
    }

    public long getAndIncrement(K key) {
        return map.computeIfAbsent(key, k -> 0L).incrementAndGet();
    }

    public long incrementAndGet(K key) {
        return map.computeIfAbsent(key, k -> 0L).getAndIncrement() + 1;
    }

    public Map<K, Long> createAsMap() {
        return map;
    }

    public Map<K, Long> asMap() {
        return map;
    }

    public boolean removeIfZero(K key) {
        return map.remove(key, 0L);
    }

    public boolean replace(K key, long oldValue, long newValue) {
        return map.replace(key, oldValue, newValue);
    }

    public long decrementAndGet(K key) {
        return map.computeIfAbsent(key, k -> 0L).getAndDecrement() - 1;
    }

    public long updateAndGet(K key, LongUnaryOperator updateFunction) {
        return map.computeIfAbsent(key, k -> 0L).getAndUpdate(updateFunction);
    }

    public long sum() {
        return map.values().stream().mapToLong(Long::longValue).sum();
    }

    public long put(K key, long value) {
        return map.put(key, value);
    }

    public long remove(K key) {
        return map.remove(key);
    }

    public boolean remove(K key, long value) {
        return map.remove(key, value);
    }

    public void removeAllZeros() {
        map.entrySet().removeIf(entry -> entry.getValue() == 0L);
    }

    public long get(K key) {
        return map.getOrDefault(key, 0L);
    }

    public void putAll(Map<K, Long> m) {
        map.putAll(m);
    }

    public static <K> AtomicLongMap<K> create() {
        return new AtomicLongMap<>();
    }

    public static <K> AtomicLongMap<K> create(Map<K, Long> map) {
        AtomicLongMap<K> atomicLongMap = new AtomicLongMap<>();
        atomicLongMap.putAll(map);
        return atomicLongMap;
    }

    public long getAndAdd(K key, long delta) {
        return map.computeIfAbsent(key, k -> 0L).getAndAdd(delta);
    }

    public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {
        return map.computeIfAbsent(key, k -> 0L).getAndAccumulate(x, accumulatorFunction);
    }

    public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {
        return map.computeIfAbsent(key, k -> 0L).accumulateAndGet(x, accumulatorFunction);
    }

    public boolean containsKey(K key) {
        return map.containsKey(key);
    }

    public boolean isEmpty() {
        return map.isEmpty();
    }

    public void clear() {
        map.clear();
    }

    public int size() {
        return map.size();
    }

    @Override
    public String toString() {
        return map.toString();
    }

    public long getAndUpdate(K key, LongUnaryOperator updateFunction) {
        return map.computeIfAbsent(key, k -> 0L).getAndUpdate(updateFunction);
    }

    public long getAndDecrement(K key) {
        return map.computeIfAbsent(key, k -> 0L).getAndDecrement() - 1;
    }

    public long putIfAbsent(K key, long value) {
        return map.putIfAbsent(key, value);
    }
}"
122,"import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.services.compute.ComputeScopes;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import com.google.cloud.compute.v1.ForwardingRule;
import com.google.cloud.compute.v1.ForwardingRule.ServiceLabel;
import com.google.cloud.compute.v1.Instance;
import com.google.cloud.compute.v1.Instance.Status;
import com.google.cloud.compute.v1.InstanceGroupsClient;
import com.google.cloud.compute.v1.InstancesClient;
import com.google.cloud.compute.v1.Network;
import com.google.cloud.compute.v1.Operation;
import com.google.cloud.compute.v1.Region;
import com.google.cloud.compute.v1.RegionBackendService;
import com.google.cloud.compute.v1.RegionDisksClient;
import com.google.cloud.compute.v1.RegionInstanceGroupsClient;
import com.google.cloud.compute.v1.RegionSslCertificatesClient;
import com.google.cloud.compute.v1.RegionTargetHttpsProxiesClient;
import com.google.cloud.compute.v1.RegionTargetHttpsProxiesSetUrlMapRequest;
import com.google.cloud.compute.v1.RegionUrlMapsClient;
import com.google.cloud.compute.v1.RegionUrlMapsInsertRequest;
import com.google.cloud.compute.v1.RegionUrlMapsPatchRequest;
import com.google.cloud.compute.v1.SshKey;
import com.google.cloud.compute.v1.Subnetwork;
import com.google.cloud.compute.v1.TargetHttpsProxy;
import com.google.cloud.compute.v1.UrlMap;
import com.google.protobuf.util.JsonFormat;
import java.io.IOException;
import java.net.Socket;
import java.util.Collections;

public class Sshexample {

  private static final String PROJECT_ID = ""YOUR_PROJECT_ID"";
  private static final String ZONE = ""europe-central2-b"";
  private static final String NETWORK_NAME = ""global/networks/default"";
  // Use a non-default subnetwork name to avoid conflicts.
  private static final String SUBNETWORK_NAME = ""non-default-subnetwork"";

  // Use a non-default instance name to avoid conflicts.
  private static final String INSTANCE_NAME = ""sshexample-instance"";
  private static final String INSTANCE_USERNAME = ""my-user"";
  private static final String INSTANCE_IMAGE =
      String.format(""projects/%s/global/images/family/%s"", ""debian-cloud"", ""debian-9"");
  // The URL for the ssh key used in the VM instance.
  // See https://cloud.google.com/compute/docs/instances/creating-managing-ssh-keys
  private static final String SSH_KEY_URL =
      ""https://www.googleapis.com/compute/v1/projects/""
          + PROJECT_ID
          + ""/global/sshKeys/my-ssh-key"";
  private static final Integer INSTANCE_PORT = 22;

  private static final String REGION = ""europe-central2"";
  private static final String HTTP_PORT = ""80"";
  private static final String HTTPS_PORT = ""443"";
  // Use a non-default backend service name to avoid conflicts.
  private static final String BACKEND_SERVICE_NAME = ""sshexample-backend-service"";
  private static final String HEALTH_CHECK_NAME = ""backing-checking-health"";
  private static final String PROXY_NAME = ""sshexample-proxy"";
  // Use a non-default target https proxy name to avoid conflicts.
  private static final String HTTPS_PROXY_NAME = ""sshexample-https-proxy"";
  // Use a non-default URL map name to avoid conflicts.
  private static final String URL_MAP_NAME = ""sshexample-url-map"";

  static class HttpResponse {
    private int responseCode;
    private String responseMessage;

    public int getResponseCode() {
      return responseCode;
    }

    public String getResponseMessage() {
      return responseMessage;
    }
  }

  /** This is a simple example of using Google Compute Engine API to create an instance,
   * allow SSH traffic over port 22 (not recommended for production), and print instance details. */
  public static void main(String... args) throws Exception {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the `instancesClient.close()` method on the client to safely
    // clean up any remaining background resources.
    // For more on the best practices for authenticating to a service account, see:
    // https://cloud.google.com/docs/authentication/production#finding_credentials_automatically
    try (InstancesClient instancesClient = InstancesClient.create(getHttpCredentialsAdapter());
        RegionInstancesClient regionInstancesClient = RegionInstancesClient.create(getHttpCredentialsAdapter());
        RegionInstanceGroupsClient regionInstanceGroupsClient = RegionInstanceGroupsClient.create(getHttpCredentialsAdapter());
        RegionUrlMapsClient regionUrlMapsClient = RegionUrlMapsClient.create(getHttpCredentialsAdapter());
        RegionTargetHttpsProxiesClient regionTargetHttpsProxiesClient = RegionTargetHttpsProxiesClient.create(getHttpCredentialsAdapter());
        RegionBackendService regionBackendServiceClient = RegionBackendService.create(getHttpCredentialsAdapter());
        RegionSslCertificatesClient regionSslCertificatesClient = RegionSslCertificatesClient.create(getHttpCredentialsAdapter());
        RegionDisksClient regionDisksClient = RegionDisksClient.create(getHttpCredentialsAdapter())) {

      // Create the disk for the instance
      diskCreate(regionDisksClient, ZONE, INSTANCE_NAME);

      // Create the instance
      instanceCreate(instancesClient, ZONE, INSTANCE_NAME, INSTANCE_IMAGE, SSH_KEY_URL, INSTANCE_PORT);

      // Create the instance group
      instanceGroupCreate(regionInstanceGroupsClient, REGION, proxyCreate(regionTargetHttpsProxiesClient, REGION, HTTPS_PROXY_NAME));

      // Add the instance to the instance group
      instanceGroupAddInstance(regionInstanceGroupsClient, REGION, INSTANCE_NAME, proxyCreate(regionTargetHttpsProxiesClient, REGION, HTTPS_PROXY_NAME));

      // Create the backend service
      backendServiceCreate(regionBackendServiceClient, REGION, BACKEND_SERVICE_NAME);

      // Add the backend service to the instance groups
      backendServicePut(regionInstanceGroupsClient, REGION, BACKEND_SERVICE_NAME, getRegionInstanceGroupsResponse(regionInstanceGroupsClient, REGION).getId());

      // Create the url map
      urlMapCreate(regionUrlMapsClient, REGION, URL_MAP_NAME, getBackendServiceInfo(regionBackendServiceClient, REGION, BACKEND_SERVICE_NAME));

      // Update the target https proxy to use the new url map
      targetHttpsProxiesSetUrlMap(regionTargetHttpsProxiesClient, REGION, HTTPS_PROXY_NAME, getRegionUrlMapsResponse(regionUrlMapsClient, REGION).getId());

      // Ssh to the instance and print instance details
      try (Socket socket = new Socket(getInstanceIp(instancesClient, ZONE, INSTANCE_NAME), INSTANCE_PORT)) {
        System.out.println(String.format(""Connected to instance %s at %s."", INSTANCE_NAME, getInstanceIp(instancesClient, ZONE, INSTANCE_NAME)));
        connected();

        // You can send commands to the instance using the Socket, however
        // this method doesn't do that and instead closes the connection after a few seconds.
        System.out.println(""Waiting 10 seconds and closing ssh connection."");
        Thread.sleep(10000);
      } catch (Exception e) {
        disconnected();
        throw e;
      } finally {
        dataReceived(0);
      }
    }
  }

  static RegionInstanceGroupsResponse getRegionInstanceGroupsResponse(RegionInstanceGroupsClient client, String region) throws IOException {
    RegionInstanceGroupsGetResponse response = client.get(REGION, ""sshexample-instance-group"");
    System.out.println(response.toPrettyString());
    return response.getPage();
  }

  static RegionUrlMapsResponse getRegionUrlMapsResponse(RegionUrlMapsClient client, String region) throws IOException {
    RegionUrlMapsGetResponse response = client.get(REGION, URL_MAP_NAME);
    System.out.println(response.toPrettyString());
    return response.getPage();
  }

  static Region"
123,"import java.util.List;
import java.util.Iterator;

class PluginContainer {
    public List<PluginManagerListener> listeners;
}

class Logger {
}

class PluginManager {
    public static PluginManager getInstance() {
        return null;
    }
}

class AbstractPlugin {
}

class PluginManagerListener {
    public void pluginStateChanged(String var1, AbstractPlugin var2) {
    }
}"
124,"import com.google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseServiceClient;
import com.google.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest;
import com.google.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse;
import com.google.recaptchaenterprise.v1.ProjectName;
import com.google.recaptchaenterprise.v1.RelatedAccountGroup;
import java.io.IOException;

public class ListRelatedAccountGroups {

  public static void main(String[] args) throws IOException {
    // TODO(developer): Replace these variables before running the sample.
    String project = ""project-id"";
    String recaptchaSiteKey = ""recaptcha-site-key"";
    listRelatedAccountGroups(project, recaptchaSiteKey);
  }

  // Lists the related account groups for a specific project.
  public static void listRelatedAccountGroups(String project, String recaptchaSiteKey)
      throws IOException {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (RecaptchaEnterpriseServiceClient client = RecaptchaEnterpriseServiceClient.create()) {
      ProjectName parent = ProjectName.of(project);
      ListRelatedAccountGroupsRequest request =
          ListRelatedAccountGroupsRequest.newBuilder()
              .setParent(parent.toString())
              .setRecaptchaSiteKey(recaptchaSiteKey)
              .build();

      ListRelatedAccountGroupsResponse response = client.listRelatedAccountGroups(request);
      for (RelatedAccountGroup group : response.getRelatedAccountGroupsList()) {
        System.out.println(""Retrieved related account group: "" + group.getName());
      }
    }
  }
}"
125,"netImpl.bindSocket(
            streaming,
            localServiceID,
            address,
            remoteServiceID,
            fd.getInetAddress(),
            fd.getServiceID(),
            (aBoolean, aBoolean1) -> {},
            (aBoolean, aBoolean2) -> {});"
126,"/**
   * test of getresponsestringcsv method, of class LogEntryRequest.
   */
  @Test
  public void testGetresponsestringcsv() {
    LogEntryRequest instance = new LogEntryRequest();
    instance.setresponsestringcsv(""response"");

    String expResult = ""response"";
    String result = instance.getresponsestringcsv();
    assertEquals(expResult, result);
  }"
127,"Button button = new Button.Builder()
                .setId(buttonId)
                .setText(buttonText)
                .setImageProvider(ImageProvider.createStaticImageProvider(imageUri))
                .build();"
128,"import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.protobuf.ByteString;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import org.bitcoinj.core.Block;
import org.bitcoinj.core.CheckpointManager;
import org.bitcoinj.core.NetworkParameters;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.StoredBlock;
import org.bitcoinj.core.Utils;
import org.bitcoinj.utils.BloomFilter;
import org.bitcoinj.utils.Threading;
import org.bitcoinj.wallet.Protos;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>A {@link CheckpointManager} implementation which stores its checkpoints in a sorted map.
 * This implementation is suitable for applications which need a fast way to access all checkpoints.
 * Please note that checkpoints can only be added during the {@link #open()} method.</p>
 *
 * <p>The checkpoints are stored as a list of block hashes and their corresponding filter hash bits.
 * The filter hash bits are used to verify that a block is related to the stored checkpoints.
 * If the block does not match the filter hash bits, it is ignored.</p>
 *
 * <p>The checkpoints are stored in a file named "".checkpoints"" in the application's data directory.
 * The file is written using the {@link BaseEncoding#BASE64} format.</p>
 */
public class FastMapCheckpointManager extends CheckpointManager {
    private static final Logger log = LoggerFactory.getLogger(FastMapCheckpointManager.class);
    private static final String TEXTUAL_MAGIC = ""Checkpoint::"";
    private static final int MAX_SIGNATURES = 100;
    private static final String BINARY_MAGIC = ""CHECK"";

    /** The checkpoints, sorted by block height. */
    private final TreeMap<Long, StoredBlock> checkpoints = Maps.newTreeMap();
    private final Set<StoredBlock> checkpointSet = Sets.newHashSet();

    public FastMapCheckpointManager(NetworkParameters params) {
        super(params);
    }

    @Override
    protected boolean addCheckpoint(long height, Sha256Hash hash) {
        // Checkpoints can only be added during the open() method.
        return false;
    }

    @Override
    public void open() {
        // We can't access the params object until this method is called.
        if (params.getId().equals(NetworkParameters.ID_MAINNET)) {
            // Load checkpoints from a file.
            try (InputStream stream = Utils.getContextClassLoader().getResourceAsStream(""checkpoints.txt"")) {
                loadFromTextualFile(stream);
            } catch (IOException e) {
                throw new RuntimeException(""Could not open checkpoints.txt: "" + e.getMessage(), e);
            }
        }
    }

    /**
     * Loads the checkpoints from a textual file.
     *
     * @param stream The stream to load the checkpoints from.
     * @throws IOException If there is an error reading the stream.
     */
    private void loadFromTextualFile(InputStream stream) throws IOException {
        byte[] bytes = Utils.readFully(stream);
        String checkpointsText = new String(bytes, ""UTF-8"");
        if (!checkpointsText.startsWith(TEXTUAL_MAGIC)) {
            throw new IllegalArgumentException(
                ""Invalid checkpoints file format: "" + Arrays.toString(bytes));
        }
        checkpointsText = checkpointsText.substring(TEXTUAL_MAGIC.length());

        // Split the checkpoint data into individual lines.
        String[] lines = checkpointsText.split(""\n"");

        // Parse each line into a checkpoint object.
        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty() || line.startsWith(""#"")) {
                continue;
            }

            // Parse the checkpoint data.
            String[] parts = line.split("":"");
            if (parts.length != 2) {
                throw new IllegalArgumentException(""Invalid checkpoint line: "" + line);
            }

            long height = Long.parseLong(parts[0]);
            Sha256Hash hash = Sha256Hash.wrap(parts[1]);

            // Add the checkpoint to the map.
            checkpoints.put(height, new StoredBlock(hash, height));
        }

        log.info(""Loaded {} checkpoints from file."", checkpoints.size());
    }

    @Override
    public void close() {
        // Nothing to do.
    }

    /**
     * Returns a hash of the concatenated checkpoint data.
     *
     * @return The hash of the concatenated checkpoint data.
     */
    public Sha256Hash dataHash() {
        // Concatenate the checkpoint data.
        StringBuilder checkpointData = new StringBuilder();
        for (StoredBlock checkpoint : checkpoints.values()) {
            checkpointData.append(checkpoint.getHeader().getHash()).append("":"");
        }

        // Hash the checkpoint data.
        return Sha256Hash.twiceOf(checkpointData.toString().getBytes());
    }

    /**
     * Reads a textual checkpoint file.
     *
     * @param stream The stream to read the checkpoint file from.
     * @return A hash of the concatenated checkpoint data.
     * @throws IOException If there is an error reading the stream.
     */
    public Sha256Hash readTextual(InputStream stream) throws IOException {
        // Read the checkpoint data from the stream.
        byte[] bytes = Utils.readFully(stream);
        String checkpointsText = new String(bytes, ""UTF-8"");
        if (!checkpointsText.startsWith(TEXTUAL_MAGIC)) {
            throw new IllegalArgumentException(
                ""Invalid checkpoints file format: "" + Arrays.toString(bytes));
        }

        // Split the checkpoint data into individual lines.
        String[] lines = checkpointsText.substring(TEXTUAL_MAGIC.length()).split(""\n"");

        // Parse each line into a checkpoint object.
        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty() || line.startsWith(""#"")) {
                continue;
            }

            // Parse the checkpoint data.
            String[] parts = line.split("":"");
            if (parts.length != 2) {
                throw new IllegalArgumentException(""Invalid checkpoint line: "" + line);
            }

            long height = Long.parseLong(parts[0]);
            Sha256Hash hash = Sha256Hash.wrap(parts[1]);

            // Add the checkpoint to the map.
            checkpoints.put(height, new StoredBlock(hash, height));
        }

        // Return the hash of the concatenated checkpoint data.
        return dataHash();
    }

    /**
     * Reads a binary checkpoint file.
     *
     * @param stream The stream to read the checkpoint file from.
     * @return A hash of the concatenated checkpoint data.
     * @throws IOException If there is an error reading the stream.
     */
    public Sha256Hash readBinary(InputStream stream) throws IOException {
        // Read the checkpoint data from the stream.
        byte[] bytes = Utils.readFully(stream);
        if (bytes.length < 8) {
            throw new IllegalArgumentException(""Invalid checkpoint file format: "" + Arrays.toString(bytes));
        }

        // Check the magic number.
        String magic = new String(bytes, 0, 4, ""US-ASCII"");
        if (!magic.equals(BINARY_MAGIC)) {
            throw new IllegalArgumentException(
                ""Invalid checkpoints file format: "" + Arrays.toString(bytes));
        }

        // Read the checkpoint count.
        int count = (int) Utils.readUint32(bytes, 4);
        if (count > MAX_SIGNATURES) {
            throw new IllegalArgumentException(""Invalid checkpoint file format: too many checkpoints"");
        }

        // Read the checkpoints.
        for (int i = 0; i < count; i++) {
            // Read the checkpoint data.
            long height = Utils.readUint32(bytes, 8 + i * 8);
            byte[] hashBytes = Arrays.copyOfRange(bytes, 12 + i * 8, 40 + i * 8);
            Sha256Hash hash = Sha256Hash.wrap(hashBytes);

            // Add the checkpoint to the map.
            checkpoints.put(height, new StoredBlock(hash, height));
        }

        // Return the hash of the concatenated checkpoint data.
        return dataHash();"
129,"import java.io.ByteArrayOutputStream;
import java.io.IOException;

class PackFormatInputStream {

    private final ByteArrayOutputStream packed;
    private final String format;

    PackFormatInputStream(String format) {
        this.packed = new ByteArrayOutputStream();
        this.format = format;
    }

    void addValue(byte value) throws IOException {
        packed.write(value);
    }

    void packLong() throws IOException {
        packed.write(Integer.reverseBytes(packed.size()));
    }

    void addShort(short value) throws IOException {
        packed.write(value >> 8);
        packed.write(value);
    }

    void reset() throws IOException {
        packed.reset();
    }

    String getFormat() {
        return format;
    }

    void addByte(byte value) throws IOException {
        packed.write(value);
    }

    void addInt(int value) throws IOException {
        packed.write((value >> 24) & 0xFF);
        packed.write((value >> 16) & 0xFF);
        packed.write((value >> 8) & 0xFF);
        packed.write(value & 0xFF);
    }

    void addLong(long value) throws IOException {
        packed.write((byte) ((value >> 56) & 0xFF));
        packed.write((byte) ((value >> 48) & 0xFF));
        packed.write((byte) ((value >> 40) & 0xFF));
        packed.write((byte) ((value >> 32) & 0xFF));
        packed.write((byte) ((value >> 24) & 0xFF));
        packed.write((byte) ((value >> 16) & 0xFF));
        packed.write((byte) ((value >> 8) & 0xFF));
        packed.write((byte) (value & 0xFF));
    }

    void addByteArray(byte[] value) throws IOException {
        addInt(value.length);
        packed.write(value);
    }

    void addByteArray(byte[] value, int offset, int len) throws IOException {
        addInt(len);
        packed.write(value, offset, len);
    }

    void addString(String value) throws IOException {
        byte[] bytes = value.getBytes(""UTF-8"");
        addInt(bytes.length);
        packed.write(bytes);
    }

}"
130,"import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.*;

import net.sf.marineapi.nmea.parser.HDMSentence;
import net.sf.marineapi.nmea.parser.HDTParser;

public class HDTParserTest {

    private HDTParser parser;
    private String example = ""HDM,240.53,M"";
    private HDMSentence hdm;

    @Before
    public void setUp() {
        parser = new HDTParser();
        hdm = parser.parse(example);
    }

    @After
    public void tearDown() {
        parser = null;
    }

    @Test
    public void testGetHeading() {
        assertEquals(""Test heading"", 240.53, hdm.getHeading(), 0.0001);
    }

    @Test
    public void testSetHeading() {
        double newHeading = 83.5;
        hdm.setHeading(newHeading);
        assertEquals(""Test heading"", newHeading, hdm.getHeading(), 0.0001);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testSetHeadingTooHigh() {
        hdm.setHeading(361);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testSetNegativeHeading() {
        hdm.setHeading(-1);
    }
}"
131,"import com.google.errorprone.annotations.CheckReturnValue;

/**
 * To cover visibility restrictions, an element must not have any of the restricted visibilities.
 *
 * <p>For example:
 *
 * <pre>{@code
 * &#64;RestrictVisibilitiesTo({Visibility.PUBLIC, Visibility.PRIVATE})
 * class Covered {}
 * }</pre>
 *
 * <p>An element covers all visibilities if it does not restrict to *any* of the restricted
 * visibilities.
 *
 * <p>For example:
 *
 * <pre>{@code
 * &#64;RestrictVisibilitiesTo({Visibility.PUBLIC, Visibility.PRIVATE})
 * class NotCovered {}
 * }</pre>
 *
 * <p>In other words, the coverage requirement is satisfied if the `@RestrictVisibilitiesTo` annotation
 * is not present.
 *
 * <p>For more information, see the :javadoc:link:`Restricts accesses by clients` section of the
 * Java language specification.
 */
@CheckReturnValue
public interface RestrictVisibilitiesToCover {

  /**
   * Adds a required annotation to the element.
   *
   * <p>Note that even if the element has an annotation, if it does not have any of the required
   * {@code Visibility} values, then the element is considered to cover all visibilities.
   */
  @CheckReturnValue
  Element restrictVisibilitiesTo(Set<Signature.Visibility> visMask);

  /**
   * Adds a required annotation to the element, disallowing any visibilities.
   *
   * <p>Note that if the element has an annotation, but it does not restrict to any visibilities then
   * the element is considered to cover all visibilities.
   */
  @CheckReturnValue
  default Element coverAllVisibilities() {
    return restrictVisibilitiesTo(EnumSet.allOf(Signature.Visibility.class));
  }

  /**
   * Returns true if the element covers all visibilities.
   *
   * <p>The element is considered to cover all visibilities if it does not restrict to *any* of the
   * restricted visibilities.
   */
  boolean covers(Element element);
}"
132,"import java.util.Scanner;

public class InputHandler {

    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        // Get a character from the user
        char character = getChar(""Enter a character: "");

        // Get a character from the user again, but this time ignore case
        character = getCharIgnoreCase(""Enter a character, ignoring case: "");

        // Get an integer from the user
        int integer = getInt(""Enter an integer: "");

        // Get a double from the user
        double doubleValue = getDouble(""Enter a double: "");

        // Get a boolean from the user
        boolean booleanValue = getBoolean(""Enter a boolean (true or false): "");

        // Get a string from the user
        String string = getString(""Enter a string: "");

        // Print the values entered by the user
        System.out.println(""Character: "" + character);
        System.out.println(""Integer: "" + integer);
        System.out.println(""Double: "" + doubleValue);
        System.out.println(""Boolean: "" + booleanValue);
        System.out.println(""String: "" + string);
    }

    public static char getChar(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine().charAt(0);
    }

    public static char getCharIgnoreCase(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine().toLowerCase().charAt(0);
    }

    public static int getInt(String prompt) {
        System.out.print(prompt);
        return Integer.parseInt(scanner.nextLine());
    }

    public static double getDouble(String prompt) {
        System.out.print(prompt);
        return Double.parseDouble(scanner.nextLine());
    }

    public static boolean getBoolean(String prompt) {
        System.out.print(prompt);
        return Boolean.parseBoolean(scanner.nextLine());
    }

    public static String getString(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine();
    }
}"
133,"import com.google.cloud.storage.Storage;
import com.google.cloud.storage.StorageOptions;
import com.google.cloud.storage.CopyFieldOption;
import com.google.cloud.storage.StorageException;
import com.google.cloud.storage.CopyBlobToBlobOptions;
import com.google.cloud.storage.Blob;

public class CopyBlob {
  public static void copyBlob(
      String projectId,
      String sourceBucketName,
      String sourceObjectName,
      String destinationBucketName,
      String destinationObjectName) {
    // The ID of your GCP project
    // String projectId = ""your-project-id"";

    // The ID of your GCS bucket
    // String sourceBucketName = ""your-source-bucket-name"";

    // The ID of your GCS object
    // String sourceObjectName = ""your-source-object-name"";

    // The ID of your GCS bucket (destination)
    // String destinationBucketName = ""your-destination-bucket-name"";

    // The ID of your GCS object (destination)
    // String destinationObjectName = ""your-destination-object-name"";

    Storage storage = StorageOptions.newBuilder().setProjectId(projectId).build().getService();
    Blob sourceBlob = storage.get(BlobId.of(sourceBucketName, sourceObjectName));
    Blob destinationBlob =
        storage.create(
            destinationBucketName, destinationObjectName, CopyBlobToBlobOptions.newBuilder().build());
    System.out.println(destinationBlob.toString());
  }
}"
134,"import net.sf.marineapi.nmea.parser.VHWParser;
import org.junit.Test;

import static org.junit.Assert.*;

public class VHWParserTest {

    private VHWParser vhw;

    // ------------------------------------------------------------------------
    // Test methods: Constructor (String)
    // ------------------------------------------------------------------------

    @Test
    public void testConstructorString() {
        vhw = new VHWParser(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,K*55"");
        assertEquals(251.80, vhw.getHeading(), 0.01);
        assertEquals(0.02, vhw.getSpeedKnots(), 0.005);
        assertEquals(0.01, vhw.getSpeedKilometres(), 0.005);
        assertEquals(true, vhw.isTrue());
    }

    // ------------------------------------------------------------------------
    // Test methods: Constructor (TalkerId)
    // ------------------------------------------------------------------------

    @Test
    public void testConstructorTalkerId() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.parse(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,K*55"");
        assertEquals(251.80, vhw.getHeading(), 0.01);
        assertEquals(0.02, vhw.getSpeedKnots(), 0.005);
        assertEquals(0.01, vhw.getSpeedKilometres(), 0.005);
        assertEquals(true, vhw.isTrue());
    }

    // ------------------------------------------------------------------------
    // Test methods: setTrue
    // ------------------------------------------------------------------------

    @Test
    public void testIsTrue() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.parse(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,K*55"");
        assertEquals(true, vhw.isTrue());
        vhw.parse(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,D*55"");
        assertEquals(false, vhw.isTrue());
    }

    // ------------------------------------------------------------------------
    // Test methods: setSpeedKnots
    // ------------------------------------------------------------------------

    @Test
    public void testSetSpeedKnots() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.setSpeedKnots(1.0);
        assertEquals(1.0, vhw.getSpeedKnots(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: setSpeedKilometres
    // ------------------------------------------------------------------------

    @Test
    public void testSetSpeedKilometres() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.setSpeedKilometres(2.0);
        assertEquals(2.0, vhw.getSpeedKilometres(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: setMagneticHeading
    // ------------------------------------------------------------------------

    @Test
    public void testSetMagneticHeading() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.setHeading(3.0);
        assertEquals(3.0, vhw.getHeading(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: getHeading
    // ------------------------------------------------------------------------

    @Test
    public void testGetHeading() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.parse(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,K*55"");
        assertEquals(251.80, vhw.getHeading(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: getSpeedKnots
    // ------------------------------------------------------------------------

    @Test
    public void testGetSpeedKnots() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.parse(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,K*55"");
        assertEquals(0.02, vhw.getSpeedKnots(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: getSpeedKilometres
    // ------------------------------------------------------------------------

    @Test
    public void testGetSpeedKilometres() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.parse(""$GPVHW,251.80,T,251.22,M,0.02,N,0.01,K*55"");
        assertEquals(0.01, vhw.getSpeedKilometres(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: getMagneticHeading
    // ------------------------------------------------------------------------

    @Test
    public void testGetMagneticHeading() {
        vhw = new VHWParser(VHWParser.TalkerId.GP);
        vhw.setHeading(123.456);
        assertEquals(123.456, vhw.getHeading(), 0.005);
    }

    // ------------------------------------------------------------------------
    // Test methods: setUp
    // ------------------------------------------------------------------------

    @Test
    public void setUp() {
        // no setUp for this class
    }
}"
135,"import java.util.*;
import java.lang.*;

public class CSP {

    private Hashtable<Variable, Integer> varIndexHash;
    private List<Variable> variables;
    private Hashtable<Variable, List<Constraint>> cnet;
    private List<Domain> domains;
    private List<Constraint> constraints;
    private boolean constraintAdded;

    public CSP() {
        this.varIndexHash = new Hashtable<>();
        this.variables = new ArrayList<>();
        this.cnet = new Hashtable<>();
        this.domains = new ArrayList<>();
        this.constraints = new ArrayList<>();
        this.constraintAdded = false;
    }

    public CSP(CSP csp) {
        this.varIndexHash = copyHashMap(csp.varIndexHash);
        this.variables = new ArrayList<>(csp.variables);
        this.cnet = copyHashMap(csp.cnet);
        this.domains = copyDomains(csp.domains);
        this.constraints = new ArrayList<>(csp.constraints);
        this.constraintAdded = csp.constraintAdded;
    }

    public void addVariable(Variable var) {
        varIndexHash.put(var, variables.size());
        variables.add(var);
        cnet.put(var, new ArrayList<>());
        domains.add(var.getDomain());
    }

    public void removeVariable(Variable var) {
        varIndexHash.remove(var);
        variables.remove(var);
        cnet.remove(var);
        domains.remove(varIndexHash.get(var));
        for (Constraint constraint : var.getConstraints()) {
            constraints.remove(constraint);
            for (Variable variable : constraint.getVariables()) {
                cnet.get(variable).remove(constraint);
            }
        }
    }

    public void addConstraint(Constraint constraint) {
        if (!constraintAdded) {
            constraints.add(constraint);
            for (Variable variable : constraint.getVariables()) {
                cnet.get(variable).add(constraint);
            }
        }
    }

    public void removeConstraint(Constraint constraint) {
        constraints.remove(constraint);
        for (Variable variable : constraint.getVariables()) {
            cnet.get(variable).remove(constraint);
        }
    }

    public boolean isConsistent() {
        for (Constraint constraint : constraints) {
            if (!constraint.isSatisfied()) {
                return false;
            }
        }
        return true;
    }

    public boolean isComplete() {
        for (Domain domain : domains) {
            if (domain.size() == 0) {
                return false;
            }
        }
        return true;
    }

    public boolean isSolved() {
        return isComplete() && isConsistent();
    }

    public List<Variable> getVariables() {
        return variables;
    }

    public List<Constraint> getConstraints() {
        return constraints;
    }

    public Domain getDomain(Variable var) {
        return domains.get(varIndexHash.get(var));
    }

    public void setDomain(Variable var, Domain domain) {
        domains.set(varIndexHash.get(var), domain);
    }

    public void removeValueFromDomain(Variable var, int value) {
        domains.get(varIndexHash.get(var)).removeValue(value);
    }

    public CSP copyDomains() {
        CSP csp = new CSP();
        for (Domain domain : domains) {
            csp.domains.add(domain.copy());
        }
        return csp;
    }

    private static Hashtable<Variable, List<Constraint>> copyHashMap(Hashtable<Variable, List<Constraint>> hashtable) {
        Hashtable<Variable, List<Constraint>> copy = new Hashtable<>();
        for (Map.Entry<Variable, List<Constraint>> entry : hashtable.entrySet()) {
            copy.put(entry.getKey(), new ArrayList<>(entry.getValue()));
        }
        return copy;
    }

    public static class Variable {

        private String name;
        private Domain domain;
        private List<Constraint> constraints;

        public Variable(String name, Domain domain) {
            this.name = name;
            this.domain = domain;
            this.constraints = new ArrayList<>();
        }

        public String getName() {
            return name;
        }

        public Domain getDomain() {
            return domain;
        }

        public void setDomain(Domain domain) {
            this.domain = domain;
        }

        public List<Constraint> getConstraints() {
            return constraints;
        }

        public void addConstraint(Constraint constraint) {
            constraints.add(constraint);
        }

        public void removeConstraint(Constraint constraint) {
            constraints.remove(constraint);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Variable variable = (Variable) o;
            return name.equals(variable.name);
        }

        @Override
        public int hashCode() {
            return Objects.hash(name);
        }
    }

    public static class Domain {

        private List<Integer> values;

        public Domain() {
            this.values = new ArrayList<>();
        }

        public Domain(List<Integer> values) {
            this.values = values;
        }

        public List<Integer> getValues() {
            return values;
        }

        public void setValues(List<Integer> values) {
            this.values = values;
        }

        public void addValue(int value) {
            values.add(value);
        }

        public void removeValue(int value) {
            values.remove(Integer.valueOf(value));
        }

        public boolean contains(int value) {
            return values.contains(value);
        }

        public int size() {
            return values.size();
        }

        public Domain copy() {
            return new Domain(new ArrayList<>(values));
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Domain domain = (Domain) o;
            return values.equals(domain.values);
        }

        @Override
        public int hashCode() {
            return Objects.hash(values);
        }
    }

    public static abstract class Constraint {

        private List<Variable> variables;

        public Constraint(List<Variable> variables) {
            this.variables = variables;
        }

        public List<Variable> getVariables() {
            return variables;
        }

        public abstract boolean isSatisfied();
    }

    public static class BinaryConstraint extends Constraint {

        private Variable var1;
        private Variable var2;

        public BinaryConstraint(Variable var1, Variable var2) {
            super(List.of(var1, var2));
            this.var1 = var1;
            this.var2 = var2;
        }

        public Variable getOtherVariable(Variable var) {
            if (var.equals(var1)) {
                return var2;
            } else if (var.equals(var2)) {
                return var1;
            } else {
                throw new IllegalArgumentException(""Variable is not part of this constraint"");
            }
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            BinaryConstraint that = (BinaryConstraint) o;
            return (var1.equals(that.var1) && var2.equals(that.var2)) || (var1.equals(that"
136,"import java.util.Date;

public class SensorData {

    private int volume;
    private double occupancy;
    private Date measurement_date;
    private int lane_id;
    private long id;
    private double speed;
    private int quality;

    public SensorData() {
    }

    public SensorData(int volume, double occupancy, Date measurement_date, int lane_id, long id, double speed, int quality) {
        this.volume = volume;
        this.occupancy = occupancy;
        this.measurement_date = measurement_date;
        this.lane_id = lane_id;
        this.id = id;
        this.speed = speed;
        this.quality = quality;
    }

    public int getVolume() {
        return volume;
    }

    public void setVolume(int volume) {
        this.volume = volume;
    }

    public double getOccupancy() {
        return occupancy;
    }

    public void setOccupancy(double occupancy) {
        this.occupancy = occupancy;
    }

    public Date getMeasurement_date() {
        return measurement_date;
    }

    public void setMeasurement_date(Date measurement_date) {
        this.measurement_date = measurement_date;
    }

    public int getLane_id() {
        return lane_id;
    }

    public void setLane_id(int lane_id) {
        this.lane_id = lane_id;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public int getQuality() {
        return quality;
    }

    public void setQuality(int quality) {
        this.quality = quality;
    }

    @Override
    public String toString() {
        return ""SensorData{"" +
                ""volume="" + volume +
                "", occupancy="" + occupancy +
                "", measurement_date="" + measurement_date +
                "", lane_id="" + lane_id +
                "", id="" + id +
                "", speed="" + speed +
                "", quality="" + quality +
                '}';
    }
}"
137,"public static void main(String[] args) {
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.toString()); // java.util.List
        System.out.println(ScopeKindEnum.SK_INSTANCE.toString()); // java.lang.String
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.literalName()); // typeName
        System.out.println(ScopeKindEnum.SK_INSTANCE.literalName()); // literalName
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.readResolve()); // ScopeKind
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.forName()); // java.util.List
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.refTypeName()); // typeName
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.hashCode()); // int
        System.out.println(ScopeKindEnum.SK_CLASSIFIER.equals(ScopeKindEnum.SK_INSTANCE)); // boolean
    }"
138,"import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;

import org.xhtmlrenderer.pdf.ITextRenderer;
import org.xhtmlrenderer.swing.XHTMLPanel;

public class XhtmlRenderer {

    private ITextRenderer renderer;
    private XHTMLPanel panel;

    public void setDocument(String html) {
        renderer.setDocumentFromString(html);
    }

    public void layout() {
        renderer.layout();
    }

    public BufferedImage renderToImageAutoSize() {
        return renderer.getImage();
    }

    public void setSharedContext(SharedContext sharedContext) {
        renderer.getSharedContext().setTextRendererFactory(sharedContext);
    }

    public Rectangle getMinimumSize() {
        return panel.getMinimumSize();
    }

    public XHTMLPanel getPanel() {
        return panel;
    }

    public SharedContext getSharedContext() {
        return renderer.getSharedContext();
    }

    public void render(Dimension dim) {
        renderer.render(dim.width, dim.height);
    }

    public BufferedImage renderToImage(Dimension dim) {
        renderer.render(dim.width, dim.height);
        return renderer.getImage();
    }

    private XhtmlRenderer(XHTMLPanel panel, ITextRenderer renderer) {
        this.panel = panel;
        this.renderer = renderer;
    }

    public static XhtmlRenderer create(String html) {
        XHTMLPanel panel = new XHTMLPanel();
        ITextRenderer renderer = new ITextRenderer();
        XhtmlRenderer xhtmlRenderer = new XhtmlRenderer(panel, renderer);
        xhtmlRenderer.setDocument(html);
        return xhtmlRenderer;
    }
}"
139,
140,"package bank;
import java.util.*;
import java.text.*;
import java.io.*;

public class Bank {
    private List<Customer> customers;

    public Bank() {
        customers = new ArrayList<Customer>();
    }

    public void addCustomer(Customer customer) {
        customers.add(customer);
    }

    public String accountNumberSummary() {
        double totalInterestPaid = 0;
        StringBuilder sb = new StringBuilder();
        DecimalFormat df = new DecimalFormat(""#,###.##"");
        for (Customer customer : customers) {
            for (Account account : customer.getAccounts()) {
                sb.append(String.format(""%s: %s: %s\n"",
                        customer.getName(),
                        account.getAccountNumber(),
                        df.format(account.getInterestPaid())));
                totalInterestPaid += account.getInterestPaid();
            }
        }
        sb.append(String.format(""Total interest paid: %s\n"", df.format(totalInterestPaid)));
        return sb.toString();
    }

    public static void main(String[] args) {
        Bank bank = new Bank();
        bank.addCustomer(new Customer(""John Doe""));
        bank.addCustomer(new Customer(""Jane Doe""));
        bank.addCustomer(new Customer(""John Smith""));
        bank.addCustomer(new Customer(""Jane Smith""));

        bank.getCustomers().get(0).getAccounts().add(new Account(1000.0, 0.01));
        bank.getCustomers().get(0).getAccounts().add(new Account(2000.0, 0.02));
        bank.getCustomers().get(1).getAccounts().add(new Account(3000.0, 0.03));
        bank.getCustomers().get(1).getAccounts().add(new Account(4000.0, 0.04));
        bank.getCustomers().get(2).getAccounts().add(new Account(5000.0, 0.05));
        bank.getCustomers().get(2).getAccounts().add(new Account(6000.0, 0.06));
        bank.getCustomers().get(3).getAccounts().add(new Account(7000.0, 0.07));
        bank.getCustomers().get(3).getAccounts().add(new Account(8000.0, 0.08));

        System.out.println(bank.accountNumberSummary());
    }
}

class Customer {
    private String name;
    private List<Account> accounts;

    public Customer(String name) {
        this.name = name;
        accounts = new ArrayList<Account>();
    }

    public String getName() {
        return name;
    }

    public List<Account> getAccounts() {
        return accounts;
    }
}

class Account {
    private double balance;
    private double interestRate;
    private double interestPaid;

    public Account(double balance, double interestRate) {
        this.balance = balance;
        this.interestRate = interestRate;
        calculateInterestPaid();
    }

    public double getBalance() {
        return balance;
    }

    public double getInterestRate() {
        return interestRate;
    }

    public double getInterestPaid() {
        return interestPaid;
    }

    private void calculateInterestPaid() {
        interestPaid = balance * interestRate;
    }
}"
141,"import com.google.common.base.Preconditions;
import java.util.Collection;

/**
 * A stream-friendly version of {@link Stats}. Does not support removing elements.
 *
 * <p>A Statistics object can be queried for various statistical properties of the data elements it has
 * seen. Currently, the following properties can be queried: minimum, maximum, mean, sum, variance, and
 * sample standard deviation.
 *
 * <p>Note that operations on a {@code Stats} object should not be interleaved with operations on a
 * different {@code Stats} object.
 */
public class Stats {

  /** A builder for {@link Stats} objects. */
  public static class Builder {
    private final Stats stats = new Stats();

    /**
     * Adds the given value to this instance.
     *
     * @param value the value to add
     * @return this {@link Builder}
     * @throws IllegalStateException if this {@link Builder} is finished
     */
    public Builder add(double value) {
      Preconditions.checkState(!stats.isFinished, ""Builder is finished"");
      stats.add(value);
      return this;
    }

    /**
     * Adds all of the values from the specified {@link Iterable} to this instance.
     *
     * @param values the values to add
     * @return this {@link Builder}
     * @throws IllegalStateException if this {@link Builder} is finished
     */
    public Builder addAll(Iterable<Double> values) {
      Preconditions.checkState(!stats.isFinished, ""Builder is finished"");
      for (double value : values) {
        stats.add(value);
      }
      return this;
    }

    /**
     * Adds all of the values from the specified {@link Collection} to this instance.
     *
     * @param values the values to add
     * @return this {@link Builder}
     * @throws IllegalStateException if this {@link Builder} is finished
     */
    public Builder addAll(Collection<Double> values) {
      return addAll(values.iterator());
    }

    /**
     * Calls {@link #addAll(Iterable)} with the specified values.
     *
     * @param values the values to add
     * @return this {@link Builder}
     * @throws IllegalStateException if this {@link Builder} is finished
     */
    public Builder addAll(double... values) {
      for (double value : values) {
        add(value);
      }
      return this;
    }

    /**
     * Builds the {@link Stats} object (to make it immutable). Interleaving operations on the returned
     * object with operations on this {@link Builder} is not supported.
     *
     * @throws IllegalStateException if this {@link Builder} is finished
     */
    public Stats build() {
      Preconditions.checkState(!stats.isFinished, ""Builder is finished"");
      stats.isFinished = true;
      return stats;
    }
  }

  // Note: these fields are public to allow direct access for computation and to reduce allocations.

  /**
   * Indicates if the number of elements counted has been corrupted. This is necessary to support
   * NaN/Infinity values.
   */
  protected boolean corruptionDetected;

  /** True if this instance has been finished. */
  protected boolean isFinished;

  /** Number of elements added to this instance. This is not guaranteed to be the number of elements
   * which had their properties queried. */
  protected double count = 0;

  /** Sum of all elements added to this instance. */
  protected double sum = 0;

  /** Sum of the squares of the difference between each element and the mean. */
  protected double sumOfSquaresOfDeltas = 0;

  /** Lowest value added to this instance. */
  protected double min = Double.POSITIVE_INFINITY;

  /** Highest value added to this instance. */
  protected double max = Double.NEGATIVE_INFINITY;

  /** The most recent mean. */
  protected double mean = 0;

  /** Builds a new instance of {@link Stats}. To avoid unnecessary allocations, build a {@link Builder}
   * instead. */
  private Stats() {}

  /**
   * Creates a new {@link Builder} for a {@link Stats} object.
   *
   * @return a new {@link Builder}
   */
  public static Builder build() {
    return new Builder();
  }

  /**
   * Adds the given value to this instance.
   *
   * @param value the value to add
   * @throws IllegalStateException if this {@link Stats} is finished
   */
  public void add(double value) {
    Preconditions.checkState(!isFinished, ""Stats is finished"");
    if (!corruptionDetected) {
      // Double.NEGATIVE_INFINITY and Double.POSITIVE_INFINITY are valid values.
      if (count == 0 && Double.isNaN(value)) {
        corruptionDetected = true;
        return;
      }
      if (count == 0 || value < min) {
        min = value;
      }
      if (value > max) {
        max = value;
      }
      if (!Double.isNaN(value)) {
        delta(value);
      }
      ++count;
    }
  }

  /**
   * Adds all of the values from the specified {@link Iterable} to this instance.
   *
   * @param values the values to add
   * @throws IllegalStateException if this {@link Stats} is finished
   */
  public void addAll(Iterable<Double> values) {
    for (double value : values) {
      add(value);
    }
  }

  /**
   * Adds all of the values from the specified {@link Collection} to this instance.
   *
   * @param values the values to add
   * @throws IllegalStateException if this {@link Stats} is finished
   */
  public void addAll(Collection<Double> values) {
    addAll(values.iterator());
  }

  /**
   * Calls {@link #addAll(Iterable)} with the specified values.
   *
   * @param values the values to add
   * @throws IllegalStateException if this {@link Stats} is finished
   */
  public void addAll(double... values) {
    for (double value : values) {
      add(value);
    }
  }

  /**
   * Calculates the delta between the new mean and the current value.
   *
   * @param value the new value
   */
  protected void delta(double value) {
    final double prevMean = mean;
    mean = calculateNewMeanNonFinite((mean * count) + value, count + 1);
    sumOfSquaresOfDeltas += ((value - prevMean) * (value - mean));
  }

  /**
   * Calculates the new mean.
   *
   * @param newSum the new sum
   * @param newCount the new count
   * @return the new mean
   */
  protected double calculateNewMeanNonFinite(double newSum, double newCount) {
    return newSum / newCount;
  }

  /**
   * Returns the minimum value from this instance. The count must be non-zero. Non-finite values
   * (NaN/Infinity) are handled as follows: if the dataset contains Double.#NaN then the result is
   * Double.#NaN. If it contains only Double.#NEGATIVE_INFINITY and not Double.#NaN then the result is
   * Double.#NEGATIVE_INFINITY. If it contains only Double.#POSITIVE_INFINITY and finite values then
   * the result is the lowest finite value. If it contains only Double.#POSITIVE_INFINITY then the result
   * is Double.#POSITIVE_INFINITY.
   *
   * @return the minimum value from this instance
   * @throws IllegalStateException if this {@link Stats} is not finished or has no elements
   */
  public double min() {
    Preconditions.checkState(isFinished, ""Stats is not finished"");
    Preconditions.checkState(count > 0, ""Stats has no elements"");
    return min;
  }

  /**
   * Returns the maximum value from this instance. The count must be non-zero. Non-finite values
   * (NaN/Infinity) are handled as follows: if the dataset contains Double.#NaN then the result is
   * Double.#NaN. If it contains only Double.#NEGATIVE_INFINITY and not Double.#NaN then the result is
   * Double.#NEGATIVE_INFINITY. If it contains only Double.#POSITIVE_INFINITY and finite values then
   * the result is the highest finite value. If it contains only Double.#POSITIVE_INFINITY then the result
   * is Double.#POSITIVE_INFINITY.
   *
   * @return the maximum value from this instance
   * @throws IllegalStateException if this {@link Stats} is not finished or has no elements
   */
  public double max() {
    Preconditions.checkState(isFinished, ""Stats is not finished"");
    Preconditions.checkState("
142,"import static org.junit.Assert.*;

import javax.swing.JPanel;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class DeviceTest {
	private static Device dev;

	@BeforeClass
	public static void setUpClass() {
	    dev = new Device(""HD Pro Video Recorder"", ""com.example.device"", ""00:08:f6:f0:28:40"", ""camera"");
	}
	
	@Before
	public void setUp() {
		dev = new Device(""HD Pro Video Recorder"", ""com.example.device"", ""00:08:f6:f0:28:40"", ""camera"");
	}

	@Test
	public void testGetType() {
		assertEquals(""camera"", dev.getType());
	}

	@Test
	public void testGetDeviceName_0args() {
		assertEquals(""HD Pro Video Recorder"", dev.getDeviceName());
	}

	@Test
	public void testAddToPane() {
		JPanel p = new JPanel();
		dev.addToPane(p);
		assertTrue(p.getComponentCount() > 0);
	}

	@Test
	public void testGetAddress() {
		assertEquals(""00:08:f6:f0:28:40"", dev.getAddress());
	}

	@Test
	public void tearDownClass() {
		// NA
	}

	@Test
	public void tearDown() {
		// NA
	}

	@Test
	public void testGetDeviceNames() {
		dev.addDeviceName(""de"", ""HD Pro Video Recorder Deutsch"");
		assertEquals(""HD Pro Video Recorder Deutsch"", dev.getDeviceName(""de""));
	}

	@Test
	public void testAddCapabilities() {
		// NA
	}

	@Test
	public void testToString() {
		assertEquals(""dev{name=\""HD Pro Video Recorder\"", addr=\""00:08:f6:f0:28:40\"", type=\""camera\""}"", dev.toString());
	}

	@Test
	public void testGetImgName() {
		// NA
	}

	@Test
	public void testAddCapability() {
		dev.addCapability(""camera"", ""video"");
		assertTrue(dev.hasCapability(""camera"", ""video""));
	}

	@Test
	public void testGetDeviceName_Locale() {
		dev.addDeviceName(""de"", ""HD Pro Video Recorder Deutsch"");
		assertEquals(""HD Pro Video Recorder Deutsch"", dev.getDeviceName(""de""));
	}

	@Test
	public void testGetImage() {
		// NA
	}

	@Test
	public void testGetDeviceID() {
		assertEquals(""com.example.device"", dev.getDeviceID());
	}

	@Test
	public void testGetCapabilityBlock() {
		// NA
	}

	@Test
	public void testGetCapabilities() {
		dev.addCapability(""camera"", ""video"");
		assertEquals(1, dev.getCapabilities(""camera"").size());
	}

	@Test
	public void testRemoveCapability() {
		dev.addCapability(""camera"", ""video"");
		dev.removeCapability(""camera"", ""video"");
		assertFalse(dev.hasCapability(""camera"", ""video""));
	}
}"
143,"package com.parrot.arsdk.arcontroller;

import android.util.Log;

import java.util.concurrent.TimeUnit;

public class ARDroneFeatureGeneralMotorControl extends ARControllerFeatureBase {
    private static final String TAG = ""ARDroneFeatureGeneralMotorControl"";
    private static final long threadTimer = TimeUnit.MILLISECONDS.toNanos(100);
    private static final GENERALMOTORCON_CMD downloadPresetList;
    private static final GENERALMOTORCON_CMD manualControl;
    private static final GENERALMOTORCON_CMD takeOff;
    private static final GENERALMOTORCON_CMD landing;
    private static final GENERALMOTORCON_CMD emergency;
    private static final GENERALMOTORCON_CMD resetAllMotors;
    private static final GENERALMOTORCON_CMD toggleCircleMovement = new GENERALMOTORCON_CMD(8);
    private static final GENERALMOTORCON_CMD hover;
    private static final GENERALMOTORCON_CMD forward;
    private static final GENERALMOTORCON_CMD spinLeft;
    private static final GENERALMOTORCON_CMD spinRight;
    private static final GENERALMOTORCON_CMD backward;
    private static final GENERALMOTORCON_CMD left;
    private static final GENERALMOTORCON_CMD right;
    private static final GENERALMOTORCON_CMD flip;
    private static final GENERALMOTORCON_CMD spin90Left;
    private static final GENERALMOTORCON_CMD spin90Right;
    private static final GENERALMOTORCON_CMD playPreset;
    private static final GENERALMOTORCON_CMD stopPreset;
    private static final GENERALMOTORCON_CMD changePreset;

    public static GENERALMOTORCON_CMD getDownloadPresetList() {
        return downloadPresetList;
    }

    public static GENERALMOTORCON_CMD getManualControl() {
        return manualControl;
    }

    public static GENERALMOTORCON_CMD getTakeOff() {
        return takeOff;
    }

    public static GENERALMOTORCON_CMD getLanding() {
        return landing;
    }

    public static GENERALMOTORCON_CMD getEmergency() {
        return emergency;
    }

    public static GENERALMOTORCON_CMD getResetAllMotors() {
        return resetAllMotors;
    }

    public static GENERALMOTORCON_CMD getToggleCircleMovement() {
        return toggleCircleMovement;
    }

    public static GENERALMOTORCON_CMD getHover() {
        return hover;
    }

    public static GENERALMOTORCON_CMD getForward() {
        return forward;
    }

    public static GENERALMOTORCON_CMD getSpinLeft() {
        return spinLeft;
    }

    public static GENERALMOTORCON_CMD getSpinRight() {
        return spinRight;
    }

    public static GENERALMOTORCON_CMD getBackward() {
        return backward;
    }

    public static GENERALMOTORCON_CMD getLeft() {
        return left;
    }

    public static GENERALMOTORCON_CMD getRight() {
        return right;
    }

    public static GENERALMOTORCON_CMD getFlip() {
        return flip;
    }

    public static GENERALMOTORCON_CMD getSpin90Left() {
        return spin90Left;
    }

    public static GENERALMOTORCON_CMD getSpin90Right() {
        return spin90Right;
    }

    public static GENERALMOTORCON_CMD getPlayPreset() {
        return playPreset;
    }

    public static GENERALMOTORCON_CMD getStopPreset() {
        return stopPreset;
    }

    public static GENERALMOTORCON_CMD getChangePreset() {
        return changePreset;
    }

    public interface Listener {
        /**
         * Motor commands status callback
         *
         * @param speed      Command speed (% of full speed 0-100)
         * @param spinSpeed  Rotation speed (% of full speed 0-100)
         * @param hoverTime  Hover duration (in ms)
         * @param spinTime   Rotation duration (in ms)
         * @param spin90Time Rotation duration (in ms)
         * @param spin90Speed Rotation speed (% of full speed 0-100)
         * @param spin90Dir  Rotation direction (1 for Left, 2 for Right)
         * @param batLvl     Battery level (0-100)
         */
        void onCommandReceived(int speed, int spinSpeed, int hoverTime, int spinTime, int spin90Time, int spin90Speed, int spin90Dir, int batLvl);
    }

    private Listener listener;

    public ARDroneFeatureGeneralMotorControl(ARDrone drone) {
        super(drone);
    }

    /**
     * Set a listener to be called when a command is received from the drone for General Motor Control.
     *
     * @param listener a {@link Listener} object
     */
    public void setListener(Listener listener) {
        this.listener = listener;
    }

    private static void sendCommand(ARDroneFeatureGeneralMotorControl feature, GENERALMOTORCON_CMD cmd, int delay) throws IllegalArgumentException {
        if (feature.isFeatureOpened()) {
            try {
                Thread.sleep(delay);
            } catch (InterruptedException e) {
                Log.e(TAG, ""Thread sleep failed during command execution.; Sending command: "" + cmd.getName());
                return;
            }
            long startTime = System.nanoTime();
            boolean received = false;
            do {
                received = ARCONTROLLER_ERROR_OK == feature.sendCommand(cmd);
                if (received) {
                    feature.waitForAck();
                    break;
                } else {
                    Log.w(TAG, ""Failed to send command: "" + cmd.getName());
                }
            } while (System.nanoTime() - startTime < threadTimer);

            if (!received) {
                Log.e(TAG, ""Unable to send command: "" + cmd.getName());
                return;
            }
            if (cmd == downloadPresetList) {
                feature.drone.getARDroneFeatures().listAll();
            }
        }
    }

    private static void sendCommandWithDelay(ARDroneFeatureGeneralMotorControl feature, GENERALMOTORCON_CMD cmd) throws IllegalArgumentException {
        sendCommand(feature, cmd, 0);
    }

    /**
     * Download preset list (with auto-discovery)
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void downloadPresetList() throws IllegalArgumentException {
        if (listener != null)
            listener.onCommandReceived(0, 0, 0, 0, 0, 0, 0, getBatLvl());
        sendCommandWithDelay(this, downloadPresetList);
    }

    /**
     * Set alert or unlock the manual control motors
     *
     * @param alert true to alert, false to unlock
     * @throws IllegalArgumentException if state is not READY
     */
    public void manualControl(boolean alert) throws IllegalArgumentException {
        int flag = alert ? 1 : 0;
        sendCommandWithDelay(this, new GENERALMOTORCON_CMD(manualControl, flag));
    }

    /**
     * Take off if not already taken off
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void takeoff() throws IllegalArgumentException {
        sendCommandWithDelay(this, takeOff);
    }

    /**
     * Land if not already landed
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void landing() throws IllegalArgumentException {
        sendCommandWithDelay(this, landing);
    }

    /**
     * Emergency stop
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void emergency() throws IllegalArgumentException {
        sendCommandWithDelay(this, emergency);
    }

    /**
     * Reset all motors
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void resetAllMotors() throws IllegalArgumentException {
        sendCommandWithDelay(this, resetAllMotors);
    }

    /**
     * Toggle circle movement
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void toggleCircleMovement() throws IllegalArgumentException {
        sendCommandWithDelay(this, toggleCircleMovement);
    }

    /**
     * Do nothing
     *
     * @throws IllegalArgumentException if state is not READY
     */
    public void hover() throws IllegalArgumentException {
        if (listener != null)
            listener.onCommandReceived(0, 0, 0, 0, 0, 0, 0, getBatLvl());
        sendCommandWithDelay(this, hover);
    }

    /**
     * Move forward
     *
     * @param speed    Command speed (% of full speed 0-100)
     * @param hoverTime Hover duration (in ms)
     * @throws IllegalArgumentException if speed is < 0 or > 100, or state is not"
144,
145,"import com.google.bitcoin.core.NetworkParameters;
import com.google.bitcoin.core.Sha256Hash;
import com.google.bitcoin.core.block.Block;

public interface NetworkParameters {

    int addressHeader;
    int INTERVAL;
    byte[] alertSigningKey;
    int[] acceptableAddressCodes;
    long packetMagic;
    int p2shHeader;
    java.util.List<NetworkParameters> paramSet;
    int PROTOCOL_VERSION;
    Block genesisBlock;
    BigInteger proofOfWorkLimit;
    int subsidyDecreaseBlockCount;
    int port;
    BigInteger MAX_MONEY;
    int TARGET_SPACING;
    String[] dnsSeeds;
    java.util.Map<Integer, Sha256Hash> checkpoints;
    byte[] SATOSHI_KEY;
    int interval;
    String id;
    int spendableCoinbaseDepth;
    int dumpedPrivateKeyHeader;
    int targetTimespan;
    int TARGET_TIMESPAN;
    int BIP16_ENFORCE_TIME;
    NetworkParameters regTests;
    boolean allowEmptyPeerChain;
    int getDumpedPrivateKeyHeader();
    NetworkParameters testNet2;
    NetworkParameters testNet3;
    NetworkParameters unitTests;
    String getId();
    int getAddressHeader();
    int[] getAcceptableAddressCodes();
    NetworkParameters prodNet;
    NetworkParameters fromID(String id);
    int getTargetTimespan();
    String[] getDnsSeeds();
    int hashCode();
    int getSpendableCoinbaseDepth();
    NetworkParameters testNet;
    Sha256Hash calculateBlockPoWHash(Block block);
    BigInteger getMaxMoney();
    NetworkParameters getParamsFromAddressByte(byte b);
    void registerParams(NetworkParameters params);
    boolean isCheckpoint(Sha256Hash hash);
    int getP2SHHeader();
    int getInterval();
    int getRetargetBlockCount();
    int getRetargetBlockCount();
    Block getGenesisBlock();
    int getSubsidyDecreaseBlockCount();
    Block createGenesis();
    long getPacketMagic();
    int getPort();
    boolean equals(Object o);
    boolean passesCheckpoint(Sha256Hash hash);
    boolean isAcceptableAddressVersion(int version);
    String getURIScheme();
    BigInteger getProofOfWorkLimit();
}"
146,"@Override
public String getType(Uri uri) {
    SQLiteUriMatcher instance = getInstance();
    synchronized (instance) {
        String type = instance.getMimeType(uri);
        if (type != null) {
            return type;
        }
    }
    SQLiteUriMatcher instance2 = getInstance();
    int uriList = instance2.uriList();
    for (int entryCount = instance2.getEntries().size() - 1; entryCount >= 0; entryCount--) {
        Entry entry = instance2.getEntries().get(entryCount);
        if (entry.isMatcher()) {
            instance2.addMatcherEntry((E) entry);
        } else {
            instance2.addSQLBuilderCallback((E) entry);
        }
    }
    for (int entryCount2 = instance2.getEntries().size() - 1; entryCount2 >= 0; entryCount2--) {
        Entry entry2 = instance2.getEntries().get(entryCount2);
        instance2.addRawSQL(entry2.getSQL());
    }
    SQLiteUriMatcher instance3 = getInstance();
    synchronized (instance3) {
        return instance3.getMimeType(uri);
    }
}"
147,"import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class ByteOrder {

  public static void writeShortLE(short x, OutputStream out) throws IOException {
    out.write((byte) (x & 0xFF));
    out.write((x >> 8) & 0xFF);
  }

  public static short readShortLE(InputStream in) throws IOException {
    int b1 = in.read();
    int b2 = in.read();
    return (short) (b1 | (b2 << 8));
  }

  public static void writeIntLE(int x, OutputStream out) throws IOException {
    out.write((byte) (x & 0xFF));
    out.write((x >> 8) & 0xFF);
    out.write((x >> 16) & 0xFF);
    out.write((x >> 24) & 0xFF);
  }

  public static int readIntLE(InputStream in) throws IOException {
    int b1 = in.read();
    int b2 = in.read();
    int b3 = in.read();
    int b4 = in.read();
    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);
  }

  public static void writeLongLE(long x, OutputStream out) throws IOException {
    out.write((byte) (x & 0xFF));
    out.write((x >> 8) & 0xFF);
    out.write((x >> 16) & 0xFF);
    out.write((x >> 24) & 0xFF);
    out.write((x >> 32) & 0xFF);
    out.write((x >> 40) & 0xFF);
    out.write((x >> 48) & 0xFF);
    out.write((x >> 56) & 0xFF);
  }

  public static long readLongLE(InputStream in) throws IOException {
    int b1 = in.read();
    int b2 = in.read();
    int b3 = in.read();
    int b4 = in.read();
    int b5 = in.read();
    int b6 = in.read();
    int b7 = in.read();
    int b8 = in.read();
    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24) | (b5 << 32) | (b6 << 40) | (b7 << 48) |
        (b8 << 56);
  }
}"
148,"public class Householder {

    private double[] v;
    private double beta;

    public Householder(double[] v) {
        this.v = copy(v);
        this.beta = 2.0 / innerProd(v, v);
    }

    public double mult(double[] x, double[] y) {
        double innerProdA = innerProd(x, v);
        double innerProdTranA = innerProd(y, v);
        addOuterProd(y, v, beta * innerProdA);
        addOuterProd(x, v, beta * innerProdTranA);

        return 0;
    }

    public double rank1Update(double[] x, double[] y) {
        double innerProdA = innerProd(x, v);
        addOuterProd(y, v, beta * innerProdA);
        return 0;
    }

    public double rank1Update(double[] x) {
        return rank1Update(x, v);
    }

    public double innerProd(double[] x, double[] y) {
        double innerProd = 0.0;
        for (int i = 0; i < x.length; i++) {
            innerProd += x[i] * y[i];
        }

        return innerProd;
    }

    public void outerProd(double[] x, double[] y, double[] z) {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < y.length; j++) {
                z[i * y.length + j] = x[i] * y[j];
            }
        }
    }

    public void addOuterProd(double[] x, double[] y, double alpha) {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < y.length; j++) {
                x[i * y.length + j] += alpha * y[i] * y[j];
            }
        }
    }

    private double[] copy(double[] v) {
        double[] copy = new double[v.length];
        for (int i = 0; i < v.length; i++) {
            copy[i] = v[i];
        }

        return copy;
    }
}"
149,"try (TarOutputStream tos = new TarOutputStream(os, TarEntry.LENGTH_SIZE)) {
          TarHelper.tar(
              tos, path, basepath, null, lastSubmittedRevision, compressed, tar, LOGGER);
          return true;
        } catch (IOException ex) {
          LOGGER.severe(""Error occured during tar creation."", ex);
          return false;
        }"
150,"// Imports the Google Cloud client library

    // Instantiates a client
    try (CloudSpanner spanner = SpannerOptions.getDefaultInstance().getService()) {
      // Creates a new instance of SQL query using builder pattern
      Statement.Builder statement =
          Statement.newBuilder(
              String.format(""SELECT SingerId, FirstName, LastName FROM SINGERS WHERE FIQL =""
                  + "" '%s'"", FIQL));
      Statement query = statement.setLanguage(DEFAULT_LANGUAGE).build();
      // Using try with resources ensures that the resultSet is closed later on
      try (ResultSet resultSet = spanner.singleUse().executeQuery(query)) {
        while (resultSet.next()) {
          System.out.printf(
              ""%d %s %s\n"", resultSet.getLong(0), resultSet.getString(1), resultSet.getString(2));
        }
      }
    }"
151,"void addAll(Set<T> set, Class<?> clazz) {
      set.add(this.value);
      if (clazz == null || clazz.isInstance(this.value)) {
        set.addAll(getNodes());
      }
      for (PlaceHolder childPlaceHolder : this.children) {
        childPlaceHolder.addAll(set, clazz);
      }
    }"
152,"import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PointF;
import android.graphics.RectF;
import android.util.AttributeSet;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.View;

import com.microsoft.handwriter.ihk.HwInfoKeys;
import com.microsoft.handwriter.ihk.HwInteractionHandler;
import com.microsoft.handwriter.ihk.HwInteractionListener;
import com.microsoft.handwriter.ihk.HwInteractionParameters;
import com.microsoft.handwriter.ihk.HwPenCommand;
import com.microsoft.handwriter.hwdoodling.R;
import com.microsoft.handwriter.hwdoodling.Page;
import com.microsoft.handwriter.hwdoodling.Strokes;
import com.microsoft.handwriter.hwdoodling.Transformation;

import java.util.ArrayList;
import java.util.List;

public class HandwriterView extends View implements HwInteractionListener {

    private Paint mPaint;
    private Strokes mStrokes;
    private HwInteractionHandler mHwInteractionHandler;
    private ScaleGestureDetector mScaleGestureDetector;
    private GestureDetector mGestureDetector;
    private Transformation mTransformation;
    private RectF mRectF;
    private Rect mRect;
    private boolean mOnlyPenInput;
    private boolean mDrawPinchZoomPreview;
    private boolean mDoubleClickPossible;
    private boolean mDoubleClickWhileWritingDisabled;
    private float mScaledPenThickness;
    private boolean mUseForWriting;
    private int mMoveGestureMinDistance;
    private float mPinchZoomScaleFactor;
    private HwPenCommand mHwPenCommand;
    private float mLastX = 0;
    private float mLastY = 0;
    private float mDownX = 0;
    private float mDownY = 0;
    private long mDownTime = 0;
    private boolean mStartFromOutside;
    private boolean mDoubleClickStarted;
    private boolean mPinchZoomed;
    private Page mPage;

    private HwInteractionParameters mHwParameters;

    public HandwriterView(Context context, AttributeSet attrs) {
        super(context, attrs);
        initHwInteraction();
        initScales();
        initPaints();
        initGestureDetector();
    }

    @Override
    public void onDraw(Canvas canvas) {
        mRectF = new RectF(0, 0, getWidth(), getHeight());
        mRect = new Rect(0, 0, getWidth(), getHeight());
        canvas.drawColor(Color.WHITE);
        canvas.drawRect(mRectF, mPaint);
        mPage.onDraw(canvas, mTransformation);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        setMeasuredDimension(
                MeasureSpec.getSize(widthMeasureSpec),
                MeasureSpec.getSize(heightMeasureSpec));
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        super.onTouchEvent(event);

        float x = event.getX();
        float y = event.getY();

        // Handle pinch to zoom
        mScaleGestureDetector.onTouchEvent(event);

        // Handle double tap to reset
        mGestureDetector.onTouchEvent(event);

        if (mPinchZoomScaleFactor != 1) {
            if (mDrawPinchZoomPreview) {
                drawPinchZoomPreview();
            }
            return true;
        }

        if (!mUseForWriting) {
            return true;
        }

        if (!mOnlyPenInput) {
            mHwInteractionHandler.processTouchEvent(event);
        } else {
            long timeDiff = event.getEventTime() - mDownTime;
            handleFingerTouch(event, timeDiff, x, y);
            mDownX = x;
            mDownY = y;
            mLastX = x;
            mLastY = y;
        }
        return true;
    }

    @Override
    public void onClick(HwPenCommand command) {
    }

    @Override
    public void onStrokeStart(HwPenCommand command, float touchX, float touchY) {
    }

    @Override
    public void onStrokeUpdate(HwPenCommand command, float touchX, float touchY, float touchWidth) {
        float x = command.getTouchX() * mTransformation.mScaleFactor;
        float y = command.getTouchY() * mTransformation.mScaleFactor;
        if (mHwPenCommand != null && mHwPenCommand.getPenId() == command.getPenId()) {
            mStrokes.drawLine(x, y, touchWidth * mScaledPenThickness);
        }
        redraw();
    }

    @Override
    public void onStrokeEnd(HwPenCommand command, float touchX, float touchY, float touchWidth) {
        mStrokes.finalizeWithErrorCheck();
        redraw();
    }

    @Override
    public void onPump(HwPenCommand command, float tiltX, float tiltY, float twist) {
    }

    @Override
    public void onAutoCorrect(HwPenCommand command) {
        mStrokes.refresh();
        redraw();
    }

    @Override
    public void onChangePage(HwPenCommand command, byte pageNo) {
        mPage.clearStrokes();
        redraw();
    }

    @Override
    public void onZoom(HwPenCommand command, float zoomFactor) {
    }

    @Override
    public void onDestroy() {
        mHwInteractionHandler.destroy();
    }

    private void initHwInteraction() {
        mHwParameters = new HwInteractionParameters();
        mHwParameters.setContext(getContext());
        mHwParameters.setPageManager(new PageManager(getContext()));
        mHwParameters.setListener(this);
        mHwInteractionHandler = new HwInteractionHandler(mHwParameters);
    }

    private void initScales() {
        mScaleGestureDetector = new ScaleGestureDetector(getContext(), new PinchZoomListener());
        mGestureDetector = new GestureDetector(getContext(), new GestureListener());
    }

    private void initPaints() {
        mPaint = new Paint();
        mPaint.setColor(Color.BLACK);
        mPaint.setStyle(Paint.Style.FILL);
    }

    private void initGestureDetector() {
        mGestureDetector = new GestureDetector(
                getContext(), new GestureDetector.SimpleOnGestureListener() {
                    @Override
                    public boolean onDoubleTap(MotionEvent e) {
                        if (!mDoubleClickWhileWritingDisabled) {
                            if (getPage().getNumStrokes() == 0) {
                                // The page is empty, reset pinch zoom instead
                                resetPinchZoom();
                            } else {
                                // Reset the page
                                redraw(true);
                            }
                        }
                        return false;
                    }

                    @Override
                    public boolean onDown(MotionEvent e) {
                        mDoubleClickPossible = true;
                        return false;
                    }

                    @Override
                    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                        if (mDoubleClickPossible &&
                                isQuickEnough(e1, e2, velocityX, velocityY) &&
                                isFarEnough(e1, e2) &&
                                moveGestureWhileWriting()) {
                            mDoubleClickPossible = false;
                            movePage(velocityX, velocityY);
                            return true;
                        }
                        return false;
                    }

                    @Override
                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
                        if (!moveGestureWhileWriting()) {
                            return false;
                        }
                        mDoubleClickPossible = false;
                        movePage(-distanceX, -distanceY);
                        return true;
                    }
                });
    }

    private void handleFingerTouch(MotionEvent event, long timeDiff, float x, float y) {
        int action = event.getActionMasked();
        boolean isStartOfStroke = false;
        boolean isEndOfStroke = false;

        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mDownTime = event.getEventTime();
                mStartFromOutside = !mRect.contains((int) x, (int) y);
                if (mStartFromOutside) {
                    x = mDownX = mLastX = mRect.centerX();
                    y = mDownY = mLastY = mRect.centerY();
                }
                if (!mDoubleClickStarted && timeDiff <= ViewConfiguration.getDoubleTapTimeout() && mDoubleClickPossible && !mPinchZoomed) {
                    mDoubleClickStarted = true;
                } else {
                    mDoubleClickStarted = false;
                    mHwPenCommand = createPenCommand(x, y, event);
                    isStartOfStroke = true;
                }"
153,"import com.google.api.client.auth.oauth2.ClientCredentials;
import com.google.api.client.auth.oauth2.ClientParametersAuthentication;
import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.auth.oauth2.CredentialStore;
import com.google.api.client.auth.oauth2.TokenResponse;
import com.google.api.client.extensions.auth.helpers.CredentialFactory;
import com.google.api.client.extensions.guava.GuavaScopes;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.util.store.FileDataStoreFactory;
import java.io.File;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.Collection;

public class OAuth2ClientCredentials {

  private static final String APPLICATION_NAME = ""Google OAuth2"";
  private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();
  private static final String TOKENS_DIRECTORY_PATH = ""tokens"";

  /**
   * Global instance of the scopes required by this application. If modifying these
   * scopes, delete your previously saved tokens/ folder.
   */
  private static final Collection<String> SCOPES =
      GuavaScopes.newArrayList(""https://www.googleapis.com/auth/calendar"");
  private static final String CREDENTIALS_FILE_PATH = ""/credentials.json"";

  /**
   * Creates an authorized Credential object.
   *
   * @param HTTP_TRANSPORT The network HTTP Transport.
   * @return An authorized Credential object.
   * @throws IOException If the credentials.json file cannot be found.
   */
  public static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)
      throws IOException {

    // Load client secrets.
    GoogleClientSecrets clientSecrets =
        GoogleClientSecrets.load(JSON_FACTORY, OAuth2ClientCredentials.class.getResourceAsStream(CREDENTIALS_FILE_PATH));

    // Build flow and trigger user authorization request.
    GoogleAuthorizationCodeFlow flow =
        new GoogleAuthorizationCodeFlow.Builder(
                HTTP_TRANSPORT,
                JSON_FACTORY,
                clientSecrets,
                SCOPES)
            .setDataStoreFactory(
                new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
            .setAccessType(""offline"")
            .build();
    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
    return new AuthorizationCodeInstalledApp(flow, receiver).authorize(""user"");
  }

  public static void main(String... args) throws IOException, GeneralSecurityException {
    // Build a new authorized API client service.
    final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Credential credential = getCredentials(HTTP_TRANSPORT);
    // Create a credential factory for the client ID and secret.
    ClientCredentials clientCredentials =
        new ClientCredentials(
            clientSecrets.getDetails().getClientId(), clientSecrets.getDetails().getClientSecret());
    // Create the client authentication based on the credential factory.
    ClientParametersAuthentication clientParametersAuthentication =
        new ClientParametersAuthentication(clientCredentials);
    // Set up authorization code flow.
    final GoogleAuthorizationCodeFlow flow =
        new GoogleAuthorizationCodeFlow.Builder(
                HTTP_TRANSPORT,
                JSON_FACTORY,
                clientSecrets,
                SCOPES)
            .setCredentialStore(new CredentialStore() {
              public void store(String key, Credential credential) throws IOException {}

              public Credential load(String key) throws IOException {
                return credential;
              }

              public void delete(String key, Credential credential) throws IOException {}

              public boolean containsKey(String key) throws IOException {
                return false;
              }

              public Collection<String> keySet() throws IOException {
                return null;
              }
            })
            .build();
    // Create the credential factory for storing credentials.
    CredentialFactory credentialFactory =
        new CredentialFactory(flow, clientParametersAuthentication) {
          @Override
          public Credential createAndStoreCredentialsFromResponse(
              TokenResponse tokenResponse, Credential credential) throws IOException {
            return flow.createAndStoreCredential(
                tokenResponse, ClientOAuth2Credentials.CLIENT_ID, credential);
          }
        };
    // Obtain token from credential flow.
    Credential refreshedCredential = flow.refreshAccessToken();
  }
}"
154,"import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Presence;
import org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration;
import org.jivesoftware.smackx.ping.PingFailedListener;
import org.jivesoftware.smackx.ping.PingManager;
import org.jivesoftware.smackx.pubsub.PubSubManager;
import org.jivesoftware.smackx.pubsub.Topic;
import org.jivesoftware.smackx.pubsub.VenueManager;
import org.jivesoftware.smackx.pubsub.util.SubscriberEventListener;
import org.jivesoftware.smackx.pubsub.util.SubscriptionEventListener;

import com.google.common.collect.Maps;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import com.google.inject.name.Named;

import net.shibboleth.ext.spring.service.BaseSpringService;
import net.shibboleth.utilities.java.support.component.ComponentSupport;
import net.shibboleth.utilities.java.support.logic.ThrowableProxy;
import net.shibboleth.utilities.java.support.primitive.DeprecationSupport;
import net.shibboleth.utilities.java.support.primitive.StringSupport;

/**
 * {@link net.shibboleth.utilities.java.support.service.ServiceableService} that manages XMPP connections.
 * 
 * <p>This service has been deprecated in favor of
 * {@link net.shibboleth.idp.xmpp.impl.XMPPPingFlushService}, which provides more sophisticated xmpp connection
 * management and pinging.</p>
 *  
 * @since 3.4.0
 */
@Deprecated
@Singleton
public class XMPPService extends BaseSpringService<Map<String, XMPPConnection>> {

    /** Configuration data instance. */
    @Inject
    private ConfigurationContext configurationContext;

    /** XMPP connection instances. */
    private final Map<String, XMPPConnection> xmppConnections = Maps.newHashMap();

    /**
     * Constructor.
     *
     * @throws XMPPException if there is a problem in creating an XMPP connection
     */
    public XMPPService() throws XMPPException {
        super(""XMPP Service"");
    }

    /**
     * Get the configuration context.
     *
     * @return {@link ConfigurationContext}
     */
    public final ConfigurationContext getConfigurationContext() {
        return configurationContext;
    }

    /**
     * Get all XMPP connections.
     *
     * @return Map of connections
     */
    public final Map<String, XMPPConnection> getXmppConnections() {
        return xmppConnections;
    }

    /** {@inheritDoc} */
    @Override protected void doLoad() throws Throwable {
        ComponentSupport.ifInitializedThrowUnmodifiabledError(configurationContext, ""Configuration"");
        xmppConnections.clear();

        try {
            initializeConnectionFactories();
        } catch (final XMPPException e) {
            throw new ThrowableProxy(e);
        }
    }

    /** {@inheritDoc} */
    @Override protected void doUnload() throws Throwable {
        stop();
        ComponentSupport.ifNotInitializedThrowUninitializedError(xmppConnections, ""XMPP Connection Map"");
        xmppConnections.clear();
    }

    /**
     * Initializes the XMPP connection factories.
     *
     * @throws XMPPException if there is a problem initializing a connection factory
     */
    private void initializeConnectionFactories() throws XMPPException {
        final Set<XMPPServerCredentials> serverCredentialsList =
                configurationContext.getServerCredentialsList();

        if (serverCredentialsList == null || serverCredentialsList.isEmpty()) {
            logger.warn(""No XMPP servers registered, skipping initialization"");
            return;
        }

        for (final XMPPServerCredentials serverCredentials : serverCredentialsList) {
            final XMPPConnection connection = createConnection(serverCredentials);
            connection.connect();
            connection.login(serverCredentials.getUsername(), serverCredentials.getPassword());
            updatePresence(connection);
            addTopicListener(connection);
            attachPingManager(connection);
            xmppConnections.put(serverCredentials.getServiceId(), connection);
            logger.info(""Successfully initialized XMPP connection to {}."", serverCredentials.getServiceId());
        }
    }

    /**
     * Starts.
     *
     * @throws Throwable if there is a problem starting the service
     */
    public void start() throws Throwable {
        log.debug(""Starting XMPP Service"");
        if (!isInitialized()) {
            log.debug(""XMPP Service is not initialized. Calling load"");
            load();
        }
    }

    /**
     * Stops the listener and disconnects from XMPP servers.
     *
     * @throws Throwable if there is a problem starting the service
     */
    public void stop() throws Throwable {
        log.debug(""Stopping XMPP Service"");
        if (!xmppConnections.isEmpty()) {
            for (final XMPPConnection conn : xmppConnections.values()) {
                detachPingManager(conn);
                conn.disconnect();
            }
            xmppConnections.clear();
        }
        unload();
    }

    /**
     * Creates XMPP connection.
     *
     * @param serverCredentials server credentials to use for the connection
     * @return connection
     * @throws XMPPException if there is a problem creating the connection
     */
    private XMPPConnection createConnection(final XMPPServerCredentials serverCredentials) throws XMPPException {
        final XMPPTCPConnectionConfiguration config =
                XMPPTCPConnectionConfiguration.builder()
                        .setServiceName(serverCredentials.getServiceId())
                        .setHost(serverCredentials.getXmppServerAddress())
                        .setPort(serverCredentials.getXmppServerPort())
                        .setSecurityMode(serverCredentials.getSecurityMode())
                        .setConnectTimeout(configurationContext.getXmppConnectTimeout())
                        .setSendTimeout(configurationContext.getXmppSendTimeout())
                        .build();

        return new XMPPConnection(config);
    }

    /**
     * Adds the ping manager to the XMPP connection.
     *
     * @param conn xmpp connection
     */
    private void attachPingManager(final XMPPConnection conn) {
        final PingManager pingManager = PingManager.getInstanceFor(conn);
        final PingFailedListener listener = new PingFailedListener() {
            @Override public void pingFailed() {
                try {
                    logger.error(""Ping to '{}' failed. Attempting reconnect."",
                            conn.getServiceName());
                    conn.disconnect();
                    conn.connect();
                    conn.login(configurationContext.getUsername(), configurationContext.getPasswordFor(
                            conn.getServiceName()));
                    attachPingManager(conn);
                } catch (final XMPPException e) {
                    logger.error(""Failed ping reconnect to '{}'."", conn.getServiceName(), e);
                }
            }
        };
        pingManager.registerPingFailedListener(listener);
        pingManager.setPingInterval(configurationContext.getXmppPingInterval());
        pingManager.start();
    }

    /**
     * Removes the ping manager from the XMPP connection.
     *
     * @param conn xmpp connection
     */
    private void detachPingManager(final XMPPConnection conn) {
        final PingManager pingManager = PingManager.getInstanceFor(conn);
        pingManager.stop();
    }

    /**
     * Adds a topic listener for the provided connection.
     *
     * @param conn xmpp connection
     */
    private void addTopicListener(final XMPPConnection conn) {
        @SuppressWarnings(""unchecked"")
        final VenueManager venueManager = new VenueManager(conn);
        final PubSubManager manager = new PubSubManager(conn);
        final String topicName = configurationContext.getXmppTopic();
        if (StringSupport.isNullOrEmpty(topicName)) {
            logger.warn(""No XMPP topic configured. Skipping topic listener."");
            return;
        }
        try {
            final Topic topic = manager.getTopic(topicName);
            final SubscriberEventListener<SubscriptionEventListener> listener =
                    new SubscriberEventListener<SubscriptionEventListener>() {
                        @Override
                        protected void handleMessage(final String messageId, final SubscriptionEventListener listener,
                                final String subId, final Topic topic, final String message) {
                            logger.debug(""Received topic message {} in subscription {}"", messageId, subId);
                        }
                    };
            topic.subscribe(listener);
            logger.info(""Added topic listener to"
155,"public class MapUtils {

    private MapUtils() {
    }

    /**
     * Retrieve a String value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The String value.
     * @throws JSONException If the item does not contain a String value.
     */
    public static String getString(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (String) ((Map) pItem).get(""value"");
        } else if (pItem instanceof String) {
            return (String) pItem;
        }
        throw new JSONException(""Item does not contain a String value."");
    }

    /**
     * Retrieve a JSONObject value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The JSONObject value.
     * @throws JSONException If the item does not contain a JSONObject value.
     */
    public static JSONObject getObject(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (JSONObject) ((Map) pItem).get(""value"");
        } else if (pItem instanceof JSONObject) {
            return (JSONObject) pItem;
        }
        throw new JSONException(""Item does not contain a JSONObject value."");
    }

    /**
     * Retrieve a boolean value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The boolean value.
     * @throws JSONException If the item does not contain a boolean value.
     */
    public static boolean getBoolean(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (boolean) ((Map) pItem).get(""value"");
        } else if (pItem instanceof Boolean) {
            return (boolean) pItem;
        }
        throw new JSONException(""Item does not contain a boolean value."");
    }

    /**
     * Retrieve a double value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The double value.
     * @throws JSONException If the item does not contain a double value.
     */
    public static double getDouble(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (double) ((Map) pItem).get(""value"");
        } else if (pItem instanceof Double) {
            return (double) pItem;
        }
        throw new JSONException(""Item does not contain a double value."");
    }

    /**
     * Retrieve a float value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The float value.
     * @throws JSONException If the item does not contain a float value.
     */
    public static float getFloat(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (float) ((Map) pItem).get(""value"");
        } else if (pItem instanceof Float) {
            return (float) pItem;
        }
        throw new JSONException(""Item does not contain a float value."");
    }

    /**
     * Retrieve a long value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The long value.
     * @throws JSONException If the item does not contain a long value.
     */
    public static long getLong(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (long) ((Map) pItem).get(""value"");
        } else if (pItem instanceof Long) {
            return (long) pItem;
        }
        throw new JSONException(""Item does not contain a long value."");
    }

    /**
     * Retrieve an int value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The int value.
     * @throws JSONException If the item does not contain an int value.
     */
    public static int getInt(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (int) ((Map) pItem).get(""value"");
        } else if (pItem instanceof Integer) {
            return (int) pItem;
        }
        throw new JSONException(""Item does not contain an int value."");
    }

    /**
     * Retrieve a char value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The char value.
     * @throws JSONException If the item does not contain a char value.
     */
    public static char getChar(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (char) ((Map) pItem).get(""value"");
        } else if (pItem instanceof Character) {
            return (char) pItem;
        }
        throw new JSONException(""Item does not contain a char value."");
    }

    /**
     * Retrieve an Object value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The Object value.
     * @throws JSONException If the item does not contain an Object value.
     */
    public static Object get(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return ((Map) pItem).get(""value"");
        } else if (pItem instanceof JSONObject) {
            return pItem;
        }
        throw new JSONException(""Item does not contain an Object value."");
    }

    /**
     * Retrieve a JSONArray value from an arbitrary data source.
     *
     * @param pItem The item to get the value from.
     * @return The JSONArray value.
     * @throws JSONException If the item does not contain a JSONArray value.
     */
    public static JSONArray getArray(Object pItem) throws JSONException {
        Assert.notNull(pItem);
        if (pItem instanceof Map) {
            return (JSONArray) ((Map) pItem).get(""value"");
        } else if (pItem instanceof JSONArray) {
            return (JSONArray) pItem;
        }
        throw new JSONException(""Item does not contain a JSONArray value."");
    }

    /**
     * Returns whether the given object contains the specified key.
     *
     * @param pItem The object to check.
     * @param pKey  The key to check for.
     * @return True if the key is present, false otherwise.
     */
    public static boolean contains(Object pItem, String pKey) {
        Assert.notNull(pItem);
        Assert.notNull(pKey);
        if (pItem instanceof Map) {
            return ((Map) pItem).containsKey(pKey);
        } else if (pItem instanceof JSONObject) {
            return ((JSONObject) pItem).has(pKey);
        }
        return false;
    }

    /**
     * Put a value into a map.
     *
     * @param pMap  The map to put the value into.
     * @param pKey  The key to use.
     * @param pItem The value to put.
     */
    public static void put(Map<String, Object> pMap, String pKey, Object pItem) {
        Assert.notNull(pMap);
        Assert.notNull(pKey);
        Assert.notNull(pItem);
        pMap.put(pKey, wrap(pItem));
    }

    /**
     * Put the contents of the specified map into the given map.
     *
     * @param pMap1 The map to put the contents into.
     * @param pMap2 The map to get the contents from.
     */
    public static void putAll(Map<String, Object> pMap1, Map pMap2) {
        Assert.notNull(pMap1);
        Assert.notNull(pMap2);
        for (Object key : pMap2.keySet()) {
            pMap1.put((String) key, wrap(pMap2.get(key)));
        }
    }

    /**
     * Put the contents of the specified JSONObject into the given map.
     *
     * @param pMap1   The map to put the contents into.
     * @param pObject The JSONObject to get the contents from.
     */
    public static void putAll(Map<String, Object> pMap1, JSONObject pObject) {"
156,"import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine.Info;
import javax.sound.sampled.LineListener;
import javax.sound.sampled.SourceDataLine;

public class PcmPlayer {

  private static final int AUDIO_BUFFER_SIZE = 1024 * 256;
  private static final AtomicBoolean RUNNING = new AtomicBoolean(false);
  private static SourceDataLine line;
  private static String filePath;
  private static Thread playerThread;
  private static FLACDecoder decoder;
  private static AudioFormat fmt;
  private static Info info;

  public static void main(String[] args) {
    filePath = ""path/to/your/audio.flac"";
    play();
  }

  public static void play() {
    try {
      processStreamInfo();
      playerThread = new Thread(PcmPlayer::run);
      playerThread.start();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  public static void processStreamInfo() throws Exception {
    decoder = FLACDecoder.readMetadata(new FileInputStream(filePath));
    fmt = decoder.format();
    info = new Info(SourceDataLine.class, fmt);
  }

  public static void stop() {
    RUNNING.set(false);
    if (line != null) {
      line.stop();
      line.close();
    }
    if (playerThread != null) {
      playerThread.interrupt();
    }
  }

  public static void update(byte[] decoded) {
    line.write(decoded, 0, decoded.length);
  }

  public static void run() {
    try {
      line = (SourceDataLine) AudioSystem.getLine(info);
      line.open(fmt, AUDIO_BUFFER_SIZE);
      line.start();
      Lock lock = new ReentrantLock();
      Condition condition = lock.newCondition();
      int bytesRead = 0;
      byte[] decoded;
      RUNNING.set(true);
      while (bytesRead >= 0 && RUNNING.get()) {
        decoded = decoder.decodeNextFrame();
        lock.lock();
        try {
          update(decoded);
          condition.await(100, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
          System.out.println(""Interruption of line thread"");
        } finally {
          lock.unlock();
        }
      }
      stop();
    } catch (Exception e) {
      e.printStackTrace();
      stop();
    }
  }

  public static void removeListener(LineListener listener) {
    line.removeLineListener(listener);
  }

  public static void decode() {
    decoder.decodeNextFrame();
  }

  public static void addListener(LineListener listener) {
    line.addLineListener(listener);
  }
}"
157,"public int getOriginalSizeInBytes() {
      return (int) encode.length;
    }"
158,"import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.io.ByteSink;
import com.google.common.io.ByteSource;
import com.google.common.io.Files;
import com.google.protobuf.ByteString;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.net.InetSocketAddress;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import javax.annotation.Nullable;
import org.bitcoinj.core.BloomFilter;
import org.bitcoinj.core.GetDataMessage;
import org.bitcoinj.core.GetDataMessage.FilterType;
import org.bitcoinj.core.Message;
import org.bitcoinj.core.MessageSerializer;
import org.bitcoinj.core.NetworkParameters;
import org.bitcoinj.core.ProtocolException;
import org.bitcoinj.core.ProtocolVersion;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.Transaction;
import org.bitcoinj.core.VerificationException;
import org.bitcoinj.core.listeners.AbstractPeerConnectionEventListener;
import org.bitcoinj.core.listeners.OnTransactionBroadcastListener;
import org.bitcoinj.core.listeners.PeerConnectionEventListener;
import org.bitcoinj.script.Script;
import org.bitcoinj.utils.BlockFile;
import org.bitcoinj.utils.BriefLogFormatter;
import org.bitcoinj.utils.ListenerRegistration;
import org.bitcoinj.utils.Threading;
import org.bitcoinj.wallet.Protos.PeerAddress;
import org.bitcoinj.wallet.Protos.TransactionInput;
import org.bitcoinj.wallet.Protos.TransactionOutput;
import org.slf4j.LoggerFactory;

/**
 * <p>Functionality that does not depend on any particular implementation of {@link Message}, such as message parsing and checksumming.
 * The static methods defined in this class are useful for working with the Bitcoin protocol regardless of whether you're working
 * with block chain downloaded from the internet, creating transactions, or communicating with other nodes.</p>
 *
 * <p>To Parse a message you must:
 * <ol>
 * <li>Use {@link #seekPastMagicBytes(InputStream)} to read past the magic bytes header if present.</li>
 * <li>Use {@link #deserializeHeader(InputStream)} or {@link #deserializeHeader(ByteBuffer)} to deserialize the header.</li>
 * <li>Use {@link #deserializePayload(byte[], Message)} or {@link #deserializePayload(ByteBuffer, Message)} to deserialize the payload.</li>
 * </ol></p>
 *
 * <p>To calculate the checksum of a message you must:
 * <li>Use {@link #seekPastMagicBytes(InputStream)} to read past the magic bytes header if present.</li>
 * <li>Use {@link #calculateChecksum(InputStream)} or {@link #calculateChecksum(byte[])} or {@link #calculateChecksum(ByteBuffer)} to calculate the checksum.</li>
 * </ol></p>
 *
 * <p>Note that magic bytes are only found in messages that were written by a peer on the wire. If you are reading
 * blocks or other messages from disk, you should <b>not</b> use seekPastMagicBytes.</p>
 */
public class MessageSerializer {
    private static final org.slf4j.Logger log = LoggerFactory.getLogger(MessageSerializer.class);

    private final NetworkParameters params;

    /** The size of the header in bytes. */
    public static final int HEADER_LENGTH = 24;
    /** The size of the checksum in bytes. */
    public static final int CHECKSUM_LENGTH = 4;
    /** The maximum length of a message in bytes. */
    public static final int MAX_MESSAGE_LENGTH = MAX_SIZE_MESSAGE_OVERHEAD + MAX_SIZE_MESSAGE_PAYLOAD;
    /** The max message payload size a message can potentially have. */
    public static final int MAX_SIZE_MESSAGE_PAYLOAD = (int) Math.pow(2, 32);
    /** The max overhead in bytes a message can potentially have. */
    public static final int MAX_SIZE_MESSAGE_OVERHEAD = HEADER_LENGTH + CHECKSUM_LENGTH;

    /** A reference to the ""latest protocol version"" message header. */
    public static final BitcoinPacketHeader LATEST_PROTOCOL_VERSION_HEADER;

    static {
        // Note that the ""latest protocol version"" isn't actually the latest version - it's whatever the latest
        // version was at the time the library was compiled.
        LATEST_PROTOCOL_VERSION_HEADER = new BitcoinPacketHeader(params.getProtocolVersion(), 0);
    }

    /** The total length of the protocol magic bytes. */
    public static final int MAGIC_BYTES_LENGTH = 4;
    protected static final byte[] MAGIC_BYTES = params.getNetMagicBytes();

    /** The offset of the protocol version in the header. */
    public static final int PROTOCOL_VERSION_OFFSET = 0;
    /** The offset of the payload length in the header. */
    public static final int PAYLOAD_LENGTH_OFFSET = 4;
    /** The offset of the checksum in the header. */
    public static final int CHECKSUM_OFFSET = 16;

    /** The offset of the command in the header. */
    public static final int COMMAND_OFFSET = 12;
    /** The max length of the command in the header. */
    public static final int COMMAND_LEN = 12;

    public static final boolean DEFAULT_PARSE_LAZY = false;
    public static final boolean DEFAULT_PARSE_RETAIN = false;

    protected final Map<Class<? extends Message>, String> names = new HashMap<>();

    /** Constructs a message serializer with the given behavior. */
    public MessageSerializer(NetworkParameters params) {
        this.params = params;
    }

    /**
     * Writes a message to the given file.
     *
     * @param file
     *            The file to write to.
     * @param message
     *            The message to write.
     * @throws IOException
     *             if an error occurs while writing the file.
     */
    public void writeMessage(File file, Message message) throws IOException {
        FileOutputStream out = new FileOutputStream(file);
        try {
            writeMessage(out, message);
            out.flush();
        } finally {
            out.close();
        }
    }

    /**
     * Writes a message to the given stream.
     *
     * @param stream
     *            The stream to write to.
     * @param message
     *            The message to write.
     * @throws IOException
     *             if an error occurs while writing the stream.
     */
    public void writeMessage(OutputStream stream, Message message) throws IOException {
        writeMessage(stream, message, false);
    }

    /**
     * Writes a message to the given stream.
     *
     * @param stream
     *            The stream to write to.
     * @param message
     *            The message to write.
     * @param parseLazy
     *            Whether to use parse lazy mode
     * @throws IOException
     *             if an error occurs while writing the stream.
     */
    public void writeMessage(OutputStream stream, Message message, boolean parseLazy) throws IOException {
        networkSerializeToStream(message, stream, parseLazy);
    }

    /**
     * Writes a message to the given file.
     *
     * @param file
     *            The file to write to.
     * @param message
     *            The message to write.
     * @throws IOException
     *             if an error occurs while writing the file.
     */
    public static void writeMessage(File file, Message message, NetworkParameters params) throws IOException {
        FileOutputStream out = new FileOutputStream(file);
        try {
            writeMessage(out, message, params);
            out.flush();
        } finally {
            out.close();
        }
    }

    /**
     * Writes a message to the given stream.
     *
     * @param stream
     *            The stream to write to.
     * @param message
     *            The message to write.
     * @throws IOException
     *             if an error occurs while writing the stream.
     */
    public static void writeMessage(OutputStream stream, Message message"
159,"import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.Arrays;

public class FeedRun {
    private BigDecimal feedConfigId;
    private Timestamp startDate;
    private String resultCode;
    private String resultMessage;
    private BigDecimal fileCount;
    private Timestamp maxReceiptDate;
    private BigDecimal downloadSize;
    private BigDecimal feedId;
    private String configInfo;
    private long runId;
    private byte[] errors;
    private String runStatus;

    public BigDecimal getFeedConfigId() {
        return feedConfigId;
    }

    public Timestamp getStartDate() {
        return startDate;
    }

    public String getResultCode() {
        return resultCode;
    }

    public String getResultMessage() {
        return resultMessage;
    }

    public BigDecimal getFileCount() {
        return fileCount;
    }

    public Timestamp getMaxReceiptDate() {
        return maxReceiptDate;
    }

    public BigDecimal getDownloadSize() {
        return downloadSize;
    }

    public BigDecimal getFeedId() {
        return feedId;
    }

    public void setFeedId(BigDecimal feedId) {
        this.feedId = feedId;
    }

    public String getConfigInfo() {
        return configInfo;
    }

    public void setConfigInfo(String configInfo) {
        this.configInfo = configInfo;
    }

    public long getRunId() {
        return runId;
    }

    public void setRunId(long runId) {
        this.runId = runId;
    }

    public byte[] getErrors() {
        return errors;
    }

    public void setErrors(byte[] errors) {
        this.errors = errors;
    }

    public String getRunStatus() {
        return runStatus;
    }

    public void setRunStatus(String runStatus) {
        this.runStatus = runStatus;
    }

    public void setFeedConfigId(BigDecimal feedConfigId) {
        this.feedConfigId = feedConfigId;
    }

    public void setStartDate(Timestamp startDate) {
        this.startDate = startDate;
    }

    public void setResultCode(String resultCode) {
        this.resultCode = resultCode;
    }

    public void setResultMessage(String resultMessage) {
        this.resultMessage = resultMessage;
    }

    public void setFileCount(BigDecimal fileCount) {
        this.fileCount = fileCount;
    }

    public void setMaxReceiptDate(Timestamp maxReceiptDate) {
        this.maxReceiptDate = maxReceiptDate;
    }

    public void setDownloadSize(BigDecimal downloadSize) {
        this.downloadSize = downloadSize;
    }

    public void setEndDate(Timestamp endDate) {
        this.endDate = endDate;
    }

    private Timestamp endDate;

    public Timestamp getEndDate() {
        return endDate;
    }

    @Override
    public String toString() {
        return ""FeedRun{"" +
                ""feedConfigId="" + feedConfigId +
                "", startDate="" + startDate +
                "", endDate="" + endDate +
                "", resultCode='"" + resultCode + '\' +
                "", resultMessage='"" + resultMessage + '\' +
                "", fileCount="" + fileCount +
                "", maxReceiptDate="" + maxReceiptDate +
                "", downloadSize="" + downloadSize +
                "", feedId="" + feedId +
                "", configInfo='"" + configInfo + '\' +
                "", runId="" + runId +
                "", errors="" + Arrays.toString(errors) +
                "", runStatus='"" + runStatus + '\' +
                '}';
    }
}"
160,"import android.util.Log;
import androidx.annotation.NonNull;
import com.parrot.arsdk.arcommands.ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY;
import com.parrot.arsdk.arcommands.ARCOMMANDS_ARDRONE3_PILOTING_SPIN;
import com.parrot.arsdk.arcommands.ARCOMMANDS_COMMON_COMMON_ALLSTATES_CMD;
import com.parrot.arsdk.arcommands.ARCOMMANDS_COMMON_VELOCITY;
import com.parrot.arsdk.arcontroller.ARController;
import com.parrot.arsdk.arcontroller.ARControllerCodec;
import com.parrot.arsdk.arcontroller.ARControllerException;
import com.parrot.arsdk.arcontroller.ARControllerListener;
import com.parrot.arsdk.ardiscovery.ARDISCOVERY_PRODUCT_ENUM;
import com.parrot.arsdk.ardiscovery.ARDiscoveryDevice;
import com.parrot.arsdk.ardiscovery.ARDiscoveryException;
import com.parrot.arsdk.ardiscovery.ARDiscoveryService;
import java.util.ArrayList;
import java.util.List;

public class GeneralMotorCon implements ARControllerListener {

    private static GeneralMotorCon ourInstance = null;

    public static GeneralMotorCon getInstance() {
        if (ourInstance == null) {
            ourInstance = new GeneralMotorCon();
        }
        return ourInstance;
    }

    private ARDiscoveryService service;
    private ARDiscoveryDevice device;
    private ARController controller;
    private ARDrone drone;
    private CommandManager cmd;
    private int speed = 0;
    private int spinSpeed = 0;
    private int spin90Speed = 0;
    private int hoverTime = 0;
    private int spinTime = 0;
    private int spin90Time = 0;
    private static final String TAG = GeneralMotorCon.class.getSimpleName();
    private int batLvl = 0;
    private long threadTimer = 0;

    private GeneralMotorCon() {
        cmd = new CommandManager();
    }

    public void setDrone(ARDrone drone) {
        this.drone = drone;
    }

    @Override
    public void onCommandReceived(List<Integer> list) {
        Thread.currentThread().setName(""GeneralMotorCon"");
        Log.i(TAG, ""onCommandReceived: "" + list);
        if (list.size() >= 8 && list.get(0) == 50) {
            if (list.get(1) == 0) {
                cmd.addCommand(list, ""spin90Right"");
            } else if (list.get(1) == 1) {
                cmd.addCommand(list, ""spin90Left"");
            } else if (list.get(1) == 2) {
                cmd.addCommand(list, ""backward"");
            } else if (list.get(1) == 3) {
                cmd.addCommand(list, ""forward"");
            } else if (list.get(1) == 4) {
                cmd.addCommand(list, ""right"");
            } else if (list.get(1) == 5) {
                cmd.addCommand(list, ""left"");
            } else if (list.get(1) == 6) {
                cmd.addCommand(list, ""raiseAltitude"");
            } else if (list.get(1) == 7) {
                cmd.addCommand(list, ""lowerAltitude"");
            } else if (list.get(1) == 8) {
                cmd.addCommand(list, ""takeoff"");
            } else if (list.get(1) == 9) {
                cmd.addCommand(list, ""landing"");
            }
        }
    }

    @SuppressWarnings(""unused"")
    public void setBatLvl(int batLvl) {
        this.batLvl = batLvl;
    }

    @Override
    public void onStateChanged(ARControllerState arControllerState) {
        switch (arControllerState) {
            case RUNNING:
                Log.i(TAG, ""RUNNING"");
                break;
            case CONNECTED:
                Log.i(TAG, ""UUID: "" + controller.getARControllerDevice().getUUID());
                Log.i(TAG, ""CONNECTED"");
                break;
            case DISCONNECTED:
                Log.i(TAG, ""DISCONNECTED"");
                break;
            default:
                break;
        }
    }

    @Override
    public void onExtensionStateChanged(ARControllerState arControllerState, ARDISCOVERY_PRODUCT_ENUM ardiscovery_product_enum) {
    }

    @Override
    public void onError(ARControllerException e) {
        Log.e(TAG, ""onError: "" + e);
    }

    @Override
    public void onConfigureController(@NonNull ARControllerCodec arControllerCodec) {
        try {
            arControllerCodec.setCommandListener(this);
        } catch (ARControllerException e) {
            e.printStackTrace();
        }
    }

    public int getBatLvl() {
        return batLvl;
    }

    public void spin90Left() {
        controller.sendCommand(ARCOMMANDS_ARDRONE3_PILOTING_SPIN.encodeSPIN(ARCOMMANDS_ARDRONE3_PILOTING_SPIN.SPIN_DIRECTION_TYPE_CLOCKWISE, spin90Time, spin90Speed));

        Log.i(TAG, String.format(""spin90Left, spinTime: %d"", spin90Time));
        spinWait();
    }

    public void spinRight() {
        controller.sendCommand(ARCOMMANDS_ARDRONE3_PILOTING_SPIN.encodeSPIN(ARCOMMANDS_ARDRONE3_PILOTING_SPIN.SPIN_DIRECTION_TYPE_COUNTERCLOCKWISE, spinTime, spinSpeed));
        Log.i(TAG, String.format(""spinRight, spinTime: %d"", spinTime));
        spinWait();
    }

    public void takeoff() {
        controller.sendCommand(ARCOMMANDS_COMMON_COMMON_ALLSTATES_CMD.encodeALLOUT(1));
        Log.i(TAG, ""takeoff"");
        takeoffWait();
    }

    public void forward() {
        controller.sendCommand(
                ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.encodeMOVEBY(ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.AXIS_TYPE_X, ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.DIRECTION_TYPE_POS, Math.round(speed * Math.cos(Math.toRadians(drone.getHeading()))), Math.round(speed * Math.sin(Math.toRadians(drone.getHeading()))), 0, 0));

        Log.i(TAG, String.format(""forward, speed: %d"", speed));
        movementWait();
    }

    public void spinLeft() {
        controller.sendCommand(ARCOMMANDS_ARDRONE3_PILOTING_SPIN.encodeSPIN(ARCOMMANDS_ARDRONE3_PILOTING_SPIN.SPIN_DIRECTION_TYPE_CLOCKWISE, spinTime, spinSpeed));
        Log.i(TAG, String.format(""spinLeft, spinTime: %d"", spinTime));
        spinWait();
    }

    public void right() {
        controller.sendCommand(
                ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.encodeMOVEBY(ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.AXIS_TYPE_X, ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.DIRECTION_TYPE_NEG, Math.round(speed * Math.cos(Math.toRadians(drone.getHeading()))), Math.round(speed * Math.sin(Math.toRadians(drone.getHeading()))), 0, 0));
        Log.i(TAG, String.format(""right, speed: %d"", speed));
        movementWait();
    }

    public void lowerAltitude() {
        controller.sendCommand(
                ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.encodeMOVEBY(ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.AXIS_TYPE_Z, ARCOMMANDS_ARDRONE3_PILOTING_MOVE_BY.DIRECTION_TYPE_NEG, 0, 0, ARCOMMANDS_COMMON_VELOCITY.VELOCITY_025, 0));
        Log.i(TAG, ""lowerAltitude"");
        movementWait();
    }

    public void landing() {
        controller.sendCommand(ARCOMMANDS_COMMON_COMMON_ALLSTATES_CMD.encodeALLOUT(0));
        Log.i(TAG, ""landing"");
    }

    public void left() {
        controller.sendCommand(
                ARCOMMANDS_AR"
161,"import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

final class MapByClientIdCache {
  static final Map<Long, Integer> EMPTY = ImmutableMap.of();

  private final Cache<String, Integer> summaryCache;
  private final Cache<Long, Integer> byClientIdCache;

  MapByClientIdCache(ApprovedSiteService approvedSiteService, ClientDetailsEntityService clientService) {
    CacheBuilder<String, Integer> summaryBuilder =
        CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.HOURS);
    summaryCache = summaryBuilder.build(approvedSiteService::computeSummaryStats);
    CacheBuilder<Long, Integer> byClientBuilder =
        CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.HOURS);
    byClientIdCache = byClientBuilder.build(clientService::computeByClientId);
  }

  // cache miss returns 0
  public Map<Long, Integer> getByClientId() {
    if (byClientIdCache.size() == 0) {
      byClientIdCache.putAll(computeByClientId());
    }
    return byClientIdCache.asMap();
  }

  Map<Long, Integer> computeByClientId() {
    return EMPTY;
  }

  public void resetCache() {
    summaryCache.invalidateAll();
    byClientIdCache.invalidateAll();
  }

  // cache miss returns 0
  public Map<String, Integer> getSummaryStats() {
    if (summaryCache.size() == 0) {
      summaryCache.putAll(computeSummaryStats());
    }
    return summaryCache.asMap();
  }

  // overrides for testing
  public Map<String, Integer> computeSummaryStats() {
    return EMPTY;
  }

  public Supplier<Map<String, Integer>> createSummaryCache() {
    return summaryCache::asMap;
  }

  public Supplier<Map<Long, Integer>> createByClientIdCache() {
    return byClientIdCache::asMap;
  }
}"
162,"import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;

public final class XPathContext {
    private static final String OPEN = ""{"";
    private static final String CLOSE = ""}"";
    private static final String PI = ""PI"";
    private static final String TEXT = ""TEXT"";
    private static final String EMPTY = ""EMPTY"";
    private static final String COMMENT = ""COMMENT"";
    private static final String ATTR = ""ATTR"";
    private static final String SEP = "" "";

    public final String xpath;
    public final QName name;
    public final short type;
    public final Map<String, String> uri2Prefix;
    public final Map<QName, Level> attributes;
    public final List<Level> children;
    public final Deque<Level> path;
    public final String expression;

    private XPathContext(XPathContext context, short type, String expression) {
        this.xpath = context.xpath;
        this.name = context.name;
        this.type = type;
        this.uri2Prefix = context.uri2Prefix;
        this.attributes = context.attributes;
        this.children = context.children;
        this.path = context.path;
        this.expression = expression;
    }

    private XPathContext(String xpath, QName name, short type, Map<String, String> uri2Prefix,
                         Map<QName, Level> attributes, List<Level> children, Deque<Level> path, String expression) {
        this.xpath = xpath;
        this.name = name;
        this.type = type;
        this.uri2Prefix = uri2Prefix == null ? new HashMap<>() : uri2Prefix;
        this.attributes = attributes == null ? new HashMap<>() : attributes;
        this.children = children == null ? new ArrayList<>() : children;
        this.path = path == null ? new LinkedList<>() : path;
        this.expression = expression == null ? "" : expression;
    }

    public XPathContext clone() {
        return new XPathContext(xpath, name, type, uri2Prefix, attributes, children, path, expression);
    }

    public XPathContext clone(short type, String expression) {
        return new XPathContext(this, type, expression);
    }

    public String getName() {
        return name.toString();
    }

    public void appendChildren(List<Level> levels) {
        children.addAll(levels);
    }

    public void navigateToChild(Level child, String expression) {
        path.add(child);
        children = child.children;
        xpath = this.xpath + SEP + child.xpath;
        name = child.name;
        this.expression = expression;
    }

    public void navigateToParent() {
        if (!path.isEmpty()) {
            Level parent = path.removeLast();
            xpath = xpath.substring(0, xpath.lastIndexOf(SEP));
            children = parent.children;
            name = parent.name;
            expression = "";
        }
    }

    public void navigateToAttribute(QName name, String expression) {
        Level child;
        switch (type) {
            case Level.ELEMENT:
                child = attributes.get(name);
                if (child != null) {
                    xpath = this.xpath + SEP + child.xpath;
                    children = Collections.singletonList(child);
                    this.name = name;
                    this.expression = expression;
                } else {
                    throw new Error(""attribute "" + child + "" not found in "" + xpath);
                }
                break;
            case Level.ATTRIBUTE:
                if (name.equals(this.name)) {
                    this.expression = expression;
                }
                break;
        }
    }

    public String getXPath() {
        if (path.isEmpty()) {
            return xpath;
        } else {
            return xpath + SEP + path.getLast().xpath;
        }
    }

    public void addAttribute(QName name, String value) {
        attributes.put(name, new Level(xpath, name, Level.ATTRIBUTE, "", SEP + value));
    }

    public void addAttributes(Map<QName, String> attributes) {
        for (Map.Entry<QName, String> entry : attributes.entrySet()) {
            addAttribute(entry.getKey(), entry.getValue());
        }
    }

    public short getType() {
        return type;
    }

    private static class Level {
        public static final short ATTRIBUTE = 3;
        public static final short COMMENT = 5;
        public static final short ELEMENT = 1;
        public static final short EMPTY = 2;
        public static final short PI = 4;
        public static final short TEXT = 6;

        public final String xpath;
        public final QName name;
        public final short type;
        public final String expression;
        public final List<Level> children;

        private Level(String xpath, QName name, short type, String expression, String children) {
            this.xpath = xpath;
            this.name = name;
            this.type = type;
            this.expression = expression;
            this.children = parseChildren(children);
        }

        private List<Level> parseChildren(String children) {
            if ("".equals(children) || EMPTY.equals(children)) {
                return Collections.emptyList();
            } else {
                List<Level> result = new ArrayList<>();
                for (String child : children.split(SEP)) {
                    if (COMMENT.equals(child)) {
                        result.add(new Level(xpath, null, COMMENT, "", ""<!-- -->""));
                    } else if (TEXT.equals(child)) {
                        result.add(new Level(xpath, null, TEXT, "", "" ""));
                    } else if (PI.equals(child)) {
                        result.add(new Level(xpath, null, PI, "", ""<??>""));
                    } else if (OPEN.equals(child.substring(0, 1))) {
                        int i = child.indexOf(CLOSE);
                        result.add(new Level(xpath, new QName(child.substring(1, i)), ELEMENT, child.substring(i + 1), ""));
                    } else {
                        result.add(new Level(xpath, new QName(child), ATTRIBUTE, "", ""));
                    }
                }
                return result;
            }
        }

        public String toString() {
            return name == null ? typeToString() : name + "":"" + typeToString();
        }

        private String typeToString() {
            switch (type) {
                case ATTRIBUTE:
                    return ATTR;
                case COMMENT:
                    return COMMENT;
                case ELEMENT:
                    return OPEN + xpath + CLOSE;
                case EMPTY:
                    return EMPTY;
                case PI:
                    return PI;
                case TEXT:
                    return TEXT;
                default:
                    throw new Error(""unknown type "" + type);
            }
        }
    }
}"
163,"import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import com.google.protobuf.ByteString;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * An index which uses Linear Probing to resolve hash collisions. This index can be either loaded from
 * a byte array or created empty and populated with keys using {@link #put}.
 */
public class LinearProbingIndex {

  // Configuration parameters
  private static final int BUCKET_SIZE_BYTES = 4; // size of a bucket is 4 bytes
  private static final int INDEX_HASHER_SEED = 0x87654321; // seed for index hash function
  private static final int FINGERPRINT_HASHER_SEED = 0xfedcba98; // seed for fingerprint hash function
  private static final HashFunction FINGERPRINT_HASHER = Hashing.farmHashFingerprint64();
  private static final HashFunction INDEX_HASHER =
      Hashing.murmur3_32(INDEX_HASHER_SEED); // index hash function
  private static final int MAX_PROBES = 2; // number of probes to perform when searching for a key

  // Storage
  private ByteBuffer mHashTableBuf;
  private int mNumBuckets; // Number of buckets in the index

  /**
   * Constructor for {@link LinearProbingIndex}.
   *
   * @param mKeyCount Number of keys in the index
   * @param mBuf Byte buffer representing the index
   */
  private LinearProbingIndex(int mKeyCount, ByteBuffer mBuf) {
    // Initialize storage
    mHashTableBuf = mBuf;
    mHashTableBuf.order(ByteOrder.LITTLE_ENDIAN);
    mNumBuckets = mHashTableBuf.limit() / BUCKET_SIZE_BYTES;
  }

  /**
   * Create an empty LinearProbingIndex. The index must be populated with keys using {@link #put}.
   *
   * @param keyCount Number of keys in the index
   * @return Empty LinearProbingIndex
   */
  public static LinearProbingIndex createEmptyIndex(int keyCount) {
    // Allocate buffer for hash table
    ByteBuffer buf = ByteBuffer.allocate(keyCount * BUCKET_SIZE_BYTES);
    buf.order(ByteOrder.LITTLE_ENDIAN);
    return new LinearProbingIndex(keyCount, buf);
  }

  /**
   * Load a LinearProbingIndex from a byte array.
   *
   * @param data Byte array representing the index
   * @return Loaded LinearProbingIndex
   */
  public static LinearProbingIndex loadFromByteArray(byte[] data) {
    // Wrap byte array in byte buffer
    ByteBuffer buf = ByteBuffer.wrap(data);
    buf.order(ByteOrder.LITTLE_ENDIAN);
    // Extract key count
    int keyCount = buf.getInt();
    // Create empty index
    LinearProbingIndex index = createEmptyIndex(keyCount);
    // Copy index data into buffer
    buf.get(index.mHashTableBuf.array());
    return index;
  }

  /**
   * Get the byte count of the LinearProbingIndex.
   *
   * @return Byte count
   */
  public int byteCount() {
    return mNumBuckets * BUCKET_SIZE_BYTES;
  }

  /**
   * Get a key from the LinearProbingIndex.
   *
   * @param fingerprintHash Fingerprint hash of the key to get
   * @return Byte buffer representing the key
   */
  public ByteBuffer get(byte[] fingerprintHash) {
    // Calculate offset in hash table
    int bucketOffset = INDEX_HASHER.hashBytes(fingerprintHash).asInt() % mNumBuckets;
    // Search for key in hash table
    for (int i = 0; i < MAX_PROBES; i++) {
      int offset = bucketOffset * BUCKET_SIZE_BYTES + i * BUCKET_SIZE_BYTES;
      if (mHashTableBuf.array()[offset] == fingerprintHash[0]) {
        return ByteBuffer.wrap(mHashTableBuf.array(), offset + 1, 3);
      }
    }
    return null;
  }

  /**
   * Get the next key from the LinearProbingIndex.
   *
   * @param fingerprintHash Fingerprint hash of the current key
   * @return Byte buffer representing the next key
   */
  public ByteBuffer nextKey(byte[] fingerprintHash) {
    // Calculate offset in hash table
    int bucketOffset = INDEX_HASHER.hashBytes(fingerprintHash).asInt() % mNumBuckets;
    // Search for next key in hash table
    for (int i = 0; i < MAX_PROBES; i++) {
      int offset = bucketOffset * BUCKET_SIZE_BYTES + i * BUCKET_SIZE_BYTES;
      if (offset < mHashTableBuf.limit()
          && mHashTableBuf.array()[offset] != 0) {
        return ByteBuffer.wrap(mHashTableBuf.array(), offset + 1, 3);
      }
    }
    return null;
  }

  /**
   * Put a key into the LinearProbingIndex.
   *
   * @param key Byte buffer representing the key to put
   * @return True if the key was successfully put
   */
  public boolean put(ByteBuffer key) {
    // Calculate fingerprint hash of key
    byte[] fingerprintHash = FINGERPRINT_HASHER.hashBytes(key.array()).asBytes();
    // Calculate offset in hash table
    int bucketOffset = INDEX_HASHER.hashBytes(fingerprintHash).asInt() % mNumBuckets;
    // Search for empty bucket in hash table
    for (int i = 0; i < MAX_PROBES; i++) {
      int offset = bucketOffset * BUCKET_SIZE_BYTES + i * BUCKET_SIZE_BYTES;
      if (mHashTableBuf.array()[offset] == 0) {
        // Put fingerprint hash and key into bucket
        mHashTableBuf.array()[offset] = fingerprintHash[0];
        System.arraycopy(key.array(), 0, mHashTableBuf.array(), offset + 1, 3);
        return true;
      }
    }
    return false;
  }

  /**
   * Get the keys from the LinearProbingIndex as an iterator.
   *
   * @return Iterator over keys
   */
  public Iterator<ByteBuffer> keyIterator() {
    return new Iterator<ByteBuffer>() {
      private int mBucketOffset = 0;
      private int mProbeCount = 0;

      @Override
      public boolean hasNext() {
        while (mProbeCount < MAX_PROBES) {
          if (mBucketOffset < mNumBuckets) {
            if (mHashTableBuf.array()[mBucketOffset * BUCKET_SIZE_BYTES + mProbeCount * BUCKET_SIZE_BYTES] != 0) {
              return true;
            }
            mProbeCount++;
          } else {
            mBucketOffset = 0;
            mProbeCount = 0;
          }
        }
        return false;
      }

      @Override
      public ByteBuffer next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        int offset = mBucketOffset * BUCKET_SIZE_BYTES + mProbeCount * BUCKET_SIZE_BYTES;
        mBucketOffset++;
        mProbeCount = 0;
        return ByteBuffer.wrap(mHashTableBuf.array(), offset + 1, 3);
      }
    };
  }

  /**
   * Get the LinearProbingIndex as a byte array.
   *
   * @return Byte array representing the index
   */
  public byte[] getBytes() {
    // Allocate byte array for index
    byte[] data = new byte[byteCount() + 4];
    // Copy key count into byte array
    ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN).putInt(mNumBuckets);
    // Copy index data into byte array
    System.arraycopy(mHashTableBuf.array(), 0, data, 4, byteCount());
    return data;
  }
}"
164,"import net.sf.marineapi.nmea.parser.SentenceFactory;
import net.sf.marineapi.nmea.parser.SentenceParser;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class SentenceFactoryTest {

    private static final char TEST_CHAR = 't';

    private SentenceFactory factory;

    @Test
    void testRegisterInvalidParser() {
        boolean exceptionCaught = false;
        try {
            factory.registerParser(null, TEST_CHAR);
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    @Test
    void testUnregisterParser() {
        // register parser
        factory.registerParser(TestParser1.class, TEST_CHAR);
        // check parser exists
        Assertions.assertTrue(factory.hasParser(TEST_CHAR));
        // unregister parser
        factory.unregisterParser(TEST_CHAR);
        // check parser no longer exists
        Assertions.assertFalse(factory.hasParser(TEST_CHAR));
    }

    @Test
    void testListParsers() {
        // register parser
        factory.registerParser(TestParser1.class, TEST_CHAR);
        // check parser exists
        Assertions.assertArrayEquals(new Class[]{TestParser1.class}, factory.listParsers());
    }

    @Test
    void testCreateParserWithNull() {
        boolean exceptionCaught = false;
        try {
            factory.createParser((char) 0);
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    @Test
    void testCreateEmptyParserWithSentenceIdStr() {
        boolean exceptionCaught = false;
        try {
            factory.createParser("");
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    @Test
    void testCreateEmptyCustomParser() {
        boolean exceptionCaught = false;
        try {
            factory.createParser((Class<? extends SentenceParser>) null);
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    @Test
    void testCreateParserWithUnregistered() {
        boolean exceptionCaught = false;
        try {
            factory.createParser(TestParser2.class);
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    @Test
    void testCreateEmptyParserWithSentenceId() {
        boolean exceptionCaught = false;
        try {
            factory.createParser(null);
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    @Test
    void testCreateCustomParser() {
        TestParser3 parser = factory.createParser(TestParser3.class);
        Assertions.assertNotNull(parser);
    }

    @Test
    void testRegisterParserWithAlternativeBeginChar() {
        factory.registerParser(TestParser1.class, TEST_CHAR, 'a');
        Assertions.assertTrue(factory.hasParser(TEST_CHAR));
        Assertions.assertTrue(factory.hasParser('a'));
    }

    @Test
    void testSupportedTypesRegistered() {
        factory.registerParser(TestParser1.class, TEST_CHAR);
        SentenceParser parser = factory.createParser(TEST_CHAR);
        Assertions.assertTrue(parser instanceof TestParser1);
    }

    @Test
    void testCreateParser() {
        SentenceParser parser = factory.createParser(TEST_CHAR);
        Assertions.assertNotNull(parser);
    }

    @Test
    void testCreateParserWithRandom() {
        char randomChar = randomChar();
        SentenceParser parser = factory.createParser(randomChar);
        Assertions.assertEquals(randomChar, parser.getSentenceId());
    }

    @Test
    void setUp() {
        factory = SentenceFactory.getInstance();
    }

    @Test
    void testGetInstance() {
        Assertions.assertNotNull(factory);
    }

    @Test
    void testCreateParserWithEmptyString() {
        boolean exceptionCaught = false;
        try {
            factory.createParser("");
        } catch (IllegalArgumentException e) {
            exceptionCaught = true;
        }
        Assertions.assertTrue(exceptionCaught);
    }

    // custom sentence parser
    private static class TestParser1 implements SentenceParser {

        @Override
        public char getSentenceId() {
            return TEST_CHAR;
        }

        @Override
        public boolean isSentenceIdChar(char id) {
            return false;
        }

        @Override
        public void parse(String sentence) {
        }
    }

    // custom sentence parser
    private static class TestParser2 implements SentenceParser {

        @Override
        public char getSentenceId() {
            return 'T';
        }

        @Override
        public boolean isSentenceIdChar(char id) {
            return false;
        }

        @Override
        public void parse(String sentence) {
        }
    }

    // custom sentence parser
    private static class TestParser3 implements SentenceParser {

        @Override
        public char getSentenceId() {
            return '3';
        }

        @Override
        public boolean isSentenceIdChar(char id) {
            return false;
        }

        @Override
        public void parse(String sentence) {
        }
    }

    private static char randomChar() {
        return (char) (Math.random() * (126 - 33) + 33);
    }
}"
165,"import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableSet;
import java.util.regex.Pattern;
import org.apache.http.Header;
import org.apache.http.HttpRequest;
import org.apache.http.util.TextUtils;

public class ProxyUtils {
  // commaSeparatedValuesPattern is used to match and split a comma-separated list of values,
  // and the values must not contain commas.
  private static final Pattern commaSeparatedValuesPattern =
      Pattern.compile(""(?:[^,]+,)*[^,]+"");

  // log is the log level for this class, it will not be null because we set it in the constructor
  // of our parent.
  private ESLogger log;

  private String remoteIpHeader = ""X-Forwarded-For"";
  private Pattern trustedProxies;
  private Pattern internalProxies = Pattern.compile("".*"");
  private String proxiesHeader = ""x-forwarded-by"";

  // commaDelimitedListToStringArray creates an array of strings by splitting a comma-delimited string.
  private String[] commaDelimitedListToStringArray(String commaSeparatedList) {
    return Splitter.on("","").splitToList(commaSeparatedList).toArray(new String[0]);
  }

  // detect populates data structures to configure the HTTP client and sets the header used to detect
  // the client's real IP.
  public void detect(HttpRequest request) {
    // We don't want to use log.debug() here because this method is called on every request, and it is
    // pointless to have so many logs at this level.
    log.trace(""Detecting proxy headers"");

    if (!TextUtils.isEmpty(proxiesHeader)) {
      String proxiesValue = getProxiesHeader(request);

      if (!TextUtils.isEmpty(proxiesValue)) {
        // The proxies header contains a comma-separated list of the intermediate proxies
        // that have been traversed by the HTTP request.
        String[] proxies = commaDelimitedListToStringArray(proxiesValue);

        // Get the trusted proxies.
        String trustedProxiesValue = getTrustedProxies();
        Pattern trustedProxiesPattern =
            trustedProxiesValue == null ? internalProxies : trustedProxies;

        // Get the internal proxies.
        Pattern internalProxiesPattern =
            internalProxies == null ? trustedProxiesPattern : internalProxies;

        // Populate data structures to configure the HTTP client.
        for (String proxy : proxies) {
          if (trustedProxiesPattern.matcher(proxy).matches()) {
            // This is a trusted proxy, so we can use it to detect the client's real IP.
            setRemoteIpHeader(proxy);
          }
        }
      }
    }
  }

  public String getRemoteIpHeader() {
    return remoteIpHeader;
  }

  // setRemoteIpHeader sets the header that will be used to detect the client's real IP.
  public void setRemoteIpHeader(String header) {
    remoteIpHeader = header;
  }

  // getProxiesHeader returns the value of the proxies header, which can be comma-delimited.
  public String getProxiesHeader(HttpRequest request) {
    Header proxiesHeader = request.getFirstHeader(this.proxiesHeader);
    return proxiesHeader != null ? proxiesHeader.getValue() : null;
  }

  // getInternalProxies returns the regular expression that is used to match internal proxies.
  public String getInternalProxies() {
    return internalProxies == null ? null : internalProxies.pattern();
  }

  // setInternalProxies sets the regular expression that is used to match internal proxies.
  public void setInternalProxies(String pattern) {
    internalProxies = pattern == null ? null : Pattern.compile(pattern);
  }

  // getTrustedProxies returns the regular expression that is used to match trusted proxies.
  public String getTrustedProxies() {
    return trustedProxies == null ? null : trustedProxies.pattern();
  }

  // setInternalProxies sets the regular expression that is used to match trusted proxies.
  public void setTrustedProxies(String pattern) {
    trustedProxies = pattern == null ? null : Pattern.compile(pattern);
  }
}"
166,"private static final short TEXT = 1;
 private static final short ATTR = 2;
 private static final short OPEN = 4;
 private static final short CLOSE = 8;
 private static final short EMPTY = 16;
 private static final short PI = 32;
 private static final short COMMENT = 64;
 private static final String SEP = ""/"";
 private static final String ATTR = ""@"";
 private static final String EMPTY = "";

 private final String xpath;
 private final QName name;
 private final String expression;
 private final QName pushName;
 private final int level;
 private final short type;

 private final Map<String, String> uri2Prefix = new HashMap<String, String>();
 private final Map<QName, Level> attributes = new HashMap<QName, Level>();

 private Deque<Level> path = new ArrayDeque<Level>();

 private final List<Level> children = new ArrayList<Level>();

 public static String stringify(Level level, XPathContext context) {
  String uri = level.name.getURI();
  String prefix = context.getPrefixForURI(uri);

  String xpath = "";

  if (level.pushName != null) {
   xpath += stringify(level.pushName, context);
  }

  if (level.uri2Prefix.size() > 0) {
   for (Map.Entry<String, String> e : level.uri2Prefix.entrySet()) {
    xpath += ""declare namespace "" + e.getValue() + "" = \"" + e.getKey() + ""\""; "";
   }
  }

  switch (level.type) {
   case PI:
    xpath += ""processing-instruction("";
    xpath += ""\'"" + level.expression + ""\'""
      + "")"";
    break;
   case TEXT:
    xpath += ""\'"" + level.expression + ""\'"";
    break;
   case OPEN:
    if (prefix != null && prefix.length() > 0)
     xpath += prefix + "":"";
    xpath += level.name.getLocalPart();
    xpath += OPEN;
    if (level.attributes.size() > 0) {
     for (Map.Entry<QName, Level> e : level.attributes.entrySet()) {
      xpath += "" "" + stringify(e.getValue(), context);
     }
    }
    break;
   case CLOSE:
    if (prefix != null && prefix.length() > 0)
     xpath += prefix + "":"";
    xpath += level.name.getLocalPart();
    xpath += CLOSE;
    break;
   case EMPTY:
    if (prefix != null && prefix.length() > 0)
     xpath += prefix + "":"";
    xpath += level.name.getLocalPart();
    break;
   case COMMENT:
    xpath += ""<!--"" + level.expression + ""-->"";
    break;
   case ATTR:
    xpath += ATTR;
    if (prefix != null && prefix.length() > 0)
     xpath += prefix + "":"";
    xpath += level.name.getLocalPart();
    xpath += ""='"";
    xpath += level.expression + ""'"";
    break;
  }

  if (level.children.size() > 0) {
   xpath += SEP;

   for (Level child : level.children) {
    xpath += stringify(child, context);
   }
  }

  return xpath;
 }

 public String stringify(XPathContext context) {
  return stringify(this, context);
 }

 public String stringify() {
  return stringify(this, XPathContext.EMPTY);
 }

 public String stringify(boolean invert) {
  if (!invert) {
   return stringify();
  }

  Level top = this;
  while (top.parentLevel != null) {
   top = top.parentLevel;
  }

  return stringify(top, top.xpathContext.getInvertedContext());
 }

 private Level(int level, QName name, QName pushName, String expression, short type,
   Map<String, String> uri2Prefix, Map<QName, Level> attributes,
   XPathContext xpathContext, Level parentLevel) {

  this.level = level;
  this.xpath = xpathContext.getXPathString(level);
  this.name = name;
  this.expression = expression;
  this.pushName = pushName;
  this.uri2Prefix = uri2Prefix;
  this.attributes = attributes;
  this.xpathContext = xpathContext;
  this.parentLevel = parentLevel;
  this.type = type;
 }

 private void navigateToParent() {
  parentLevel = parentLevel.parentLevel;

  if (parentLevel == null)
   return;

  if (type == OPEN)
   parentLevel.children.add(this);
  else if (type == CLOSE) {
   parentLevel.children.add(this);
   xpathContext.resolveUri2Prefix(parentLevel.uri2Prefix);

   Map<String, String> attrs = invert(uri2Prefix);
   for (Map.Entry<QName, Level> e : attributes.entrySet()) {
    String uri = e.getKey().getURI();
    String prefix = attrs.get(uri);
    if (prefix != null && prefix.length() > 0) {
     e.getValue().uri2Prefix.put(uri, prefix);
    }
   }

   if (parentLevel.pushName != null) {
    Level level = parentLevel.pushName;

    if (level.type == OPEN) {
     xpathContext.declarePrefix(name.getURI(), name.getLocalPart());
     path.push(this);
     return;
    }
   }

   xpathContext.release(path);
  } else if (type != EMPTY)
   parentLevel.attributes.put(name, this);
 }

 public String getName() {
  return name.getLocalPart();
 }

 public QName getName() {
  return name;
 }

 public void appendChildren() {
  if (parentLevel == null)
   return;

  parentLevel.children.addAll(children);
 }

 private static Map<String, String> invert(Map<String, String> map) {
  Map<String, String> invertedMap = new HashMap<String, String>();

  for (Map.Entry<String, String> e : map.entrySet()) {
   invertedMap.put(e.getValue(), e.getKey());
  }

  return invertedMap;
 }

 private void addAttribute() {
  attributes.put(name, this);
 }

 public short getType() {
  return type;
 }

 public short getType() {
  return type;
 }

 private void addAttributes() {
  if (parentLevel == null)
   return;
  parentLevel.attributes.putAll(attributes);
 }

 public XPathContext clone() {
  Level top = this;
  while (top.parentLevel != null) {
   top = top.parentLevel;
  }

  XPathContext copy = top.xpathContext.clone();
  return top.clone(copy);
 }

 public Level clone(XPathContext xpathContext) {
  return new Level(level, name, pushName, expression, type, uri2Prefix, attributes,
    xpathContext, parentLevel);
 }

 private int add1OrIncrement() {
  if (xpathContext.prefixes.containsKey(name.getURI())) {
   String prefix = xpathContext.prefixes.get(name.getURI());
   uri2Prefix.put(name.getURI(), prefix);
   return 0;
  }

  return xpathContext.generateUniquePrefix();
 }

 private void navigateToChild(Level child) {
  if (type == PI) {
   children.add(child);
   return;
  }

  if (child.type == ATTR) {
   attributes.put(child.name, child);
   return;
  }

  if (child.type == OPEN) {
   if (type == OPEN && name.equals(child.name))
    path.push(this);
   children.add(child);
   return;
  }

  if (child.type == CLOSE)
   return;

  if (child.type == TEXT) {
   xpathContext.clearPrefixes();
   if (expression == null || expression.length() == 0)
    expression = child.expression;
   else
    expression += child.expression;
  }
 }

 public void setChildren(List<Level> levels) {
  children.clear();
  children.addAll(levels);
 }

 private void navigateToAttribute() {
  if (parentLevel == null)
   return;

  parentLevel.attributes.put(name, this);
 }

 public static class Factory {
  private final XPathContext context;

  public Factory(XPathContext context) {
   this.context = context;
  }

  public Level startTag(QName name) {
   return new Level(context"
167,"package com.google.cloud.datacatalog.v1;

import com.google.api.gax.rpc.ApiException;
import com.google.cloud.datacatalog.v1.DataCatalogClient;
import com.google.cloud.datacatalog.v1.Job;
import com.google.cloud.datacatalog.v1.JobName;
import com.google.cloud.datacatalog.v1.UpdateJobRequest;
import com.google.protobuf.FieldMask;
import java.io.IOException;

// Sample to update job
public class UpdateJob {

  public static void main(String[] args) throws ApiException, IOException {
    // TODO(developer): Replace these variables before running the sample.
    String projectId = ""MY_PROJECT_ID"";
    String location = ""MY_LOCATION"";
    String jobId = ""MY_JOB_ID"";
    // optionally provide run_id to update
    long runId = 12345L;
    updateJob(projectId, location, jobId, runId);
  }

  public static void updateJob(String projectId, String location, String jobId, long runId)
      throws ApiException, IOException {
    // Initialize client that will be used to send requests. This client only needs to be created
    // once, and can be reused for multiple requests. After completing all of your requests, call
    // the ""close"" method on the client to safely clean up any remaining background resources.
    try (DataCatalogClient dataCatalogClient = DataCatalogClient.create()) {
      // Construct the Job object.
      JobName jobName = JobName.of(projectId, location, jobId);
      Job job =
          Job.newBuilder()
              .setName(jobName.toString())
              // Set job's run_id
              .setRunId(runId)
              .build();
      // Construct the FieldMask object. FieldMask restricts the set of fields to be updated
      // in the Job object. It can be used to update individual fields without updating
      // all of them.
      FieldMask fieldMask = FieldMask.newBuilder().addPaths(""run_id"").build();
      // Construct the UpdateJobRequest object.
      UpdateJobRequest request =
          UpdateJobRequest.newBuilder().setJob(job).setUpdateMask(fieldMask).build();
      // Send the request to update the job.
      Job response = dataCatalogClient.updateJob(request);
      System.out.format(""Job updated successfully: %s\n"", response.getName());
    }
  }
}"
168,"import java.util.Objects;

public class LRItem extends ParseItem {
    public final boolean isDotAtEnd;
    public final Production production;

    public LRItem(boolean isDotAtEnd, Production production, ParsingSymbol symbolAfterDot, int objHash,
                  int dotPos, int hashCode) {
        super(symbolAfterDot, objHash, dotPos, hashCode);
        this.isDotAtEnd = isDotAtEnd;
        this.production = production;
    }

    public String toSimpleString() {
        return this.production.toSimpleString(dotPos);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof LRItem)) return false;
        LRItem lrItem = (LRItem) o;
        return isDotAtEnd == lrItem.isDotAtEnd &&
                Objects.equals(production, lrItem.production) &&
                Objects.equals(symbolAfterDot, lrItem.symbolAfterDot) &&
                objHash == lrItem.objHash &&
                dotPos == lrItem.dotPos &&
                hashCode == lrItem.hashCode;
    }

    @Override
    public int hashCode() {
        return hashCode;
    }

    @Override
    public String toString() {
        return ""LRItem{"" +
                ""isDotAtEnd="" + isDotAtEnd +
                "", production="" + production +
                "", symbolAfterDot="" + symbolAfterDot +
                "", objHash="" + objHash +
                "", dotPos="" + dotPos +
                "", hashCode="" + hashCode +
                '}';
    }
}"
169,"package com.squareup.wire.internal;

import com.google.gson.Gson;
import com.squareup.wire.CompleteFileOptions;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CompleteFileOptionsTest {

  private static CompleteFileOptions options = new CompleteFileOptions();

  // Java interop only
  @Test public void defaults() {
    assertEquals(0L, options.option1);
    assertEquals(""2"", options.option2);
    assertEquals(true, options.option3);
    assertEquals(""default"", options.option4);
    assertEquals(10.5, options.option5, .0001);
    assertEquals(new NestedOptions(500L, ""501""), options.nestedOptions);
  }

  // Java interop only
  @Test public void roundTrip() {
    String json = new Gson().toJson(options);
    assertEquals(options, new Gson().fromJson(json, CompleteFileOptions.class));
  }
}"
170,"import java.util.Map;

public class Permission {
  public static final String NOT_SHARED = ""NOT_SHARED"";
  public static final String FRIENDS = ""FRIENDS"";
  public static final String ALL = ""ALL"";
  public static final String FRIEND_FRIEND = ""FRIEND_FRIEND"";
  public static final String PUBLIC = ""PUBLIC"";
  public static final String FRIEND_PUBLIC = ""FRIEND_PUBLIC"";
  private static Map<String, Permission> PERMISSIONS = Map.of(NOT_SHARED, new Permission(""NOT_SHARED"", 0), FRIENDS, new Permission(""FRIENDS"", 1), ALL, new Permission(""ALL"", 2), FRIEND_FRIEND, new Permission(""FRIEND_FRIEND"", 3), PUBLIC, new Permission(""PUBLIC"", 4), FRIEND_PUBLIC, new Permission(""FRIEND_PUBLIC"", 5));
  public static final long serialVersionUID = 129L;
  private String m_key;
  private int m_permissionIndex;
  private int m_id;

  public Permission(String key, int id) {
    m_key = key;
    m_id = id;
    m_permissionIndex = id;
  }

  public String getKey() {
    return m_key;
  }

  public int getID() {
    return m_id;
  }

  public static Permission getInstance(String key) {
    return PERMISSIONS.get(key);
  }

  @Override
  public String toString() {
    return m_key;
  }
}"
171,"import android.content.Context;

import androidx.loader.content.AsyncTaskLoader;
import java.util.Collections;
import java.util.List;

abstract class DuplicateProvider<T> extends AsyncTaskLoader<List<T>> {

    private final DuplicateProviderListener<T, DuplicateProvider<T>> listener;

    private boolean cancelled;

    public DuplicateProvider(Context context, DuplicateProviderListener<T, DuplicateProvider<T>> listener) {
        super(context);
        this.listener = listener;
    }

    @Override
    protected void onStartLoading() {
        super.onStartLoading();
        if (listener != null) {
            listener.onPreExecute(this);
        }
        if (!cancelled) {
            forceLoad();
        }
    }

    @Override
    public void deliverResult(List<T> data) {
        if (!isCancelled()) {
            super.deliverResult(data);
        }
    }

    @Override
    protected void onStopLoading() {
        super.onStopLoading();
        cancelled = true;
    }

    @Override
    protected void onReset() {
        super.onReset();
        onStopLoading();
        if (listener != null) {
            listener.onPostExecute(this);
        }
    }

    public boolean isCancelled() {
        return cancelled;
    }

    public boolean deleteItem(T item) {
        return false;
    }

    public boolean deleteItem(long id) {
        return false;
    }

    @Override
    public List<T> loadInBackground() {
        return Collections.emptyList();
    }

    public String[] getCursorProjection() {
        return null;
    }

    public String getCursorSelection() {
        return null;
    }

    public String[] getReadPermissions() {
        return null;
    }

    public String[] getDeletePermissions() {
        return null;
    }

    public Uri getContentUri() {
        return null;
    }

    public T createItem(String[] values) {
        return null;
    }

    public void populateItem(T item, String[] values) {
    }

    public List<T> getItems() {
        return null;
    }

    public void setListener(DuplicateProviderListener<T, DuplicateProvider<T>> listener) {
    }

    public DuplicateProviderListener<T, DuplicateProvider<T>> getListener() {
        return listener;
    }

    public Context getContext() {
        return getContext();
    }

    public void deletePairs() {
    }

    public String empty() {
        return null;
    }
}"
172,
173,"import org.junit.Test;

import static org.junit.Assert.*;

public class VHWParserTest {

  private VHWParser parser;

  @Test
  public void testConstructorTalkerId() {
    parser = new VHWParser(""$IIVHW,22.3,N,125.6,E,00.0,E"");
    assertEquals(""II"", parser.getTalkerId());
  }

  @Test
  public void testConstructorString() {
    parser = new VHWParser(""$IIVHW,22.3,N,125.6,E,00.0,E"");
    assertEquals(""$IIVHW,22.3,N,125.6,E,00.0,E"", parser.getSource());
  }

  @Test
  public void testIsTrue() {
    assertTrue(parser.isTrue());
  }

  @Test
  public void setUp() throws Exception {
    parser.setUp();
    // hard to test
  }

  @Test
  public void testSetHeading() {
    parser.setHeading(85);
    assertEquals(85, parser.getHeading());
  }

  @Test
  public void testSetSpeedKilometres() {
    parser.setSpeedKilometres(22.3);
    assertEquals(22.3, parser.getSpeedKilometres(), 0);
  }

  @Test
  public void testSetSpeedKnots() {
    parser.setSpeedKnots(125.6);
    assertEquals(125.6, parser.getSpeedKnots(), 0);
  }

  @Test
  public void testGetHeading() {
    parser.setHeading(85);
    assertEquals(85, parser.getHeading());
  }

  @Test
  public void testGetMagneticHeading() {
    assertEquals(0.0, parser.getMagneticHeading(), 0);
  }

  @Test
  public void testGetSpeedKnots() {
    parser.setSpeedKnots(125.6);
    assertEquals(125.6, parser.getSpeedKnots(), 0);
  }

  @Test
  public void testGetSpeedKmH() {
    parser.setSpeedKilometres(22.3);
    assertEquals(22.3, parser.getSpeedKilometres(), 0);
  }

}"
174,"import io.netty.buffer.ByteBuf;

class RPCMessage {

    public void encode(ByteBuf buf) { throw new RuntimeException(""Not implemented""); }

    public static ByteToMessageDecoder createFrameDecoder() { throw new RuntimeException(""Not implemented""); }

    public Type getType() { throw new RuntimeException(""Not implemented""); }

    public DataBuffer getPayloadDataBuffer() { throw new RuntimeException(""Not implemented""); }

    public int getId() { throw new RuntimeException(""Not implemented""); }

    public static RPCMessage decodeMessage(final ByteBuf in) { throw new RuntimeException(""Not implemented""); }

    public boolean hasPayload() { throw new RuntimeException(""Not implemented""); }

    public Type decode(ByteBuf buf) { throw new RuntimeException(""Not implemented""); }

    public int getEncodedLength() { throw new RuntimeException(""Not implemented""); }
}"
175,"import java.util.List;

import org.apache.accumulo.core.client.BatchScanner;
import org.apache.accumulo.core.data.Key;
import org.apache.accumulo.core.data.Range;
import org.apache.accumulo.core.data.Value;
import org.apache.accumulo.core.iterators.user.IntersectingIterator;

public class ExampleBatchScanner {

  public static void main(String[] args) {
    // Create a batch scanner using a list of scans
    List<Range> ranges = List.of(new Range(), new Range());
    BatchScanner batchScanner = new BatchScanner(ranges);

    // Add an intersecting iterator to the batch scanner
    batchScanner.addScanIterator(new IntersectingIterator());

    // Iterate over the results of the batch scanner
    for (Map.Entry<Key,Value> entry : batchScanner) {
      System.out.println(entry.getKey() + "" = "" + entry.getValue());
    }
  }
}"
176,
177,"import java.util.ArrayList;
import java.util.List;

import javax.xml.namespace.QName;

import com.google.api.client.util.Key;
import com.google.api.client.util.Value;

public class HandlerChain {
  @Key(""@handlerClass"")
  public String handlerClass;

  @Key(""init-param"")
  @Value
  public List<ParamValueType> initParam = new ArrayList<ParamValueType>();

  @Key(""display-name"")
  @Value
  public List<DisplayNameType> displayName = new ArrayList<DisplayNameType>();

  @Key(""soap-role"")
  @Value
  public List<String> soapRole = new ArrayList<String>();

  @Key(""soap-header"")
  @Value
  public List<XsdQNameType> soapHeader = new ArrayList<XsdQNameType>();

  @Key(""icon"")
  @Value
  public List<IconType> icon = new ArrayList<IconType>();

  @Key(""description"")
  @Value
  public List<DescriptionType> description = new ArrayList<DescriptionType>();

  @Key(""handler-name"")
  public String handlerName;;

  @Key(""@id"")
  public String id;

  public List<XsdQNameType> getSoapHeader() {
    return soapHeader;
  }

  public List<DisplayNameType> getDisplayName() {
    return displayName;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public String getHandlerName() {
    return handlerName;
  }

  public void setHandlerName(String handlerName) {
    this.handlerName = handlerName;
  }

  public String getHandlerClass() {
    return handlerClass;
  }

  public void setHandlerClass(String handlerClass) {
    this.handlerClass = handlerClass;
  }

  public List<ParamValueType> getInitParam() {
    return initParam;
  }

  public List<DescriptionType> getDescription() {
    return description;
  }

  public List<SoapRole> getSoapRole() {
    List<SoapRole> roles = new ArrayList<SoapRole>();
    for (String r : soapRole) {
      roles.add(SoapRole.valueOf(r));
    }
    return roles;
  }

  public List<IconType> getIcon() {
    return icon;
  }

  public static class ParamValueType {

    @Key(""param-name"")
    public String paramName;

    @Key(""param-value"")
    public String paramValue;

    public ParamValueType() {
    }

    public String getParamName() {
      return paramName;
    }

    public String getParamValue() {
      return paramValue;
    }

  }

  public static class DisplayNameType {

    @Key(""lang"")
    public String lang;

    @Key(""value"")
    public String value;

    public DisplayNameType() {
    }

    public String getLang() {
      return lang;
    }

    public String getValue() {
      return value;
    }
  }

  public static class XsdQNameType extends QName {

    public XsdQNameType(String namespaceURI, String localPart) {
      super(namespaceURI, localPart);
    }

  }

  public static class IconType {

    @Key(""lang"")
    public String lang;

    @Key(""small-icon"")
    public String smallIcon;

    @Key(""large-icon"")
    public String largeIcon;

    @Key(""gif"")
    public String gif;

    public IconType() {
    }

    public String getLang() {
      return lang;
    }

    public String getSmallIcon() {
      return smallIcon;
    }

    public String getLargeIcon() {
      return largeIcon;
    }

    public String getGif() {
      return gif;
    }
  }

  public static class DescriptionType {

    @Key(""lang"")
    public String lang;

    @Key(""value"")
    public String value;

    public DescriptionType() {
    }

    public String getLang() {
      return lang;
    }

    public String getValue() {
      return value;
    }
  }

  public enum SoapRole {

    AUTHENTICATION, AUTHORIZATION;
  }
}"
178,"import java.util.HashMap;
import java.util.LinkedList;
import java.util.logging.Logger;

public class Patch_Graph_Merge {

    private HashMap<String, String> oldRevisionGraphMap;
    private Logger logger;

    public void saveGraphVorMergingInMap(String revisionInformation, String getaddSetUri,
                                          String getdeleteSetUri) {
        this.oldRevisionGraphMap = loadGraphVorMergingFromMap(revisionInformation);
        addGraphTripleSets(getaddSetUri, getdeleteSetUri);
    }

    public void addGraphTripleSets(String getaddSetUri, String getdeleteSetUri) {
        if (getaddSetUri != null) {
            LinkedList<String> createAddedOrRemovedTripleSet = createAddedOrRemovedTripleSet(getaddSetUri);
            for (String s : createAddedOrRemovedTripleSet) {
                oldRevisionGraphMap.put(s, ""added"");
            }
        }
        if (getdeleteSetUri != null) {
            LinkedList<String> createAddedOrRemovedTripleSet = createAddedOrRemovedTripleSet(getdeleteSetUri);
            for (String s : createAddedOrRemovedTripleSet) {
                oldRevisionGraphMap.put(s, ""deleted"");
            }
        }
    }

    private LinkedList<String> createAddedOrRemovedTripleSet(String uri) {
        LinkedList<String> createAddedOrRemovedTripleSet = new LinkedList<>();
        // TODO
        return createAddedOrRemovedTripleSet;
    }

    private HashMap<String, String> loadGraphVorMergingFromMap(String revisionInformation) {
        HashMap<String, String> loadGraphVorMerging = new HashMap<>();
        // TODO
        return loadGraphVorMerging;
    }
}"
179,"import java.util.Arrays;

public class ParseTable {
    private int _size;
    private int[] default_reduce;
    private int[][] reduction_count;
    private int[][] under_term;

    public void clear() {
        Arrays.fill(default_reduce, 0);
        for (int[] row : reduction_count) {
            Arrays.fill(row, 0);
        }
        for (int[] row : under_term) {
            Arrays.fill(row, 0);
        }
        _size = 0;
    }

    public void compute_default() {
        for (int i = 1; i <= _size; i++) {
            for (int j = 1; j <= under_term[i].length; j++) {
                if (under_term[i][j] > 0) {
                    if (reduction_count[i][reduction_count[i].length - 1] == 0) {
                        reduction_count[i][reduction_count[i].length - 1] = 1;
                        default_reduce[i] = j;
                    }
                }
            }
        }
    }

}"
180,"import com.google.common.collect.CopyOnWriteArrayList;
import java.util.ArrayList;
import java.util.List;

class SpringChain {
    private static final int DEFAULT_ATTACHMENT_TENSION = 1;
    private static final int DEFAULT_ATTACHMENT_FRICTION = 1;
    private static final int DEFAULT_MAIN_TENSION = 1;
    private static final int DEFAULT_MAIN_FRICTION = 1;

    private final SpringConfigRegistry registry;

    private final CopyOnWriteArrayList<Spring> mSprings;
    private final CopyOnWriteArrayList<SpringListener> mListeners;

    private final int id;
    private int mControlSpringIndex;

    private SpringConfig mAttachmentSpringConfig;
    private SpringConfig mMainSpringConfig;
    private SpringSystem mSpringSystem;

    private SpringChain(SpringSystem springSystem, int id, List<Spring> springs) {
        this.id = id;
        this.mSprings = new CopyOnWriteArrayList<>(springs);
        this.mListeners = new CopyOnWriteArrayList<>();
        this.registry = springSystem.getSpringConfigRegistry();

        mAttachmentSpringConfig = registry.getSpringConfig(DEFAULT_ATTACHMENT_TENSION, DEFAULT_ATTACHMENT_FRICTION);
        mMainSpringConfig = registry.getSpringConfig(DEFAULT_MAIN_TENSION, DEFAULT_MAIN_FRICTION);
        mControlSpringIndex = -1;

        mSpringSystem = springSystem;
        mSpringSystem.addSpringChain(this);
    }

    public SpringConfig getMainSpringConfig() {
        return mMainSpringConfig;
    }

    public List<Spring> getAllSprings() {
        return new ArrayList<>(mSprings);
    }

    public SpringChain setControlSpringIndex(int index) {
        mControlSpringIndex = index;
        return this;
    }

    void onSpringActivate(Spring spring) {
        for (SpringListener listener : mListeners) {
            listener.onSpringActivate(this, spring);
        }
    }

    void onSpringAtRest(Spring spring) {
        for (SpringListener listener : mListeners) {
            listener.onSpringAtRest(this, spring);
        }
    }

    static SpringChain create(SpringSystem springSystem, int id, List<Spring> springs) {
        return new SpringChain(springSystem, id, springs);
    }

    static SpringChain create(SpringSystem springSystem, int id, Spring... springs) {
        return new SpringChain(springSystem, id, new ArrayList<>(List.of(springs)));
    }

    void onSpringUpdate(Spring spring) {
        calculatePositions();
        for (SpringListener listener : mListeners) {
            listener.onSpringUpdate(this, spring);
        }
    }

    SpringChain addSpring(Spring spring) {
        mSprings.add(spring);
        return this;
    }

    void onSpringEndStateChange(Spring spring) {
        for (SpringListener listener : mListeners) {
            listener.onSpringEndStateChange(this, spring);
        }
    }

    SpringConfig getAttachmentSpringConfig() {
        return mAttachmentSpringConfig;
    }

    private void calculatePositions() {
        int springIndex = 0;
        Spring controlSpring = mSprings.get(mControlSpringIndex);
        for (Spring spring : mSprings) {
            if (spring != controlSpring) {
                spring.setEndValue(controlSpring.getEndValue());
            }
            springIndex++;
        }
    }
}"
181,"void readExtensions(ExtensionInfo extensionInfo, ClassFileLoader loader, ErrorQueue eq,
                      Collection<JavaFileObject> outputFiles, List<ExtensionInfo> allExtensions,
                      List<Job> jobs) {
    boolean done = runToGoal(Goal.CLASS_PATH_EXTENSIONS);
    outputFiles = maybeRunJobs(done, eq, outputFiles, jobs);

    if (done) {
        // Late allocation of ExtensionInfo objects to allow loaded class files
        // to enforce necessary constraints between them
        for (ExtensionInfo info : allExtensions) {
            info.setClassFileLoader(loader);
        }

    }
    ExtensionInfo info = extensionInfo;
    for (ExtensionInfo extension : allExtensions) {
        if (extension.getExtension().equals(info.getExtension())
                && extension != info) {
            if (loader.isEmpty()) {
                loader.addClasses(info.getExtension().getSuppliedClasses());
            }
            loader.addClasses(extension.getExtension().getSuppliedClasses());
            extension.setExtension(info);
            info.addExtension(extension);
        }
    }
    if (!done) {
        jobs.add(new CompileExtensionJob(extensionInfo, eq));
    }
}"
182,
183,"import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.auth.oauth2.CredentialRefreshListener;
import com.google.api.client.auth.oauth2.TokenResponse;
import java.util.Collection;
import java.util.Date;
import java.util.List;

/* Class generated by 'go generate'. DO NOT EDIT. */

/**
 * A OAuth2 credential representing user authorization.
 *
 * @since 1.22
 */
public class OAuth2UserCredential extends Credential {

  /**
   * The subject that created the object. Usually an OAuth 2.0 user subject.
   */
  private final UserSubject subject;

  /**
   * The scopes related to the create methods.
   */
  private final Collection<OAuthPermission> scopes;

  /**
   * Lifetime (> 0) of the credential in seconds since issued, unless epoch time was defined in
   * {@link #issuedAt}.
   */
  private final Long lifetime;

  /**
   * Instant at which the token was issued. Usually used in combination with {@link #lifetime}.
   */
  private final Long issuedAt;

  /**
   * Whether the credential has been revoked.
   *
   * <p>Subsequent accessors that depend on the credential having been revoked should only be used
   * after calling {@link #revoke()} and checking this value.
   *
   * <p>It is recommended that the OAuth 2.0 server be used to check the revocation status.
   *
   * @since 1.15
   */
  private boolean revoked;

  /**
   * @param subject the subject that created the object. Usually an OAuth 2.0 user subject.
   * @param scopes the scopes related to the create methods
   * @param lifetime lifetime (> 0) of the credential in seconds since issued, unless epoch time was
   *     defined in {@link #issuedAt}.
   * @param issuedAt instant at which the token was issued. Usually used in combination with {@link
   *     #lifetime}.
   */
  public OAuth2UserCredential(
      UserSubject subject,
      Collection<OAuthPermission> scopes,
      Long lifetime,
      Long issuedAt) {
    super();
    this.subject = subject;
    this.scopes = scopes;
    this.lifetime = lifetime;
    this.issuedAt = issuedAt;
  }

  public final UserSubject getSubject() {
    return subject;
  }

  public final Collection<OAuthPermission> getScopes() {
    return scopes;
  }

  public final Long getLifetime() {
    return lifetime;
  }

  public final Long getIssuedAt() {
    return issuedAt;
  }

  @Override
  public final boolean isExpired() {
    if (revoked) {
      return true;
    }
    if (lifetime == null || issuedAt == null) {
      return false;
    }
    return issuedAt + lifetime * 1000 < (new Date()).getTime();
  }

  // Override toString to suppress client_secret from logging.

  @Override
  public String toString() {
    return getSubject() + "" ("" + getScopes() + "")"";
  }

  // Override methods that require creating child credentials with new OAuth2 credentials.

  @Override
  public OAuth2UserCredential createScoped(List<String> scopes) {
    return new OAuth2UserCredential(subject, scopes, lifetime, issuedAt);
  }

  @Override
  public OAuth2UserCredential createScopedRequired() {
    return createScoped(getScopes());
  }

  @Override
  public Builder toBuilder() {
    return new Builder(this);
  }

  public static class Builder extends Credential.Builder {

    private UserSubject subject;
    private Collection<OAuthPermission> scopes;
    private Long lifetime;
    private Long issuedAt;
    private boolean revoked;

    public Builder() {
      super();
    }

    protected Builder(OAuth2UserCredential credential) {
      super(credential);
      this.subject = credential.subject;
      this.scopes = credential.scopes;
      this.lifetime = credential.lifetime;
      this.issuedAt = credential.issuedAt;
      this.revoked = credential.revoked;
    }

    public UserSubject getSubject() {
      return subject;
    }

    public Builder setSubject(UserSubject subject) {
      this.subject = subject;
      return this;
    }

    public Collection<OAuthPermission> getScopes() {
      return scopes;
    }

    public Builder setScopes(Collection<OAuthPermission> scopes) {
      this.scopes = scopes;
      return this;
    }

    public Long getLifetime() {
      return lifetime;
    }

    public Builder setLifetime(Long lifetime) {
      this.lifetime = lifetime;
      return this;
    }

    public Long getIssuedAt() {
      return issuedAt;
    }

    public Builder setIssuedAt(Long issuedAt) {
      this.issuedAt = issuedAt;
      return this;
    }

    public boolean isRevoked() {
      return revoked;
    }

    public Builder setRevoked(Boolean revoked) {
      this.revoked = revoked;
      return this;
    }

    @Override
    public OAuth2UserCredential build() {
      return new OAuth2UserCredential(subject, scopes, lifetime, issuedAt);
    }

    @Override
    public Builder setAccessToken(String accessToken) {
      return (Builder) super.setAccessToken(accessToken);
    }

    @Override
    public Builder setRefreshToken(String refreshToken) {
      return (Builder) super.setRefreshToken(refreshToken);
    }

    @Override
    public Builder setExpirationTimeMilliseconds(Long expirationTimeMilliseconds) {
      return (Builder) super.setExpirationTimeMilliseconds(expirationTimeMilliseconds);
    }

    @Override
    public Builder addRefreshListener(CredentialRefreshListener refreshListener) {
      return (Builder) super.addRefreshListener(refreshListener);
    }

    @Override
    public Builder setTokenResponse(TokenResponse tokenResponse) {
      return (Builder) super.setTokenResponse(tokenResponse);
    }
  }
}"
184,"import java.util.List;

public class IngredientService {

    private final Logger log;
    private final IngredientRepository ingredientRepository;

    public IngredientService(Logger log, IngredientRepository ingredientRepository) {
        this.log = log;
        this.ingredientRepository = ingredientRepository;
    }

    public List<String> getAutoSuggest(String maxSuggest) {
        return ingredientRepository.getAutoSuggest(maxSuggest);
    }

    public Ingredient save(Ingredient ingredient) {
        return ingredientRepository.save(ingredient);
    }

    public List<Ingredient> save(List<Ingredient> ingredients) {
        return ingredientRepository.saveAll(ingredients);
    }

    public Ingredient findOne(Long id) {
        return ingredientRepository.findById(id).orElse(null);
    }

    public void delete(Long id) {
        ingredientRepository.deleteById(id);
    }
}"
185,"public String getPartString(String[] dataLine, int column) {
  if (column >= 0 && column < dataLine.length) {
    return dataLine[column].trim();
  }
  return "";
}"
186,"import org.apache.activemq.artemis.api.core.ActiveMQException;
import org.apache.activemq.artemis.api.core.client.ClientConsumer;
import org.apache.activemq.artemis.api.core.client.ClientMessage;
import org.apache.activemq.artemis.api.core.client.ClientProducer;
import org.apache.activemq.artemis.api.core.client.ClientSession;
import org.apache.activemq.artemis.api.core.client.ServerLocator;
import org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryImpl;
import org.apache.activemq.artemis.core.client.impl.ClientSessionImpl;
import org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl;

public class ConsumerReceiveTimeout {

   public static void main(String[] args) {
      String hostname = ""localhost"";
      int port = 5445;
      String queueName = ""exampleQueue"";
      long timeout = 10000;

      try {
         ServerLocator serverLocator = org.apache.activemq.artemis.core.client.impl.ServerLocatorImpl.createFactory(hostname, port);
         ClientSessionFactoryImpl sessionFactory = new ClientSessionFactoryImpl(serverLocator);
         ClientSession session = sessionFactory.createSession();
         ClientProducer producer = session.createProducer(queueName);
         ClientConsumer consumer = session.createConsumer(queueName);

         // Set the receive timeout to 10 seconds
         consumer.resetTimeout();
         consumer.setTimeoutEnabled(true);
         consumer.setTimeoutMillis(timeout);

         // Reset the timeout
         consumer.resetTimeout();

         // Send a message
         ClientMessage message = session.createMessage(false);
         message.getBodyBuffer().writeString(""Hello, World!"");
         producer.send(message);

         // Receive the message
         ClientMessage receivedMessage = consumer.receive();
         System.out.println(""Received message: "" + receivedMessage.getBodyBuffer().readString());

         // Close the session
         session.close();
      } catch (ActiveMQException e) {
         e.printStackTrace();
      }
   }
}"
187,"import com.box.sdk.BoxAPIConnection;
import com.box.sdk.BoxFolder;
import com.box.sdk.BoxItem.Info;
import com.box.sdk.BoxUser;
import com.box.sdk.EventListener;
import com.box.sdk.RealBoxClient;
import com.box.sdk.RealBoxFolder;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.List;

public final class ListFolderStructure {
    private static String getLoginMessage(String developerToken) {
        return String.format(""Logging in using developer token %s"", developerToken);
    }

    private static BoxFolder getRootFolder(BoxUser user, String devToken) {
        return BoxFolder.getRootFolder(user, devToken);
    }

    private static String getMissingFolderMessage(String folderName) {
        return String.format(""Folder '%s' not found"", folderName);
    }

    private static BoxFolder getCurrentFolder(BoxFolder rootFolder, String path) {
        BoxFolder currentFolder = rootFolder;
        if (path.length() != 0) {
            String[] splitPath = path.split(""/"");
            for (String folderName : splitPath) {
                currentFolder = currentFolder.getSubfolder(folderName);
                if (currentFolder == null) {
                    return null;
                }
            }
        }
        return currentFolder;
    }

    private static void goToFolder(TextBot tb, BoxFolder currentFolder, String folderName) {
        String currentPath = currentFolder.getInfo().getPathCollection().toString();
        BoxFolder nextFolder = currentFolder.getSubfolder(folderName);
        if (nextFolder == null) {
            tb.reply(getMissingFolderMessage(folderName));
        } else {
            currentFolder = nextFolder;
            tb.reply(String.format(""Switched to folder /%s"", currentPath + ""/"" + folderName));
        }
    }

    private static void uploadFile(TextBot tb, BoxFolder currentFolder, InputStream stream, String fileName) {
        ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();
        try {
            int nRead;
            byte[] data = new byte[16384];
            while ((nRead = stream.read(data, 0, data.length)) != -1) {
                byteOutputStream.write(data, 0, nRead);
            }
            byteOutputStream.flush();
        } catch (IOException e) {
            // Handle exception.
        }
        BoxFolder.Info info = currentFolder.createFile(fileName, byteOutputStream);
        tb.reply(String.format(""Uploaded file '%s' to folder /%s"", fileName, currentFolder.getInfo().getPathCollection().toString()));
    }

    private static void downloadFromCurrent(TextBot tb, BoxFolder currentFolder) {
        List<Info> items = currentFolder.getChildren();
        for (Info item : items) {
            if (item instanceof BoxFolder.Info) {
                tb.reply(String.format(""Found folder '%s'"", item.getName()));
            } else {
                tb.reply(String.format(""Found file '%s'"", item.getName()));
            }
        }
    }

    private static void createNewFolder(TextBot tb, BoxFolder currentFolder, String folderName) {
        BoxFolder newFolder = currentFolder.createFolder(folderName);
        tb.reply(String.format(""Created folder '%s' in /%s"", newFolder.getInfo().getName(), currentFolder.getInfo().getPathCollection()));
    }

    private static void deleteFolder(TextBot tb, BoxFolder currentFolder, String folderName) {
        BoxFolder folderToDelete = currentFolder.getSubfolder(folderName);
        if (folderToDelete != null) {
            folderToDelete.delete(false);
            tb.reply(String.format(""Deleted folder /%s"", folderToDelete.getInfo().getPathCollection().toString()));
        } else {
            tb.reply(getMissingFolderMessage(folderName));
        }
    }

    private static void uploadFolder(TextBot tb, BoxFolder currentFolder, String folderName) {
        File file = new File(folderName);
        if (file.exists() && file.isDirectory()) {
            BoxFolder newFolder = currentFolder.createFolder(file.getName()).newFolder();
            int fileCount = 0, folderCount = 0;
            for (File entry : file.listFiles()) {
                if (entry.isDirectory()) {
                    uploadFolder(tb, newFolder, entry.getName());
                    folderCount++;
                } else {
                    uploadFile(tb, newFolder, file, entry.getName());
                    fileCount++;
                }
            }
            tb.reply(String.format(""Uploaded %d files and %d folders to /%s"", fileCount, folderCount, newFolder.getInfo().getPathCollection()));
        } else {
            tb.reply(String.format(""Folder '%s' not found"", folderName));
        }
    }

    private static void listFolders(TextBot tb, BoxFolder currentFolder, String indent) {
        List<Info> subFolders = currentFolder.getChildren();
        for (Info subFolder : subFolders) {
            tb.reply(indent + subFolder.getName());
            if (subFolder instanceof BoxFolder.Info) {
                listFolders(tb, (BoxFolder) subFolder, indent + ""  "");
            }
        }
    }

    private static void notify(TextBot tb, String message, Map<String, Object> metadata) {
        tb.reply(String.format(""%s: %s"", message, metadata.get(""event"")));
    }

    private static List<String> getCurrentFiles(BoxFolder currentFolder) {
        return currentFolder.getChildren();
    }

    private static void uploadFileToFolder(TextBot tb, BoxFolder currentFolder, InputStream stream, String fileName) {
        ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();
        try {
            int nRead;
            byte[] data = new byte[16384];
            while ((nRead = stream.read(data, 0, data.length)) != -1) {
                byteOutputStream.write(data, 0, nRead);
            }
            byteOutputStream.flush();
        } catch (IOException e) {
            // Handle exception.
        }
        BoxFolder.Info info = currentFolder.createFile(fileName, byteOutputStream);
        tb.reply(String.format(""Uploaded file '%s' to folder /%s"", fileName, currentFolder.getInfo().getPathCollection().toString()));
    }

    private static BoxFolder getFolder(BoxFolder currentFolder, String folderName) {
        return currentFolder.getSubfolder(folderName);
    }

    private static BoxFolder getFolder(BoxFolder rootFolder, String path) {
        BoxFolder currentFolder = rootFolder;
        if (path.length() != 0) {
            String[] splitPath = path.split(""/"");
            for (String folderName : splitPath) {
                currentFolder = currentFolder.getSubfolder(folderName);
                if (currentFolder == null) {
                    return null;
                }
            }
        }
        return currentFolder;
    }

    private static void setUpNotifications(BoxUser user) {
        setNotifications(user, ""/"");
    }

    private static void setNotifications(BoxUser user, String folderPath) {
        BoxFolder folder = user.getFolder(folderPath);
        Map<String, Object> metadata = new HashMap<>();
        metadata.put(""test"", ""value"");
        folder.assignNotifications(metadata, new EventListener() {
            @Override
            public void onEvent(Map<String, Object> metadata, Info item) {
                notify(TextBot.getBot(), item.getName(), metadata);
            }
        });

        List<Info> subFolders = folder.getChildren();
        for (Info subFolder : subFolders) {
            if (subFolder instanceof BoxFolder.Info) {
                setNotifications(user, ((BoxFolder.Info) subFolder).getId());
            }
        }
    }

    private static void goToRootFolder(BoxFolder currentFolder) {
        if (!currentFolder.getInfo().getPathCollection().toString().equals(""/"")) {
            currentFolder = currentFolder.getInfo().getRootFolder();
        }
    }

    public static void main(String[] args) {
        String developerToken = "";
        String folderName = "";
        String fileName = "";
        String prompt = ""> "";

        // Create a new Box client and user from the provided developer token
        BoxAPIConnection client = new BoxAPIConnection(developerToken);
        BoxUser user = new BoxUser(client);
        TextBot tb ="
188,"@Override
public void writeBytes(ByteBuffer dbuf, boolean vCloseRequested) {
  if (dbuf == null) {
    return;
  }
  try {
    int toWrite = Math.min(BUFFER_SIZE_UPPER_BOUND, dbuf.remaining());
    int written = socket.getOutputStream().write(dbuf.array(), dbuf.arrayOffset(), toWrite);
    dbuf.position(dbuf.position() + written);

    log.debug(""written: {}, {}"", written, dbuf.remaining());
    if (vCloseRequested && dbuf.remaining() == 0) {
      log.debug(""Closing connection"");
      socket.getOutputStream().close();
      connectionClosed();
    } else if (dbuf.remaining() < BUFFER_SIZE_LOWER_BOUND && written > 0) {
      writeBytes(dbuf, vCloseRequested);
    }
  } catch (Exception e) {
    connectionClosed();
  }
}"
189,
190,
191,"import org.junit.Assert;
import java.util.Map;

public class AssertNotEmptyMap {

    public static void isTrue(Map<?, ?> actual) {
        Assert.assertTrue(actual != null && !actual.isEmpty());
    }

    public static void isAssignable() {
        isTrue(new java.util.HashMap<>());
    }

    public static void notNull() {
        isTrue(new java.util.HashMap<>());
    }

    public static void isNull() {
        Assert.assertFalse(null != null && !null.isEmpty());
    }

    public static void noNullElements() {
        isTrue(new java.util.HashMap<>());
    }

    public static void isInstanceOf() {
        isTrue(new java.util.HashMap<>());
    }

    public static void state() {
        Assert.assertTrue(new java.util.HashMap<>() != null);
    }

}"
192,"import com.google.api.client.http.HttpHeaders;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.mockito.Mockito;

import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(JUnit4.class)
public class NotificationControllerTest {

  private static final String MOCK_SESSION_ID = ""uuid"";
  private static final String USER_ID = ""user-123"";
  private static final String NOTIFICATION_ID = ""notification-246"";
  private static final String TITLE = ""notification title"";

  private NotificationController notificationController;
  private ServerMessage mockServerMessage;
  private ServerSession mockServerSession;
  private Map<String, Object> testEventProperties;

  @Before
  public void setUp() {
    mockServerSession = mock(ServerSession.class);
    mockServerMessage = mock(ServerMessage.class);
    notificationController = new NotificationController();
    testEventProperties = new HashMap<>();
    when(mockServerSession.getAppId()).thenReturn(""demo"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullUser() {
    testEventProperties.put(""title"", TITLE);
    try {
      notificationController.handleEvent(null, mockServerMessage);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null user"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyUser() {
    testEventProperties.put(""title"", TITLE);
    try {
      notificationController.handleEvent("", mockServerMessage);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for empty user"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullTitle() {
    testEventProperties.put(""user"", USER_ID);
    try {
      notificationController.handleEvent(USER_ID, null);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null title"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyTitle() {
    testEventProperties.put(""user"", USER_ID);
    try {
      notificationController.handleEvent(USER_ID, "");
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for empty title"");
  }

  @Test
  public void testRegisterUserSession() {
    Gson gson = new Gson();
    Map<String, String> userSessionData = new HashMap<>();
    notificationController.registerUserSession(userSessionData, mockServerSession, MOCK_SESSION_ID);
    verify(mockServerSession).setData(gson.toJson(userSessionData));
    verify(mockServerSession).setUser(USER_ID);
  }

  @Test
  public void testRegisterUserSessionWithNullServerSessionIdThrowsException() {
    Map<String, String> userSessionData = new HashMap<>();
    try {
      notificationController.registerUserSession(userSessionData, mockServerSession, null);
    } catch (IllegalArgumentException e) {
      verify(mockServerSession, Mockito.never()).setData(userSessionData);
      verify(mockServerSession, Mockito.never()).setUser(USER_ID);
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null server session id"");
  }

  @Test
  public void testDeregisterUserSessionWithNullServerSessonThrowsException() {
    try {
      notificationController.deregisterUserSession(null);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null server session"");
  }

  @Test
  public void testDeregisterUserSessionWithNullServerSessionIdThrowsException() {
    try {
      notificationController.deregisterUserSession("");
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for empty server session id"");
  }

  @Test
  public void testDeregisterUserSessionRemovesUserFromKnownClients() {
    notificationController.deregisterUserSession(MOCK_SESSION_ID);
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullApplication() {
    testEventProperties.put(""user"", USER_ID);
    testEventProperties.put(""title"", TITLE);
    try {
      notificationController.handleEvent(USER_ID, null);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null application"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyApplication() {
    testEventProperties.put(""user"", USER_ID);
    testEventProperties.put(""title"", TITLE);
    try {
      notificationController.handleEvent(USER_ID, "");
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for empty application"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullTimestamp() {
    testEventProperties.put(""user"", USER_ID);
    testEventProperties.put(""title"", TITLE);
    testEventProperties.put(""application"", ""demo"");
    try {
      notificationController.handleEvent(USER_ID, ""demo"", null, null);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null timestamp"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullMessage() {
    testEventProperties.put(""user"", USER_ID);
    testEventProperties.put(""title"", TITLE);
    testEventProperties.put(""application"", ""demo"");
    testEventProperties.put(""timestamp"", System.currentTimeMillis());
    try {
      notificationController.handleEvent(USER_ID, ""demo"", System.currentTimeMillis(), null);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null message"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyMessage() {
    testEventProperties.put(""user"", USER_ID);
    testEventProperties.put(""title"", TITLE);
    testEventProperties.put(""application"", ""demo"");
    testEventProperties.put(""timestamp"", System.currentTimeMillis());
    try {
      notificationController.handleEvent(USER_ID, ""demo"", System.currentTimeMillis(), "");
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for empty message"");
  }

  @Test
  public void testGetServerSessionByUserId() {
    notificationController.registerUserSession(new HashMap<>(), mockServerSession, MOCK_SESSION_ID);
    notificationController.getServerSessionByUserId(USER_ID);
    verify(mockServerSession).getAppId();
  }

  @Test
  public void testDeletePersistentNotificationThrowsIllegalArgumentOnNullUserId() {
    try {
      notificationController.deletePersistentNotification(null, NOTIFICATION_ID);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null user id"");
  }

  @Test
  public void testDeletePersistentNotificationThrowsIllegalArgumentOnNullServerSession() {
    try {
      notificationController.deletePersistentNotification(USER_ID, null);
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for null server session"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyUser() {
    try {
      HttpHeaders httpHeaders = new HttpHeaders();
      httpHeaders.set(""x-appengine-current-user"", "");
      notificationController.handleEvent(httpHeaders, new Gson().toJson(testEventProperties));
    } catch (IllegalArgumentException e) {
      return;
    }
    throw new AssertionError(""IllegalArgumentException should have been thrown for empty user"");
  }

  @Test
  public void testHandleEventThrowsIllegalArgumentExceptionOnNullApplication() {
    testEventProperties.put(""user"", ""user-1"");
    testEventProperties.put(""title"", ""title"");
    HttpHeaders httpHeaders"
193,"import javax.swing.JPanel;
import java.util.ArrayList;
import java.util.List;

public class Wizard {

    private final List<JPanel> panels;
    private int step;
    private boolean started;
    private boolean finished;
    private WizardItem item;

    public Wizard(List<JPanel> panels, WizardItem item) {
        this.panels = panels;
        this.item = item;
    }

    public void next() {
        if (canGoNext()) {
            getCurrentPanel().setVisible(false);
            step++;
            getCurrentPanel().setVisible(true);
        }
    }

    public void back() {
        if (canGoBack()) {
            getCurrentPanel().setVisible(false);
            step--;
            getCurrentPanel().setVisible(true);
        }
    }

    public void finish() {
        if (canFinish()) {
            finished = true;
        }
    }

    public JPanel getPanel() {
        return getCurrentPanel();
    }

    public void doAction() {
        item.doAction(getCurrentPanel());
    }

    public void undo() {
        item.undo(getCurrentPanel());
    }

    public int getStep() {
        return step;
    }

    public int getNumSteps() {
        return panels.size();
    }

    public boolean isStarted() {
        return started;
    }

    public void setToDoItem(WizardItem item) {
        this.item = item;
    }

    public boolean isFinished() {
        return finished;
    }

    public int getProgress() {
        return (int) ((double) step / panels.size() * 100);
    }

    public WizardItem getToDoItem() {
        return item;
    }

    public boolean canGoNext() {
        return step < panels.size() - 1;
    }

    public boolean canGoBack() {
        return step > 0;
    }

    public boolean canFinish() {
        return !finished && canGoNext();
    }

    public JPanel makePanel(WizardItem item) {
        JPanel panel = item.makePanel();
        panel.setVisible(false);
        return panel;
    }

    public JPanel getCurrentPanel() {
        return panels.get(step);
    }

    public void removePanel(JPanel panel) {
        panels.remove(panel);
    }

    public static void main(String[] args) {
        List<JPanel> panels = new ArrayList<>();
        panels.add(new JPanel());
        panels.add(new JPanel());
        panels.add(new JPanel());

        Wizard wizard = new Wizard(panels, new WizardItem() {
            @Override
            public void doAction(JPanel panel) {
                // Do something
            }

            @Override
            public void undo(JPanel panel) {
                // Undo the action
            }

            @Override
            public JPanel makePanel() {
                return new JPanel();
            }
        });

        wizard.next();
        wizard.doAction();
        wizard.undo();
        wizard.back();
        wizard.finish();
    }
}"
194,"public int compareTo(Tag tag) {
        if (key == tag.key) {
            return value.compareTo(tag.value);
        } else {
            return key.compareTo(tag.key);
        }
    }"
195,"/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.support.v7.widget;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;

/**
 * A layout that arranges its children in a single row or column and distributes any additional
 * space among the children.
 */
public class LinearLayoutCompat extends ViewGroup {

    public static final int HORIZONTAL = 0;
    public static final int VERTICAL = 1;

    public static final int SHOW_DIVIDER_NONE = 0;
    public static final int SHOW_DIVIDER_BEGINNING = 1;
    public static final int SHOW_DIVIDER_END = 2;
    public static final int SHOW_DIVIDER_MIDDLE = 4;

    private int mOrientation;
    private int mGravity;
    private int mTotalLength;
    private int mDividerWidth;
    private int mDividerHeight;
    private boolean mUseLargestChild;
    private boolean mBaselineAligned;
    private boolean mBaselineAlignedChildIndex = -1;
    private float[] mSpacing;
    private float[] mDefaultSpacing;
    private int[] sFlagsMap = new int[4];

    private static final int START = 0x1;
    private static final int END = 0x7F << 1;
    private static final int TOP = 0x3;
    private static final int BOTTOM = 0x5;
    private static final int LEFT = 0x7;
    private static final int RIGHT = 0x1F;
    private static final int ALL = 0x3F;

    private static final int HORIZONTAL_MASK = LEFT | TOP | RIGHT | BOTTOM;
    private static final int VERTICAL_MASK = START | END | TOP | BOTTOM;

    private final Rect mTempRect = new Rect();

    public LinearLayoutCompat(Context context) {
        this(context, null);
    }

    public LinearLayoutCompat(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public LinearLayoutCompat(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);

        final TypedArray a = context.obtainStyledAttributes(attrs,
                R.styleable.LinearLayoutCompat, defStyleAttr, 0);

        int index = a.getInt(R.styleable.LinearLayoutCompat_android_orientation, -1);
        if (index >= 0) {
            setOrientation(index);
        }

        int gravity = a.getInt(R.styleable.LinearLayoutCompat_android_gravity, -1);
        if (gravity >= 0) {
            setGravity(gravity);
        }

        boolean baselineAligned = a.getBoolean(
                R.styleable.LinearLayoutCompat_android_baselineAligned, true);
        if (!baselineAligned) {
            setBaselineAligned(baselineAligned);
        }

        mUseLargestChild = a.getBoolean(R.styleable.LinearLayoutCompat_android_baselineAlignedChildIndex,
                true);

        if (a.hasValue(R.styleable.LinearLayoutCompat_divider, true)) {
            setDividerDrawable(a.getDrawable(
                    R.styleable.LinearLayoutCompat_divider));
        }

        mDividerWidth = a.getDimensionPixelSize(
                R.styleable.LinearLayoutCompat_dividerWidth, 0);

        mDividerHeight = a.getDimensionPixelSize(
                R.styleable.LinearLayoutCompat_dividerHeight, 0);

        final float dimension = a.getDimension(
                R.styleable.LinearLayoutCompat_measureWithLargestChild, -1.0f);
        if (dimension >= 0) {
            setMeasureWithLargestChildEnabled(dimension != 0);
        }

        int index2 = a.getInt(R.styleable.LinearLayoutCompat_showDividers, 0);
        setShowDividers(index2);

        a.recycle();
    }

    /**
     * Set the orientation of this layout. Must be either {@link #HORIZONTAL} or
     * {@link #VERTICAL}.
     *
     * @param orientation the new orientation value
     */
    public void setOrientation(int orientation) {
        if (mOrientation != orientation) {
            mOrientation = orientation;
            requestLayout();
        }
    }

    /**
     * Return the orientation of this layout.
     *
     * @return either {@link #HORIZONTAL} or {@link #VERTICAL}
     */
    public int getOrientation() {
        return mOrientation;
    }

    /**
     * Set the gravity of this layout. The gravity will be applied to the entire layout.
     *
     * @param gravity the new gravity value
     */
    public void setGravity(int gravity) {
        if (mGravity != gravity) {
            if ((gravity & HORIZONTAL_MASK) == 0) {
                gravity |= START;
            }

            if ((gravity & VERTICAL_MASK) == 0) {
                gravity |= TOP;
            }

            mGravity = gravity;
            requestLayout();
        }
    }

    /**
     * Return the gravity of this layout.
     *
     * @return the gravity value
     */
    public int getGravity() {
        return mGravity;
    }

    /**
     * <p>When set to true, all children with a weight will be considered having
     * the minimum size of the largest child. If false, all children are
     * measured normally.</p>
     *
     * <p>By default this is true after construction.</p>
     *
     * @param enabled True if all weights will be computed based on the largest child.
     */
    public void setMeasureWithLargestChildEnabled(boolean enabled) {
        mUseLargestChild = enabled;
    }

    /**
     * Return whether all weights will be computed based on the largest child.
     *
     * @return true if weights will be computed based on the largest child.
     */
    public boolean isMeasureWithLargestChildEnabled() {
        return mUseLargestChild;
    }

    /**
     * Set if this layout should be base aligned. When true, all children with a
     * weight will be considered having the minimum size of the largest child. If
     * false, all children are measured normally.
     *
     * @param aligned True if this layout should be base aligned.
     */
    public void setBaselineAligned(boolean aligned) {
        mBaselineAligned = aligned;
    }

    /**
     * Return whether this layout is baseline aligned. When true, all children with a
     * weight will be considered having the minimum size of the largest child. If
     * false, all children are measured normally.
     *
     * @return true if this layout is baseline aligned.
     */
    public boolean isBaselineAligned() {
        return mBaselineAligned;
    }

    /**
     * When true, indicates that the children of this layout will be baseline aligned.
     *
     * @param childIndex The index of the child whose baseline will be aligned.
     * @see #setBaselineAligned(boolean)
     * @see #isBaselineAligned()
     */
    public void setBaselineAlignedChildIndex(int childIndex) {
        if (childIndex < 0 || childIndex >= getChildCount()) {
            throw new IllegalArgumentException(""invalid child index: "" + childIndex);
        }
        mBaselineAlignedChildIndex = childIndex;
    }

    /**
     * Get the child index that will be baseline aligned.
     *
     * @return The index of the child whose baseline will be aligned, or -1 if no
     * child is aligned.
     * @see #setBaselineAlignedChildIndex(int)
     * @see #setBaselineAligned(boolean)
     * @see #isBaselineAligned()
     */
    public int getBaselineAlignedChildIndex() {
        return mBaselineAlignedChildIndex;
    }

    /**
     * <p>Sets the drawable used to draw a divider between views. The
     * default value is a horizontal line drawn on the bottom edge of
     * each view.  The drawable should have its top and bottom edges set
     * to 0 and its intrinsic height set to the desired divider width.</p>
     *
     * @param divider Drawable to draw between views
     * @see"
196,"import com.google.common.base.Splitter;
import com.google.common.collect.*;
import com.google.common.reflect.ClassPath;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.*;

/**
 * Scans one or more base packages (e.g. ""com.google.common."") for all resources with a given extension
 * (e.g. "".properties"").
 */
public class ClasspathScanner {
  private static final String ALL_CLASS_FILES = ""**/*.class"";
  private static final String CLASSPATH_URL_SCHEME = ""classpath:"";
  private static final String ALL_FILES = ""**"";
  private static final String WILDCARD = ""*"";
  private static final Splitter PACKAGE_SPLITTER = Splitter.on('.').omitEmptyStrings();

  /**
   * Packages to skip when scanning the classpath.
   */
  private static final Set<String> PACKAGES_TO_SKIP =
      ImmutableSet.of(""java"", ""javax"", ""junit"", ""sun"", ""com.google.common.reflect"");

  private final ClasspathScanner getClasspathScanner() {
    return this;
  }

  /**
   * Scans the classpath for all resources with the given extension e.g. "".properties"".
   *
   * @param basePackages One or more (comma separated) base packages to scan e.g. ""com.google.common"".
   * @param extension e.g. "".properties""
   * @return Map from base package to list of resource paths e.g. ""my.package -> resource1.properties""
   */
  public Map<String, List<String>> findResources(String basePackages, String extension) {
    Map<String, List<String>> result = Maps.newHashMap();
    for (String basePackage : basePackages.split("","")) {
      result.put(basePackage, findResourcesInternal(basePackage, extension));
    }
    return ImmutableMap.copyOf(result);
  }

  private List<String> findResourcesInternal(String basePackage, String extension) {
    List<String> result = Lists.newArrayList();
    try {
      for (ClassPath.ResourceInfo resource :
          getClasspathScanner()
              .parsePackages(basePackage)
              .getResources(ImmutableSet.of(extension))) {
        result.add(resource.getResourceName());
      }
    } catch (IOException e) {
      throw new RuntimeException(""IOException while scanning for resources"", e);
    }
    return Lists.newArrayList(result);
  }

  /**
   * Scans the classpath for all classes with the given annotations.
   *
   * @param basePackages One or more (comma separated) base packages to scan e.g. ""com.google.common"".
   * @param annotations the annotations to scan for.
   * @return Map from base package to set of classes with the given annotations e.g.
   *     ""my.package -> {class1.class, class2.class}""
   */
  public Map<Class<? extends Annotation>, Collection<Class<?>>> findClasses(
      String basePackages, Class<? extends Annotation>... annotations) {
    Map<Class<? extends Annotation>, Collection<Class<?>>> result = Maps.newHashMap();
    for (String basePackage : parsePackages(basePackages)) {
      result.putAll(findClassesInternal(basePackage, annotations));
    }
    return ImmutableMap.copyOf(result);
  }

  private Map<Class<? extends Annotation>, Collection<Class<?>>> findClassesInternal(
      String basePackage, Class<? extends Annotation>... annotations) {
    Map<Class<? extends Annotation>, Collection<Class<?>>> result = Maps.newHashMap();
    SettableMap<Class<? extends Annotation>, Class<?>> allClasses =
        TreeBasedTable.create().rowMap();
    findClasses(basePackage, allClasses);
    for (Class<? extends Annotation> annotation : annotations) {
      result.put(annotation, allClasses.get(annotation));
    }
    return ImmutableMap.copyOf(result);
  }

  private void findClasses(String basePackage, Map<Class<? extends Annotation>, Class<?>> allClasses) {
    try {
      for (ClassPath.ClassInfo classInfo :
          getClasspathScanner().parsePackages(basePackage).getAllClasses()) {
        Class<?> clazz = classInfo.load();
        for (Class<? extends Annotation> annotation : clazz.getAnnotations()) {
          Collection<Class<?>> classes =
              allClasses.get(annotation) == null
                  ? Lists.<Class<?>>newArrayList()
                  : newArrayList(allClasses.get(annotation));
          classes.add(clazz);
          allClasses.put(annotation, classes);
        }
      }
    } catch (IOException e) {
      throw new RuntimeException(""IOException while scanning for classes"", e);
    }
  }

  /**
   * Parses package names into a set of package prefixes.
   *
   * <p>For example, the package ""com.google.common"" would be parsed as the set
   * {"", ""com"", ""com.google"", ""com.google.common""}.
   *
   * @param packages String containing comma-separated package names.
   */
  private Set<String> parsePackages(String packages) {
    Set<String> result = Sets.newHashSet();
    for (String pkg : Splitter.on(',').split(packages)) {
      List<String> packageParts = PACKAGE_SPLITTER.splitToList(pkg);
      if (PACKAGES_TO_SKIP.contains(pkg)) {
        continue;
      }
      result.addAll(ImmutableSet.copyOf(packageParts));
    }
    result.add("");
    return result;
  }

  private static class AllClassFilesUrlFinder {
    // Because the URLClassLoader can efficiently find resources located in JAR files, we delegate the
    // task of scanning the classpath for class files to it.

    private List<URL> findClassFiles(List<URL> urls, List<String> basePackages) {
      List<URL> result = Lists.newArrayList();
      URLClassLoader urlClassloader = URLClassLoader.newInstance(urls.toArray(new URL[] {}));
      try {
        for (String basePackage : basePackages) {
          String classPathString = (basePackage.isEmpty() ? "" : basePackage.replace('.', '/')) + ALL_CLASS_FILES;
          Enumeration<URL> classFiles =
              urlClassloader.findResources(classPathString, true);
          result.addAll(Lists.newArrayList(classFiles));
        }
      } catch (IOException e) {
        throw new RuntimeException(""IOException while scanning for class files"", e);
      }
      return result;
    }
  }
}"
197,"public void navigateToAttribute() {
        path.push(currentLevel);
        currentLevel = children.get(0);
        children = currentLevel.children;
        type = Level.AttrLevel;
    }"
198,"import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Utility to resolve content-type values based on heuristics.
 *
 * <p>
 * If the specified message is an instance of ContentTypeResolver.ResolvableContentType, the
 * `getContentType()` method will be invoked to attempt to determine the content-type. Otherwise, this
 * will attempt to match the message content to one of the registered rules.
 */
public final class ContentTypeResolver {
  private static final List<ContentTypeRule> DEFAULT_RULES =
      List.of(
          new TextContentTypeRule(),
          new ImageContentTypeRule(),
          new BinaryContentTypeRule(),
          new ApplicationJsonContentTypeRule());

  /** Concurrent map to cache results by message. */
  private static final ConcurrentHashMap<String, String> cache = new ConcurrentHashMap<>();

  /** Default property name used to pull the default content-type for new messages. */
  private static String defaultContentTypeProperty = ""defaultContentType"";

  /**
   * Register additional rules to be applied when resolving the content-type of a message.
   *
   * <p>
   * Rules are applied in the order they are registered. The first rule to match the message will be
   * used to resolve the content-type.
   *
   * @param rule The content-type rule to register.
   */
  public static void addRule(final ContentTypeRule rule) {
    DEFAULT_RULES.add(rule);
  }

  /**
   * Get the default property name used to pull the default content-type for new messages.
   *
   * @return The default property name.
   */
  public static String getDefaultContentTypeProperty() {
    return defaultContentTypeProperty;
  }

  /**
   * Set the default property name used to pull the default content-type for new messages.
   *
   * @param defaultContentTypeProperty The default property name.
   */
  public static void setDefaultContentTypeProperty(final String defaultContentTypeProperty) {
    ContentTypeResolver.defaultContentTypeProperty = defaultContentTypeProperty;
  }

  /** Interface for content-type resolvers. */
  public interface ResolvableContentType {
    /** Return the content-type of the message. */
    String getContentType();
  }

  /**
   * Resolves the content-type for a given message using a series of registered rules.
   *
   * @param message The message to resolve the content-type for.
   * @return The resolved content-type.
   */
  public static String resolveContentType(final Object message) {
    if (message instanceof ResolvableContentType) {
      return ((ResolvableContentType) message).getContentType();
    }
    String value = cache.get(message);
    if (value != null) {
      return value;
    }

    value = resolveInternal(message);
    cache.put(message.toString(), value);
    return value;
  }

  private static String resolveInternal(final Object message) {
    String contentType = null;
    for (ContentTypeRule rule : DEFAULT_RULES) {
      if (rule.test(message)) {
        contentType = rule.getContentType();
        break;
      }
    }

    return contentType;
  }

  /**
   * Rule interface used to determine if a given message should receive a particular content-type.
   */
  public interface ContentTypeRule {
    /** Return true if the rule applies to the given message. */
    boolean test(Object message);

    /** Return the content-type to apply if the rule applies. */
    String getContentType();
  }

  /** Rule to set the content-type to text/plain. */
  private static final class TextContentTypeRule implements ContentTypeRule {
    @Override
    public boolean test(final Object message) {
      return message instanceof String;
    }

    @Override
    public String getContentType() {
      return ""text/plain"";
    }
  }

  /** Rule to set the content-type to image/jpeg. */
  private static final class ImageContentTypeRule implements ContentTypeRule {
    private static final List<String> IMAGE_EXTENSIONS =
        List.of(""gif"", ""jpg"", ""jpeg"", ""bmp"", ""png"", ""svg"");

    @Override
    public boolean test(final Object message) {
      return message instanceof String && IMAGE_EXTENSIONS.stream()
          .anyMatch(((String) message)::endsWith);
    }

    @Override
    public String getContentType() {
      return ""image/jpeg"";
    }
  }

  /** Rule to set the content-type to application/octet-stream. */
  private static final class BinaryContentTypeRule implements ContentTypeRule {
    @Override
    public boolean test(final Object message) {
      return message instanceof byte[];
    }

    @Override
    public String getContentType() {
      return ""application/octet-stream"";
    }
  }

  /** Rule to set the content-type to application/json. */
  private static final class ApplicationJsonContentTypeRule implements ContentTypeRule {
    @Override
    public boolean test(final Object message) {
      return message instanceof String && ((String) message).startsWith(""{"");
    }

    @Override
    public String getContentType() {
      return ""application/json"";
    }
  }

  /** Utilities for working with content types. */
  public static final class ContentTypes {
    /** Check if the given content-type is a MIME multipart content-type. */
    public static boolean isMultipart(final String contentType) {
      return contentType != null && contentType.startsWith(""multipart/"");
    }

    /** Check if the given content-type is a JSON content-type. */
    public static boolean isJson(final String contentType) {
      return contentType != null && contentType.startsWith(""application/json"");
    }

    /** Check if the given content-type is a binary content-type. */
    public static boolean isBinary(final String contentType) {
      return contentType != null
          && (contentType.startsWith(""application/"") || isMultipart(contentType));
    }

    /**
     * Get the default content-type header of the given message.
     *
     * @param message The message to get the default content-type header of.
     * @return The default content-type header.
     */
    public static String getDefaultContentType(final Object message) {
      String contentType = null;
      if (message instanceof Message) {
        contentType = ((Message) message).getDefaultContentType();
      }
      if (contentType == null) {
        contentType = resolveContentType(message);
      }
      return contentType;
    }
  }

  private ContentTypeResolver() {
  }
}"
199,"import com.google.api.ads.admanager.axis.v202202.GetOfferDetailsResponse;
import com.google.api.ads.admanager.axis.v202202.Geo;
import com.google.api.ads.admanager.axis.v202202.Offer;
import com.google.api.ads.admanager.axis.v202202.OfferData;
import com.google.api.ads.admanager.axis.v202202.OfferImage;
import com.google.api.ads.admanager.axis.v202202.OfferImageEntry;
import com.google.api.ads.admanager.axis.v202202.Product;
import com.google.api.ads.admanager.axis.v202202.RedemptionAddress;
import com.google.api.ads.admanager.axis.v202202.Region;
import com.google.api.ads.admanager.axis.v202202.Size;

/**
 * This example gets the specified offer. Offer details should only be requested by the offer's
 * owner. To determine which offers exist, run the GetAllOffers example.
 *
 * <p>Credentials and properties in {@code admanager_api.properties} are used to create a
 * com.google.api.ads.admanager.axis.v202202.AdManagerServiceClient instance.
 *
 * @param offerId the ID of the offer to retrieve
 */
public class GetOfferDetails {

  public static void runExample(long offerId) throws Exception {
    // Generate a refreshable OAuth2 credential.
    GoogleCredentials credential =
        GoogleCredentials.getApplicationDefault()
            .createScoped(Collections.singleton(AdManagerScopes.AD_MANAGER));
    // Construct a com.google.api.ads.admanager.axis.v202202.AdManagerServiceClient instance.
    AdManagerServiceClient client =
        new AdManagerServiceClient.Builder().setHttpRequestInitializer(credential).build();

    // Get the offer.
    OfferData offerDetails = client.getOfferDetailsService().getOfferDetails(offerId);

    // Display the offer details.
    System.out.printf(""Offer ID: %s%n"", offerDetails.getId());
    System.out.printf(""Offer name: %s%n"", offerDetails.getName());
    System.out.printf(""Start date time: %s%n"", offerDetails.getStartTime());
    System.out.printf(""End date time: %s%n"", offerDetails.getEndTime());
    System.out.printf(""Advertiser: %s%n"", offerDetails.getAdvertiserId());
    System.out.printf(""Total slots: %s%n"", offerDetails.getTotalSlots());
    System.out.printf(""Deal ID: %s%n"", offerDetails.getDealId());

    // Display the offer's display information.
    Offer offer = offerDetails.getOffer();
    System.out.printf(""Offer description: %s%n"", offer.getDescription());
    System.out.printf(""Offer terms: %s%n"", offer.getTerms());
    System.out.printf(""Offer deal: %s%n"", offer.getDeal());
    System.out.printf(""Offer URL: %s%n"", offer.getUrl());

    // Display the offer's source geographic targets.
    System.out.println(""Source geographic targets:"");
    for (Geo geo : offerDetails.getSourceGeos()) {
      System.out.printf(""%s : "", geo.getCountry());
      if (geo.getRegion() != null) {
        System.out.printf(""%s : "", geo.getRegion());
      }
      if (geo.getCity() != null) {
        System.out.printf(""%s : "", geo.getCity());
      }
      System.out.println();
    }

    // Display the offer's target geographic targets.
    System.out.println(""Target geographic targets:"");
    for (Geo geo : offerDetails.getTargetGeos()) {
      System.out.printf(""%s : "", geo.getCountry());
      if (geo.getRegion() != null) {
        System.out.printf(""%s : "", geo.getRegion());
      }
      if (geo.getCity() != null) {
        System.out.printf(""%s : "", geo.getCity());
      }
      System.out.println();
    }

    // Display the offer's merchant information.
    System.out.println(""Merchant:"");
    System.out.printf(
        ""%s, %s, %s, %s, %s%n"",
        offerDetails.getMerchant().getName(),
        offerDetails.getMerchant().getPhone(),
        offerDetails.getMerchant().getEmail(),
        offerDetails.getMerchant().getSiteUrl(),
        offerDetails.getMerchant().getLogoUrl());

    // Display the offer's address information.
    for (Address address : offerDetails.getMerchant().getAddresses()) {
      System.out.printf(
          ""%s, %s, %s, %s%n"",
          address.getAddress(),
          address.getAddress2(),
          address.getCity(),
          address.getCountry());
    }

    // Display the offer's redemption addresses.
    for (RedemptionAddress rAddress : offerDetails.getRedemptionAddresses()) {
      System.out.printf(
          ""%s, %s, %s, %s%n"",
          rAddress.getName(),
          rAddress.getAddress(),
          rAddress.getCity(),
          rAddress.getState());
    }

    // Display the offer's media.
    for (OfferImage image : offerDetails.getOfferMedia().getOfferImages()) {
      System.out.println(""Offer image:"");
      for (OfferImageEntry entry : image.getEntries()) {
        Size size = entry.getSize();
        System.out.printf(""  Image size: %sx%s%n"", size.getWidth(), size.getHeight());
        System.out.printf(""  Image URL: %s%n"", entry.getValue().getUrl());
      }
    }

    // Display the offer's products.
    for (Product product : offerDetails.getProducts()) {
      System.out.println(""Product:"");
      System.out.printf(""  Name: %s%n"", product.getName());
      System.out.printf(""  Description: %s%n"", product.getDescription());
      System.out.printf(""  Image URL: %s%n"", product.getImageUrl());
      System.out.printf(""  Link: %s%n"", product.getLink());
      System.out.printf(""  Price: %s%n"", product.getPrice());
    }

    System.out.println(""Marketplace offer service status:"");
    System.out.printf(
        ""  %s%n"",
        offerDetails.getServiceCompatibility().getMarketplaceEnabled()
            ? ""Enabled""
            : ""Disabled"");
  }
}"
200,"// ItemList.java
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class ItemList<T> implements Serializable {
    private static final long serialVersionUID = 1L;
    private List<T> items = new ArrayList<>();
    private ResponseStatus status = ResponseStatus.OK;

    public List<T> getItems() {
        return items;
    }

    public void setItems(List<T> items) {
        this.items = items;
    }

    public ResponseStatus getStatus() {
        return status;
    }

    public void setStatus(ResponseStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return ""ItemList{"" +
                ""items="" + items +
                "", status="" + status +
                '}';
    }
}
// ResponseStatus.java
public enum ResponseStatus {
    OK,
    ERROR
}"
